{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This repository provides all Python tools developed by the COGIP robotic team. The team is developing a robot for Eurobot, French robotic contest.</p> <p>All the tools are used during the game itself, or for development, debugging and monitoring of the robot and other test platforms.</p>"},{"location":"#robot-software-architecture","title":"Robot Software Architecture","text":"<p>The main components of the robot are:</p> <ul> <li>a STM32 that runs <code>mcu-firmware</code>,</li> <li>a Raspberry Pi 4 that controls a camera, a touchscreen and a Lidar.</li> </ul> <p>The robot is associated with a central beacon having an upper view of the game area, composed of a Raspberry Pi 4, a camera and a touchscreen.</p> <p></p> <p>Tools running on the robot's Raspberry Pi 4 are:</p> <ul> <li><code>Server</code> connecting all components through a SocketIO server.</li> <li><code>Dashboard</code> a web server providing a dashboard to control and monitor the robot.</li> <li><code>Planner</code> in charge of the game strategy.</li> <li><code>Copilot</code> driving the robot moves by communicating     with <code>mcu-firmware</code> (on STM32) using Protobuf messages over a serial port.</li> <li><code>Detector</code> generating obstacles based on Lidar data.</li> <li><code>Robotcam</code> reading and analyzing images from the camera.</li> </ul> <p>Tools running on the central beacon's Raspberry Pi 4 are:</p> <ul> <li><code>Server Beacon</code> connecting all beacon components through a SocketIO server,   and connected to the SocketIO server of all robots.     It also runs a web server providing a <code>Dashboard</code> to control and monitor the robot.</li> <li><code>Dashboard Beacon</code>, a web server providing a dashboard to control and monitor the beacon, and display the dashboard of all robots.</li> <li><code>Beaconcam</code> reading and analyzing images of the game area from the camera.</li> </ul> <p>Beacon services will be redesigned and are not yet available. Robots can run standalone.</p> <p><code>Monitor</code> is running on a PC connected to the SocketIO server.</p> <p><code>Camera</code> provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>The touchscreens display the <code>Dashboard</code> using an web browser embedded in the Raspberry Pi.</p>"},{"location":"#emulation-software-architecture","title":"Emulation Software Architecture","text":"<p>During development, an emulation environment is also available. In this case, all robot and beacon components are running on the development PC.</p> <p></p> <p>In this mode, fake Lidar data are provided by the <code>Monitor</code>.</p>"},{"location":"install/","title":"Setup","text":"<p>There are two ways to setup the environment to develop and run the tools.</p> <ul> <li> <p>The Manual method requires to configure the environment on the development computer and to run tools one by one. This method also briefly explains how to build the firmware for the real MCU.</p> </li> <li> <p>The Docker method provides a complete Docker Compose stack that configure, compile and run each tool using only one command.</p> </li> </ul> <p>To prepare SDCards for Raspberry Pi SDCards for robots and beacon, refer to the Raspberry Pi OS section.</p>"},{"location":"install/#common-setup","title":"Common Setup","text":""},{"location":"install/#os","title":"OS","text":"<p>Linux only.</p> <p>Tested on Ubuntu 24.04 (with Xorg instead of Wayland for proper display of the Monitor).</p>"},{"location":"install/#debian-packages","title":"Debian packages","text":"<pre><code>sudo apt install git build-essential\n</code></pre>"},{"location":"install/#git-submodules","title":"Git Submodules","text":"<p>The tools depend on the compatible version of cogip/mcu-firmware which also depends on a specific version of RIOT-OS/RIOT. So to avoid struggle in finding the correct versions of the dependencies, we use git submodules to fix the versions of <code>mcu-firmware</code> and <code>RIOT</code>. Do not forget to fetch the submodules after <code>git clone</code>:</p> <pre><code>git submodule update --init\n</code></pre>"},{"location":"install/#manual-method","title":"Manual Method","text":""},{"location":"install/#debian-packages_1","title":"Debian packages","text":"<pre><code>sudo apt install libxcb-xinerama0 socat protobuf-compiler build-essential swig cmake pkg-config\n</code></pre>"},{"location":"install/#build-mcu-firmware","title":"Build mcu-firmware","text":"<p>See the <code>Requirements</code> section of <code>submodules/mcu-firmware/README.md</code> to setup the build environment.</p> <p>Use the following command to build the native version of the firmware:</p>"},{"location":"install/#native-build","title":"Native build","text":"<pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-native\n</code></pre>"},{"location":"install/#arm-build","title":"ARM build","text":"<p>Use the following command to build the ARM version of the firmware:</p> <pre><code>make -C submodules/mcu-firmware/applications/cup2023 BOARD=cogip-board-ng\n</code></pre>"},{"location":"install/#installation","title":"Installation","text":"<p>All tools can be installed on the development PC.</p> <p>Python installation is managed by uv, so it is independent from Python version provided by the OS.</p> <ul> <li>Install uv following the official documentation, like with the following command:</li> </ul> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Read carefully advices to make uv accessible on your PATH.</p> <ul> <li>Install the required Python version:</li> </ul> <pre><code>uv python install\n</code></pre> <ul> <li>Create a new virtual environment (it will be automatically used by <code>uv</code> commands, no need to source it):</li> </ul> <pre><code>uv venv\n</code></pre> <ul> <li>Patch Python installation:</li> </ul> <p>Note on uv-managed Python installation</p> <p>This Python version is compiled using clang so uv will use clang by default to build wheels with C/C++ extensions. Some packages are not compatible with clang. <code>sysconfigpatcher</code> will revert sysconfig variables to the default values of a Python system installation to use gcc to build wheels.\"</p> <pre><code>uvx --isolated --from \"git+https://github.com/bluss/sysconfigpatcher\" sysconfigpatcher $(dirname $(dirname $(readlink .venv/bin/python)))\n</code></pre> <ul> <li>Install the package in dev/editable mode (default mode for uv):</li> </ul> <pre><code>uv sync\n</code></pre>"},{"location":"install/#linting-and-formatting","title":"Linting and Formatting","text":"<p>While installing the <code>dev</code> environment, <code>ruff</code> and <code>pre-commit</code> package have been installed.</p> <p>To run <code>ruff</code> manually, just run:</p> <pre><code>uv run ruff check [--fix]\nuv run ruff format\n</code></pre> <p>To enable pre-commit hooks prevent committing code not respecting linting and formatting rules, run:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#packaging-and-deployment","title":"Packaging and Deployment","text":"<p>This section explains how to build a new binary package and deploy it on a Raspberry Pi.</p> <p>A Docker Compose service is provided to build a binary distribution package for linux/arm64 platform.</p> <pre><code>docker compose up --build build_wheel\n</code></pre> <p>This will produce <code>dist/cogip_tools-1.0.0-cp312-cp312-linux_aarch64.whl</code>.</p> <p>This package can be copied to the Raspberry Pi and installed to deploy the Python tools:</p> <pre><code>uv pip install cogip_tools-1.0.0-cp312-cp312-linux_aarch64.whl\n</code></pre> <p>Docker image for linux/arm64</p> <p>The <code>build_wheel</code> service is based on a image built from a Ubuntu image. If this image was already pulled for the <code>linux/amd64</code> platform, the <code>linux/arm64</code> may not be pulled automatically. If the <code>docker compose</code> command is failing for this reason, the required image can be pulled manually: <code>bash docker pull --platform \"linux/arm64\" ubuntu:24.04</code></p>"},{"location":"install/#docker-method","title":"Docker Method","text":""},{"location":"install/#docker-installation","title":"Docker Installation","text":"<p>See Docker installation instructions.</p>"},{"location":"install/#virtual-can-interface-setup","title":"Virtual CAN Interface Setup","text":"<p><code>Firmware</code> communicates with <code>Copilot</code> using a CAN interface. In emulation mode, a virtual CAN interface (<code>vcan0</code>) must be configured on host before running the Compose stack.</p> <p>Configure <code>vcan0</code> using the two following files:</p> <ul> <li><code>/etc/systemd/network/80-vcan.network</code></li> </ul> <pre><code>[Match]\nName=vcan0\n\n[CAN]\nBitRate=500000\nDataBitRate=1000000\nSamplePoint=87.5%\nFDMode=yes\n</code></pre> <ul> <li><code>/etc/systemd/network/vcan0.netdev</code></li> </ul> <pre><code>[NetDev]\nName=vcan0\nKind=vcan\nMTUBytes=72\nDescription=Virtual CAN0 network interface\n</code></pre> <p>Restart systemd-networkd service to setup:</p> <pre><code>sudo systemctl restart systemd-networkd\n</code></pre> <p>Check <code>vcan0</code> is up:</p> <pre><code>$ networkctl | grep vcan0\n  3 vcan0           can      carrier     configured```\n\n$ ip address show dev vcan0\n3: vcan0: &lt;NOARP,UP,LOWER_UP&gt; mtu 72 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/can\n</code></pre>"},{"location":"install/#x-server","title":"X Server","text":"<p>The <code>Monitor</code> is working with X11 but does not behave correctly with Wayland.</p> <p>To allow the <code>Monitor</code> process running in a Docker container to access the X Server running on the host, you need to run the following command in a terminal:</p> <p><code>$ xhost +local:</code></p>"},{"location":"install/#configuration","title":"Configuration","text":"<p>The configuration of the tools is done by setting environment variables in the <code>.env</code> file.</p> <p>All variables supported by the tools are forwarded inside Docker containers.</p>"},{"location":"install/#compose-profiles","title":"Compose Profiles","text":"<p>Several profiles are defined to select which containers to run:</p> <ul> <li><code>beacon</code>: for the beacon container</li> <li><code>robotX</code>: for robot X containers (1 &lt;= X &lt;= 4)</li> <li><code>monitorX</code>: for <code>Monitor</code> container of robot X (1 &lt;= X &lt;= 4)</li> </ul> <p>Profiles are set in the <code>.env</code> file:</p> <p><code>COMPOSE_PROFILES=beacon,robot1,robot2</code></p>"},{"location":"install/#build-images","title":"Build Images","text":"<p>Build Docker images:</p> <p><code>docker compose build</code></p>"},{"location":"install/#run-all-tools","title":"Run All Tools","text":"<p>Start the Compose stack:</p> <p><code>docker compose up</code></p> <p>Use <code>--build</code> option to build images and start the stack:</p> <p><code>docker compose up --build</code></p>"},{"location":"install/#automatic-restart-on-changes","title":"Automatic Restart on Changes","text":"<p>To automatically restart the services on Python source files changes or rebuild C++ extensions on C++ source files changes, use the <code>--watch</code> option:</p> <p><code>docker compose up --build --watch</code></p>"},{"location":"install/#dashboards-access","title":"Dashboards Access","text":"<p>The <code>Beacon Dashboard</code> (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:8080</code>.</p> <p>The <code>Dashboard</code> for robot X (if enabled in <code>.env</code>) is accessible using a web browser at <code>http://localhost:808X</code>.</p>"},{"location":"install/#running-monitor","title":"Running Monitor","text":"<p>Instead of running <code>Monitor</code> from the Compose stack, it can be launched for robot X (if enabled in <code>.env</code>) with:</p> <pre><code>uv run cogip-monitor http://localhost:809X\n</code></pre>"},{"location":"raspios/","title":"Raspberry Pi OS Customization","text":"<p>The <code>raspios</code> directory provides a series of scripts to build and flash a custom Raspberry Pi OS images running COGIP tools on the Pi 4 embedded in the beacon and robots.</p> <p>It works by creating a Docker image based on Raspberry Pi OS Lite, use Dockerfiles to install/configure/remove softwares and services, extract and build the customized image, and flash it on a SDCard.</p>"},{"location":"raspios/#network-configuration","title":"Network Configuration","text":"<p>Default network configuration is represented on the following schema:</p> <p></p>"},{"location":"raspios/#requirements","title":"Requirements","text":"<ul> <li>Docker</li> </ul> <p>See Docker installation instructions.</p> <ul> <li>ARM Emulation</li> </ul> <pre><code>$ sudo apt-get install binfmt-support qemu-user-static zerofree\n$ docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n</code></pre>"},{"location":"raspios/#configuration","title":"Configuration","text":"<p>Two configuration profiles are provided:   - <code>cup</code>: a configuration for the cup, to setup robots and beacon   - <code>dev</code>: a configuration for development environment without beacon Select a profile by setting the <code>PROFILE</code> variable to either <code>cup</code> or <code>dev</code>.</p> <p>The following variables must be set before running any script:   - ROBOT_ID   - PUBLIC_WLAN_SSID   - PUBLIC_WLAN_PSK Those variables are set to <code>NOT_SET</code> by default and will be checked will loading the config files.</p> <p><code>ROBOT_ID</code> possible values:   - 0:   for the beacon   - 1-9: for the robots</p> <p>The PSK value can be generated from the WiFi password using the following command:</p> <pre><code>$ wpa_passphrase MYSSID passphrase\nnetwork={\n        ssid=\"MYSSID\"\n        #psk=\"passphrase\"\n        psk=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\n}\n</code></pre> <p>The micro SD card device can be customized using related environment variables Example for micro-SD card to SD card adapter on <code>/dev/mmcblk0</code> (default values):</p> <pre><code>SDCARD_DEV=/dev/mmcblk0\nSDCARD_DEV_BOOT=${SDCARD_DEV}p1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}p2\n</code></pre> <p>Example for micro-SD card to USB adapter on <code>/dev/sda</code>:</p> <pre><code>SDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre> <p>Customized variables can be set in the environment or in a local, not-committed <code>.env</code> file in the <code>raspios</code> directory.</p> <p>Example of a complete <code>.env</code> file:</p> <pre><code>PROFILE=dev\nROBOT_ID=1\nPUBLIC_WLAN_SSID=MYSSID\nPUBLIC_WLAN_PSK=59e0d07fa4c7741797a4e394f38a5c321e3bed51d54ad5fcbd3f84bc7415d73d\nSDCARD_DEV=/dev/sda\nSDCARD_DEV_BOOT=${SDCARD_DEV}1\nSDCARD_DEV_ROOTFS=${SDCARD_DEV}2\n</code></pre>"},{"location":"raspios/#stage-0","title":"Stage 0","text":"<p>First stage builds a docker image from original Raspios image.</p> <pre><code>$ ./stage0_base_image.sh\n</code></pre>"},{"location":"raspios/#stage-1","title":"Stage 1","text":"<p>Build a customized docker image:  - install required Debian and Python packages  - configure required services  - install COGIP tools</p> <pre><code>$ ./stage1_customize_image.sh\n</code></pre>"},{"location":"raspios/#stage-1b-under-development","title":"Stage 1b (under development)","text":"<p>This stage is optional and allow to build a custom kernel image. It is not working yet so not documented.</p>"},{"location":"raspios/#stage-2","title":"Stage 2","text":"<p>Create the custom filesystem image.</p> <pre><code>$ ./stage2_create_image.sh\n</code></pre>"},{"location":"raspios/#stage-3","title":"Stage 3","text":"<p>Flash the filesystem image on SDCard.</p> <pre><code>$ ./stage3_flash_image.sh\n</code></pre>"},{"location":"developers/dashboard/","title":"Dashboard documentation","text":"<p>The dashboard is written with vanilla JS, CSS and HTML (and love). We made the choice to not used any frameworks like Angular or Vue.js... because dashboard is a very small web site.</p> <p>This dashboard uses only two externals frameworks, which are Bootstrap and Socket.io.</p> <p>Socket.io is useful to dynamically receive events from Copilot and display them.</p> <p>Bootstrap is a framework very powerful which comes with layout conception (grid to help us with responsively) and components (like modal that we use). But Bootstrap is a very large and heavy framework and we only use a percentage of what it offers. So we made the choice to purge it to reduce loading time on dashboard.</p> <p>The manipulation below needs to be done each time we add or remove a class in html, css or js files in server.</p> <p>This command line has to be executed in <code>cogip-tools/cogip/tools/dashboard</code> or <code>cogip-tools/cogip/tools/dashboard_beacon</code>.</p> <ol> <li> <p>Install npm    <code>sudo apt install npm</code></p> </li> <li> <p>Install PurgeCSS as CLI (you may need to be super user)    <code>npm i -g purgecss</code></p> </li> <li> <p>Run command to purge Bootstrap file according to what we use in our html, js and css files    <code>purgecss -css static/css/external/bootstrap-5.3.3.min.css --content templates/dashboard.html static/js/*.js --output static/css/purged</code></p> </li> </ol> <p>Useful documentation:</p> <ul> <li>https://purgecss.com/CLI.html</li> </ul>"},{"location":"developers/developers/","title":"Developer's Documentation","text":"<p>This documentation provides information for developers who would like to contribute to the project. It tries to explain how modules are organized and how <code>PySide6</code> and <code>Qt3D</code> are used.</p> <p>COGIP tools are developed in Python 3.12+, using <code>Pyside6</code>, the Qt for Python package.</p> <p>The 3D view is based on the <code>Qt3D framework</code>. To have a better understanding of the code, it is important to understand Qt concepts like Signals and Slots, and the Qt3D Entity Component System (ECS).</p> <p>Here are some interesting blogs and docs to understand the Qt3D architecture:</p> <ul> <li>https://doc.qt.io/qt-6/qt3d-overview.html#qt-3d-architecture</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-1/</li> <li>https://www.kdab.com/overview-qt3d-2-0-part-2/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-1-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-2-guido-piasenza/</li> <li>https://www.linkedin.com/pulse/3d-visualisation-using-qt3d-part-3-guido-piasenza/</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cogip<ul> <li>entities<ul> <li>artifacts</li> <li>asset</li> <li>dynobstacle</li> <li>impact</li> <li>line</li> <li>obstacle</li> <li>path</li> <li>robot</li> <li>robot_manual</li> <li>robot_order</li> <li>sensor</li> <li>table</li> </ul> </li> <li>models<ul> <li>actuators</li> <li>artifacts</li> <li>models</li> </ul> </li> <li>tools<ul> <li>beaconcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>codecs</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>camera<ul> <li>__main__</li> <li>arguments</li> <li>calibrate</li> <li>capture</li> <li>detect</li> <li>info</li> <li>utils</li> </ul> </li> <li>cansend<ul> <li>__main__</li> </ul> </li> <li>copilot<ul> <li>__main__</li> <li>controller</li> <li>copilot</li> <li>menu</li> <li>pbcom</li> <li>pid</li> <li>sio_events</li> </ul> </li> <li>copilot_pami<ul> <li>__main__</li> <li>controller</li> <li>copilot</li> <li>menu</li> <li>pbcom</li> <li>pid</li> <li>sio_events</li> </ul> </li> <li>cpp_example<ul> <li>__main__</li> </ul> </li> <li>dashboard<ul> <li>__main__</li> <li>app</li> <li>dashboard</li> <li>routes<ul> <li>beacon</li> </ul> </li> </ul> </li> <li>dashboard_beacon<ul> <li>__main__</li> <li>app</li> <li>dashboard</li> <li>routes<ul> <li>beacon</li> </ul> </li> </ul> </li> <li>detector<ul> <li>__main__</li> <li>detector</li> <li>menu</li> <li>properties</li> <li>sio_events</li> </ul> </li> <li>detector_pami<ul> <li>__main__</li> <li>detector</li> <li>menu</li> <li>properties</li> <li>sio_events</li> </ul> </li> <li>lidarusb<ul> <li>__main__</li> <li>dataproxy</li> <li>lidar</li> <li>main</li> <li>mainwindow</li> </ul> </li> <li>monitor<ul> <li>__main__</li> <li>main</li> <li>mainwindow</li> <li>robots</li> <li>socketiocontroller</li> </ul> </li> <li>planner<ul> <li>__main__</li> <li>actions<ul> <li>actions</li> <li>back_and_forth</li> <li>base_actions</li> <li>camera_calibration</li> <li>game_grip_first</li> <li>game_solar_first</li> <li>pami</li> <li>position_test</li> <li>solar_panels</li> <li>speed_test</li> <li>test_align</li> <li>test_dropoff</li> <li>test_grip</li> <li>test_planters</li> <li>test_pot_capture</li> <li>test_solar_panels</li> </ul> </li> <li>actuators</li> <li>avoidance<ul> <li>avoidance</li> <li>debug</li> <li>process</li> <li>visibility_road_map<ul> <li>dijkstra_search</li> <li>geometry</li> <li>visibility_road_map</li> </ul> </li> </ul> </li> <li>cameras</li> <li>camp</li> <li>context</li> <li>menu</li> <li>planner</li> <li>pose</li> <li>positions</li> <li>properties</li> <li>sio_events</li> <li>table</li> <li>wizard</li> </ul> </li> <li>replay<ul> <li>__main__</li> <li>main</li> <li>mainwindow</li> </ul> </li> <li>robotcam<ul> <li>__main__</li> <li>app</li> <li>camera</li> <li>main</li> <li>server</li> <li>settings</li> </ul> </li> <li>server<ul> <li>__main__</li> <li>app</li> <li>context</li> <li>namespaces<ul> <li>beacon</li> <li>copilot</li> <li>dashboard</li> <li>detector</li> <li>monitor</li> <li>planner</li> <li>robotcam</li> </ul> </li> <li>recorder</li> <li>server</li> </ul> </li> <li>server_beacon<ul> <li>__main__</li> <li>app</li> <li>menu</li> <li>namespaces<ul> <li>dashboard</li> </ul> </li> <li>robot</li> <li>server</li> </ul> </li> </ul> </li> <li>utils<ul> <li>argenum</li> <li>asyncloop</li> <li>lidartablemodel</li> <li>singleton</li> <li>threadloop</li> </ul> </li> <li>widgets<ul> <li>actuators</li> <li>chartsview</li> <li>gameview</li> <li>help</li> <li>lidarview</li> <li>properties</li> <li>wizard</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cogip/entities/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/entities/asset/","title":"asset","text":"<p>This module defines the base class AssetEntity used directly or inherited for specific assets.</p> <p>Asset entities are graphic element displayed on the 3D view and loaded from asset files. It is typically used for table and robot assets.</p> <p>Supported asset files are in Collada format (<code>.dae</code>). Other formats could be also supported, but not tested (see Open Asset Import Library).</p>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.AssetEntity","title":"<code>AssetEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>Base class for asset entities</p> <p>This class inherits from <code>Qt3DCore.QEntity</code></p> <p>Attributes:</p> Name Type Description <code>ready</code> <code>Signal</code> <p>Qt signal emitted when the asset entity is ready to be used</p> <code>asset_ready</code> <code>bool</code> <p><code>True</code> if the asset is ready</p> <code>asset_entity</code> <code>QEntity</code> <p>first useful <code>QEntity</code> in the asset tree</p> <code>transform_component</code> <p><code>QTransform</code> holding the asset's translation and orientation</p> Source code in <code>cogip/entities/asset.py</code> <pre><code>class AssetEntity(Qt3DCore.QEntity):\n    \"\"\"Base class for asset entities\n\n    This class inherits from [`Qt3DCore.QEntity`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DCore/QEntity.html)\n\n    Attributes:\n        ready: Qt signal emitted when the asset entity is ready to be used\n        asset_ready: `True` if the asset is ready\n        asset_entity: first useful `QEntity` in the asset tree\n        transform_component: `QTransform` holding the asset's translation and orientation\n    \"\"\"\n\n    ready: qtSignal = qtSignal()\n\n    def __init__(self, asset_path: Path, scale: float = 1.0, parent: Qt3DCore.QEntity = None):\n        \"\"\"\n        The constructor checks the asset's file and starts loading the entity.\n\n        The entity load is asynchronous, a signal is emitted when it is done\n        (see [`on_loader_status_changed`][cogip.entities.asset.AssetEntity.on_loader_status_changed])\n\n        Arguments:\n            asset_path: path of the asset file\n            scale: scale to apply to the entity after load\n        \"\"\"\n\n        super().__init__(parent)\n\n        self.asset_ready: bool = False\n        self.asset_path: Path = asset_path\n        self.scale: float = scale\n        self.asset_entity: Qt3DCore.QEntity = None\n\n        self.transform_component = Qt3DCore.QTransform()\n        self.addComponent(self.transform_component)\n\n        if not self.asset_path.exists():\n            raise FileNotFoundError(f\"File not found '{self.asset_path}'\")\n        if not self.asset_path.is_file():\n            raise IsADirectoryError(f\"'{self.asset_path}' is not a file\")\n\n        self.loader = Qt3DRender.QSceneLoader(self)\n        self.loader.statusChanged.connect(self.on_loader_status_changed)\n        self.loader.setObjectName(self.asset_path.name)\n        self.addComponent(self.loader)\n        self.loader.setSource(QtCore.QUrl(f\"file:{self.asset_path}\"))\n\n    @qtSlot(Qt3DRender.QSceneLoader.Status)\n    def on_loader_status_changed(self, status: Qt3DRender.QSceneLoader.Status):\n        \"\"\"\n        When the loader has finished, clean the entity tree,\n        record the main `QEntity` and its `QTransform` component.\n\n        Then it generated the dot tree\n        (see [`generate_tree`][cogip.entities.asset.AssetEntity.generate_tree]),\n        run the [`post_init`][cogip.entities.asset.AssetEntity.post_init] pass,\n        and emit the `ready` signal.\n\n        Arguments:\n            status: current loader status\n        \"\"\"\n        if (\n            status.value != Qt3DRender.QSceneLoader.Ready.value\n        ):  # .value is workaround to a Python binding bug in PySide6 6.4.\n            return\n\n        self.post_init()\n\n        self.generate_tree()\n\n        self.asset_ready = True\n\n        self.ready.emit()\n\n    def generate_tree(self):\n        \"\"\"\n        Generate a tree of all entities and components starting from the main entity.\n\n        The generated file is stored next to the asset file and it has the same name\n        but with `.tree.dot` extension.\n\n        It is a text file written in [Graphviz](https://graphviz.org/) format.\n\n        To read this file:\n        ```bash\n            sudo apt install graphviz okular\n            dot -Tpdf assets/robot2019.tree.dot | okular -\n        ```\n        \"\"\"\n\n        tree_filename = self.asset_path.with_suffix(\".tree.dot\")\n        with tree_filename.open(mode=\"w\") as fd:\n            fd.write('graph \"\"\\n')\n            fd.write(\"{\\n\")\n            fd.write('label=\"Entity tree\"\\n')\n            root_node_number = 0\n            traverse_tree(self, root_node_number, fd)\n            fd.write(\"}\\n\")\n\n    def post_init(self):\n        \"\"\"\n        Post initialization method that can be overloaded.\n        It it executed after entity and transform components are ready.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.AssetEntity.__init__","title":"<code>__init__(asset_path, scale=1.0, parent=None)</code>","text":"<p>The constructor checks the asset's file and starts loading the entity.</p> <p>The entity load is asynchronous, a signal is emitted when it is done (see <code>on_loader_status_changed</code>)</p> <p>Parameters:</p> Name Type Description Default <code>asset_path</code> <code>Path</code> <p>path of the asset file</p> required <code>scale</code> <code>float</code> <p>scale to apply to the entity after load</p> <code>1.0</code> Source code in <code>cogip/entities/asset.py</code> <pre><code>def __init__(self, asset_path: Path, scale: float = 1.0, parent: Qt3DCore.QEntity = None):\n    \"\"\"\n    The constructor checks the asset's file and starts loading the entity.\n\n    The entity load is asynchronous, a signal is emitted when it is done\n    (see [`on_loader_status_changed`][cogip.entities.asset.AssetEntity.on_loader_status_changed])\n\n    Arguments:\n        asset_path: path of the asset file\n        scale: scale to apply to the entity after load\n    \"\"\"\n\n    super().__init__(parent)\n\n    self.asset_ready: bool = False\n    self.asset_path: Path = asset_path\n    self.scale: float = scale\n    self.asset_entity: Qt3DCore.QEntity = None\n\n    self.transform_component = Qt3DCore.QTransform()\n    self.addComponent(self.transform_component)\n\n    if not self.asset_path.exists():\n        raise FileNotFoundError(f\"File not found '{self.asset_path}'\")\n    if not self.asset_path.is_file():\n        raise IsADirectoryError(f\"'{self.asset_path}' is not a file\")\n\n    self.loader = Qt3DRender.QSceneLoader(self)\n    self.loader.statusChanged.connect(self.on_loader_status_changed)\n    self.loader.setObjectName(self.asset_path.name)\n    self.addComponent(self.loader)\n    self.loader.setSource(QtCore.QUrl(f\"file:{self.asset_path}\"))\n</code></pre>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.AssetEntity.generate_tree","title":"<code>generate_tree()</code>","text":"<p>Generate a tree of all entities and components starting from the main entity.</p> <p>The generated file is stored next to the asset file and it has the same name but with <code>.tree.dot</code> extension.</p> <p>It is a text file written in Graphviz format.</p> <p>To read this file:</p> <pre><code>    sudo apt install graphviz okular\n    dot -Tpdf assets/robot2019.tree.dot | okular -\n</code></pre> Source code in <code>cogip/entities/asset.py</code> <pre><code>def generate_tree(self):\n    \"\"\"\n    Generate a tree of all entities and components starting from the main entity.\n\n    The generated file is stored next to the asset file and it has the same name\n    but with `.tree.dot` extension.\n\n    It is a text file written in [Graphviz](https://graphviz.org/) format.\n\n    To read this file:\n    ```bash\n        sudo apt install graphviz okular\n        dot -Tpdf assets/robot2019.tree.dot | okular -\n    ```\n    \"\"\"\n\n    tree_filename = self.asset_path.with_suffix(\".tree.dot\")\n    with tree_filename.open(mode=\"w\") as fd:\n        fd.write('graph \"\"\\n')\n        fd.write(\"{\\n\")\n        fd.write('label=\"Entity tree\"\\n')\n        root_node_number = 0\n        traverse_tree(self, root_node_number, fd)\n        fd.write(\"}\\n\")\n</code></pre>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.AssetEntity.on_loader_status_changed","title":"<code>on_loader_status_changed(status)</code>","text":"<p>When the loader has finished, clean the entity tree, record the main <code>QEntity</code> and its <code>QTransform</code> component.</p> <p>Then it generated the dot tree (see <code>generate_tree</code>), run the <code>post_init</code> pass, and emit the <code>ready</code> signal.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>Status</code> <p>current loader status</p> required Source code in <code>cogip/entities/asset.py</code> <pre><code>@qtSlot(Qt3DRender.QSceneLoader.Status)\ndef on_loader_status_changed(self, status: Qt3DRender.QSceneLoader.Status):\n    \"\"\"\n    When the loader has finished, clean the entity tree,\n    record the main `QEntity` and its `QTransform` component.\n\n    Then it generated the dot tree\n    (see [`generate_tree`][cogip.entities.asset.AssetEntity.generate_tree]),\n    run the [`post_init`][cogip.entities.asset.AssetEntity.post_init] pass,\n    and emit the `ready` signal.\n\n    Arguments:\n        status: current loader status\n    \"\"\"\n    if (\n        status.value != Qt3DRender.QSceneLoader.Ready.value\n    ):  # .value is workaround to a Python binding bug in PySide6 6.4.\n        return\n\n    self.post_init()\n\n    self.generate_tree()\n\n    self.asset_ready = True\n\n    self.ready.emit()\n</code></pre>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.AssetEntity.post_init","title":"<code>post_init()</code>","text":"<p>Post initialization method that can be overloaded. It it executed after entity and transform components are ready.</p> Source code in <code>cogip/entities/asset.py</code> <pre><code>def post_init(self):\n    \"\"\"\n    Post initialization method that can be overloaded.\n    It it executed after entity and transform components are ready.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogip/entities/asset/#cogip.entities.asset.traverse_tree","title":"<code>traverse_tree(node, next_node_nb, fd)</code>","text":"<p>Recursive function traversing all child entities and write its node and all its components to the .dot file.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>QEntity</code> <p>entity to traverse</p> required <code>next_node_nb</code> <code>int</code> <p>next node number</p> required <code>fd</code> <code>TextIO</code> <p>opened file descriptor used to write the tree</p> required Return <p>tuple of current and next node numbers</p> Source code in <code>cogip/entities/asset.py</code> <pre><code>def traverse_tree(node: Qt3DCore.QEntity, next_node_nb: int, fd: TextIO) -&gt; tuple[int, int]:\n    \"\"\"\n    Recursive function traversing all child entities and write its node\n    and all its components to the .dot file.\n\n    Arguments:\n        node: entity to traverse\n        next_node_nb: next node number\n        fd: opened file descriptor used to write the tree\n\n    Return:\n        tuple of current and next node numbers\n    \"\"\"\n\n    current_node_nb = next_node_nb\n    next_node_nb += 1\n\n    # Insert current node in the tree\n    fd.write(f'n{current_node_nb:03d} [label=\"{node.metaObject().className()}\\n{node.objectName()}\"] ;\\n')\n\n    # Enumerate components\n    for comp in node.components():\n        fd.write(f'n{next_node_nb:03d} [shape=box,label=\"{comp.metaObject().className()}\\n{comp.objectName()}\"] ;\\n')\n        fd.write(f\"n{current_node_nb:03d} -- n{next_node_nb:03d} [style=dotted];\\n\")\n        next_node_nb += 1\n\n    # Build tree for children\n    for child_node in node.children():\n        if isinstance(child_node, Qt3DCore.QEntity):\n            child_node_nb, next_node_nb = traverse_tree(child_node, next_node_nb, fd)\n            fd.write(f\"n{current_node_nb:03d} -- n{child_node_nb:03d} ;\\n\")\n\n    return current_node_nb, next_node_nb\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/","title":"dynobstacle","text":""},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynBaseObstacleEntity","title":"<code>DynBaseObstacleEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A dynamic obstacle detected by the robot.</p> <p>Base class for rectangle and circle obstacles.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>class DynBaseObstacleEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A dynamic obstacle detected by the robot.\n\n    Base class for rectangle and circle obstacles.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.parent = parent\n        self.points = []\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setDiffuse(QtGui.QColor.fromRgb(255, 0, 0, 100))\n        self.material.setDiffuse(QtGui.QColor.fromRgb(255, 0, 0, 100))\n        self.material.setSpecular(QtGui.QColor.fromRgb(255, 0, 0, 100))\n        self.material.setShininess(1.0)\n        self.material.setAlphaBlendingEnabled(True)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.addComponent(self.transform)\n\n        self.bb = PathEntity(QtCore.Qt.darkRed, self.parent)\n\n    def set_bounding_box(self, points: list[models.Vertex]) -&gt; None:\n        if self.points == points:\n            return\n\n        self.points = points\n        bb_points = []\n        if points:\n            for point in points:\n                bb_points.append(models.Vertex(x=point.x, y=point.y, z=5))\n            bb_points.append(models.Vertex(x=points[0].x, y=points[0].y, z=5))\n        self.bb.set_points(bb_points)\n\n    def setEnabled(self, isEnabled: bool) -&gt; None:\n        super().setEnabled(isEnabled)\n        self.bb.setEnabled(isEnabled)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynBaseObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.parent = parent\n    self.points = []\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setDiffuse(QtGui.QColor.fromRgb(255, 0, 0, 100))\n    self.material.setDiffuse(QtGui.QColor.fromRgb(255, 0, 0, 100))\n    self.material.setSpecular(QtGui.QColor.fromRgb(255, 0, 0, 100))\n    self.material.setShininess(1.0)\n    self.material.setAlphaBlendingEnabled(True)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.addComponent(self.transform)\n\n    self.bb = PathEntity(QtCore.Qt.darkRed, self.parent)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynCircleObstacleEntity","title":"<code>DynCircleObstacleEntity</code>","text":"<p>               Bases: <code>DynBaseObstacleEntity</code></p> <p>A dynamic circle obstacle detected by the robot.</p> <p>Represented as a transparent red cylinder.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>class DynCircleObstacleEntity(DynBaseObstacleEntity):\n    \"\"\"\n    A dynamic circle obstacle detected by the robot.\n\n    Represented as a transparent red cylinder.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.position: tuple[int, int, int] = None\n\n        self.mesh = Qt3DExtras.QCylinderMesh()\n        self.mesh.setLength(200)\n        self.mesh.setRadius(400)\n        self.addComponent(self.mesh)\n\n        self.transform.setRotationX(90)\n\n    def set_position(self, x: int, y: int, radius: int) -&gt; None:\n        \"\"\"\n        Set the position and size of the dynamic obstacle.\n\n        Arguments:\n            x: Center X position\n            y: Center Y position\n            radius: Obstacle radius\n        \"\"\"\n        if self.position == (x, y, radius):\n            return\n        self.position = (x, y, radius)\n\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.length() / 2))\n        self.mesh.setRadius(radius)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynCircleObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.position: tuple[int, int, int] = None\n\n    self.mesh = Qt3DExtras.QCylinderMesh()\n    self.mesh.setLength(200)\n    self.mesh.setRadius(400)\n    self.addComponent(self.mesh)\n\n    self.transform.setRotationX(90)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynCircleObstacleEntity.set_position","title":"<code>set_position(x, y, radius)</code>","text":"<p>Set the position and size of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Center X position</p> required <code>y</code> <code>int</code> <p>Center Y position</p> required <code>radius</code> <code>int</code> <p>Obstacle radius</p> required Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def set_position(self, x: int, y: int, radius: int) -&gt; None:\n    \"\"\"\n    Set the position and size of the dynamic obstacle.\n\n    Arguments:\n        x: Center X position\n        y: Center Y position\n        radius: Obstacle radius\n    \"\"\"\n    if self.position == (x, y, radius):\n        return\n    self.position = (x, y, radius)\n\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.length() / 2))\n    self.mesh.setRadius(radius)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynRectObstacleEntity","title":"<code>DynRectObstacleEntity</code>","text":"<p>               Bases: <code>DynBaseObstacleEntity</code></p> <p>A dynamic rectangle obstacle detected by the robot.</p> <p>Represented as a transparent red cube.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>class DynRectObstacleEntity(DynBaseObstacleEntity):\n    \"\"\"\n    A dynamic rectangle obstacle detected by the robot.\n\n    Represented as a transparent red cube.\n    \"\"\"\n\n    def __init__(self, parent: Qt3DCore.QEntity):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n        self.size: tuple[int, int] = None\n        self.position: tuple[int, int, int] = None\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setZExtent(200)\n        self.addComponent(self.mesh)\n\n    def set_size(self, length: int, width: int) -&gt; None:\n        \"\"\"\n        Set the size of the dynamic obstacle.\n\n        Arguments:\n            length: Length\n            width: Width\n        \"\"\"\n        if self.size == (length, width):\n            return\n\n        self.size = (length, width)\n\n        self.mesh.setXExtent(width)\n        self.mesh.setYExtent(length)\n\n    def set_position(self, x: int, y: int, rotation: int) -&gt; None:\n        \"\"\"\n        Set the position and orientation of the dynamic obstacle.\n\n        Arguments:\n            x: X position\n            y: Y position\n            rotation: Rotation\n        \"\"\"\n        if self.position == (x, y, rotation):\n            return\n\n        self.position = (x, y, rotation)\n\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n        self.transform.setRotationZ(rotation)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynRectObstacleEntity.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n    self.size: tuple[int, int] = None\n    self.position: tuple[int, int, int] = None\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setZExtent(200)\n    self.addComponent(self.mesh)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynRectObstacleEntity.set_position","title":"<code>set_position(x, y, rotation)</code>","text":"<p>Set the position and orientation of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X position</p> required <code>y</code> <code>int</code> <p>Y position</p> required <code>rotation</code> <code>int</code> <p>Rotation</p> required Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def set_position(self, x: int, y: int, rotation: int) -&gt; None:\n    \"\"\"\n    Set the position and orientation of the dynamic obstacle.\n\n    Arguments:\n        x: X position\n        y: Y position\n        rotation: Rotation\n    \"\"\"\n    if self.position == (x, y, rotation):\n        return\n\n    self.position = (x, y, rotation)\n\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n    self.transform.setRotationZ(rotation)\n</code></pre>"},{"location":"reference/cogip/entities/dynobstacle/#cogip.entities.dynobstacle.DynRectObstacleEntity.set_size","title":"<code>set_size(length, width)</code>","text":"<p>Set the size of the dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length</p> required <code>width</code> <code>int</code> <p>Width</p> required Source code in <code>cogip/entities/dynobstacle.py</code> <pre><code>def set_size(self, length: int, width: int) -&gt; None:\n    \"\"\"\n    Set the size of the dynamic obstacle.\n\n    Arguments:\n        length: Length\n        width: Width\n    \"\"\"\n    if self.size == (length, width):\n        return\n\n    self.size = (length, width)\n\n    self.mesh.setXExtent(width)\n    self.mesh.setYExtent(length)\n</code></pre>"},{"location":"reference/cogip/entities/impact/","title":"impact","text":""},{"location":"reference/cogip/entities/impact/#cogip.entities.impact.ImpactEntity","title":"<code>ImpactEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p><code>QEntity</code> used to visualize to points detected by sensors.</p> <p>It is represented with <code>QSphereMesh</code>, its radius and color are configurable in the constructor.</p> Source code in <code>cogip/entities/impact.py</code> <pre><code>class ImpactEntity(Qt3DCore.QEntity):\n    \"\"\"\n    `QEntity` used to visualize to points detected by sensors.\n\n    It is represented with [`QSphereMesh`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QSphereMesh.html),\n    its radius and color are configurable in the constructor.\n    \"\"\"\n\n    def __init__(self, radius: float = 50, color: QtCore.Qt.GlobalColor = QtCore.Qt.red):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            radius: Radius of the sphere\n            color: Color of the sphere\n        \"\"\"\n        super().__init__()\n\n        self.mesh = Qt3DExtras.QSphereMesh()\n        self.mesh.setRadius(radius)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial()\n        self.material.setDiffuse(QtGui.QColor(color))\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform()\n        self.addComponent(self.transform)\n        self.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/entities/impact/#cogip.entities.impact.ImpactEntity.__init__","title":"<code>__init__(radius=50, color=QtCore.Qt.red)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Radius of the sphere</p> <code>50</code> <code>color</code> <code>GlobalColor</code> <p>Color of the sphere</p> <code>red</code> Source code in <code>cogip/entities/impact.py</code> <pre><code>def __init__(self, radius: float = 50, color: QtCore.Qt.GlobalColor = QtCore.Qt.red):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        radius: Radius of the sphere\n        color: Color of the sphere\n    \"\"\"\n    super().__init__()\n\n    self.mesh = Qt3DExtras.QSphereMesh()\n    self.mesh.setRadius(radius)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial()\n    self.material.setDiffuse(QtGui.QColor(color))\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform()\n    self.addComponent(self.transform)\n    self.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/entities/line/","title":"line","text":""},{"location":"reference/cogip/entities/line/#cogip.entities.line.LineEntity","title":"<code>LineEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A simple entity drawing a line between two vertices.</p> Source code in <code>cogip/entities/line.py</code> <pre><code>class LineEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A simple entity drawing a line between two vertices.\n    \"\"\"\n\n    def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            color: color\n            parent: parent entity\n        \"\"\"\n        super().__init__(parent)\n        self.color = color\n\n        self.geometry = Qt3DCore.QGeometry(self)\n\n        self.position_buffer = Qt3DCore.QBuffer(self.geometry)\n\n        self.position_attribute = Qt3DCore.QAttribute(self.geometry)\n        self.position_attribute.setName(Qt3DCore.QAttribute.defaultPositionAttributeName())\n        self.position_attribute.setAttributeType(Qt3DCore.QAttribute.VertexAttribute)\n        self.position_attribute.setVertexBaseType(Qt3DCore.QAttribute.Float)\n        self.position_attribute.setVertexSize(3)\n        self.position_attribute.setCount(2)\n        self.position_attribute.setBuffer(self.position_buffer)\n        self.geometry.addAttribute(self.position_attribute)\n\n        # Connectivity between vertices\n        self.indices = array(\"I\", [0, 1])\n        self.indices_bytes = QtCore.QByteArray(self.indices.tobytes())\n        self.indices_buffer = Qt3DCore.QBuffer(self.geometry)\n        self.indices_buffer.setData(self.indices_bytes)\n\n        self.indices_attribute = Qt3DCore.QAttribute(self.geometry)\n        self.indices_attribute.setVertexBaseType(Qt3DCore.QAttribute.UnsignedInt)\n        self.indices_attribute.setAttributeType(Qt3DCore.QAttribute.IndexAttribute)\n        self.indices_attribute.setBuffer(self.indices_buffer)\n        self.indices_attribute.setCount(2)\n        self.geometry.addAttribute(self.indices_attribute)\n\n        # Mesh\n        self.line = Qt3DRender.QGeometryRenderer(self)\n        self.line.setGeometry(self.geometry)\n        self.line.setPrimitiveType(Qt3DRender.QGeometryRenderer.Lines)\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.material.setAmbient(self.color)\n\n        # Entity\n        self.addComponent(self.line)\n        self.addComponent(self.material)\n\n    def set_points(self, start: models.Vertex, end: models.Vertex):\n        \"\"\"\n        Set start and end vertices.\n\n        Arguments:\n            start: start position\n            end: end position\n        \"\"\"\n\n        # Position vertices (start and end)\n        positions = array(\"f\")\n        positions.fromlist([start.x, start.y, start.z])\n        positions.fromlist([end.x, end.y, end.z])\n        buffer_bytes = QtCore.QByteArray(positions.tobytes())\n        self.position_buffer.setData(buffer_bytes)\n</code></pre>"},{"location":"reference/cogip/entities/line/#cogip.entities.line.LineEntity.__init__","title":"<code>__init__(color=QtCore.Qt.blue, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>color</p> <code>blue</code> <code>parent</code> <code>QEntity | None</code> <p>parent entity</p> <code>None</code> Source code in <code>cogip/entities/line.py</code> <pre><code>def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        color: color\n        parent: parent entity\n    \"\"\"\n    super().__init__(parent)\n    self.color = color\n\n    self.geometry = Qt3DCore.QGeometry(self)\n\n    self.position_buffer = Qt3DCore.QBuffer(self.geometry)\n\n    self.position_attribute = Qt3DCore.QAttribute(self.geometry)\n    self.position_attribute.setName(Qt3DCore.QAttribute.defaultPositionAttributeName())\n    self.position_attribute.setAttributeType(Qt3DCore.QAttribute.VertexAttribute)\n    self.position_attribute.setVertexBaseType(Qt3DCore.QAttribute.Float)\n    self.position_attribute.setVertexSize(3)\n    self.position_attribute.setCount(2)\n    self.position_attribute.setBuffer(self.position_buffer)\n    self.geometry.addAttribute(self.position_attribute)\n\n    # Connectivity between vertices\n    self.indices = array(\"I\", [0, 1])\n    self.indices_bytes = QtCore.QByteArray(self.indices.tobytes())\n    self.indices_buffer = Qt3DCore.QBuffer(self.geometry)\n    self.indices_buffer.setData(self.indices_bytes)\n\n    self.indices_attribute = Qt3DCore.QAttribute(self.geometry)\n    self.indices_attribute.setVertexBaseType(Qt3DCore.QAttribute.UnsignedInt)\n    self.indices_attribute.setAttributeType(Qt3DCore.QAttribute.IndexAttribute)\n    self.indices_attribute.setBuffer(self.indices_buffer)\n    self.indices_attribute.setCount(2)\n    self.geometry.addAttribute(self.indices_attribute)\n\n    # Mesh\n    self.line = Qt3DRender.QGeometryRenderer(self)\n    self.line.setGeometry(self.geometry)\n    self.line.setPrimitiveType(Qt3DRender.QGeometryRenderer.Lines)\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.material.setAmbient(self.color)\n\n    # Entity\n    self.addComponent(self.line)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/entities/line/#cogip.entities.line.LineEntity.set_points","title":"<code>set_points(start, end)</code>","text":"<p>Set start and end vertices.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Vertex</code> <p>start position</p> required <code>end</code> <code>Vertex</code> <p>end position</p> required Source code in <code>cogip/entities/line.py</code> <pre><code>def set_points(self, start: models.Vertex, end: models.Vertex):\n    \"\"\"\n    Set start and end vertices.\n\n    Arguments:\n        start: start position\n        end: end position\n    \"\"\"\n\n    # Position vertices (start and end)\n    positions = array(\"f\")\n    positions.fromlist([start.x, start.y, start.z])\n    positions.fromlist([end.x, end.y, end.z])\n    buffer_bytes = QtCore.QByteArray(positions.tobytes())\n    self.position_buffer.setData(buffer_bytes)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/","title":"obstacle","text":""},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity","title":"<code>ObstacleEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>An obstacle on the table.</p> <p>It is represented as a cube (QCuboidMesh).</p> <p>When selected with a mouse click, a property window is displayed to modify the obstacle properties.</p> <p>The obstacle can also be moved using the mouse.</p> <p>Attributes:</p> Name Type Description <code>enable_controller</code> <p>Qt signal used to disable the camera controller when moving the obstacle using the mouse</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>class ObstacleEntity(Qt3DCore.QEntity):\n    \"\"\"\n    An obstacle on the table.\n\n    It is represented as a cube ([QCuboidMesh](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QCuboidMesh.html)).\n\n    When selected with a mouse click, a property window is displayed\n    to modify the obstacle properties.\n\n    The obstacle can also be moved using the mouse.\n\n    Attributes:\n        enable_controller: Qt signal used to disable the camera controller\n            when moving the obstacle using the mouse\n    \"\"\"\n\n    enable_controller = qtSignal(bool)\n\n    def __init__(\n        self,\n        parent_widget: QtWidgets.QWidget,\n        x: int = 0,\n        y: int = 0,\n        rotation: int = 0,\n        length: int = 225,\n        width: int = 225,\n        height: int = 350,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent_widget: Parent widget\n            x: X position\n            y: Y position\n            rotation: Rotation\n            length: Length\n            width: Width\n            height: Height\n        \"\"\"\n        super().__init__()\n\n        self.parent_widget = parent_widget\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setXExtent(width)\n        self.mesh.setYExtent(length)\n        self.mesh.setZExtent(height)\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n        self.transform.setRotationZ(rotation)\n        self.addComponent(self.transform)\n\n        self.picker = Qt3DRender.QObjectPicker()\n        self.picker.setDragEnabled(True)\n        self.picker.pressed.connect(self.pressed_obstacle)\n        self.picker.released.connect(self.released_obstacle)\n        self.picker.moved.connect(self.moved_obstacle)\n        self.addComponent(self.picker)\n\n        self.beacon_entity = Qt3DCore.QEntity(self)\n        self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n        self.beacon_mesh.setLength(80)\n        self.beacon_mesh.setRadius(35)\n        self.beacon_entity.addComponent(self.beacon_mesh)\n\n        self.beacon_material = Qt3DExtras.QPhongMaterial(self.beacon_entity)\n        self.beacon_entity.addComponent(self.beacon_material)\n\n        self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n        self.beacon_transform.setTranslation(\n            QtGui.QVector3D(0, 0, self.mesh.zExtent() / 2 + self.beacon_mesh.length() / 2)\n        )\n        self.beacon_transform.setRotationX(90)\n        self.beacon_entity.addComponent(self.beacon_transform)\n\n        self.moving = False\n\n        self.mesh.zExtentChanged.connect(self.updateZTranslation)\n\n        # Create a layer used by sensors to activate detection on the obstacles\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        # Create properties dialog\n        self.properties = ObstacleProperties(self.parent_widget, self)\n\n        Sensor.add_obstacle(self)\n\n    @qtSlot(float)\n    def updateZTranslation(self, zExtent: float):\n        \"\"\"\n        Qt Slot\n\n        Update the Z position based on the obstacle height.\n        This function is called each time the height is modified\n        to set the bottom on Z=0.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setZ(zExtent / 2)\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setXTranslation(self, x: int):\n        \"\"\"\n        Qt Slot\n\n        Set the X position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setX(float(x))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setYTranslation(self, y: int):\n        \"\"\"\n        Qt Slot\n\n        Set the Y position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setY(float(y))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def pressed_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```pressed``` mouse event on the obstacle.\n\n        Emit a signal to disable the camera controller before moving the obstacle.\n        \"\"\"\n        self.enable_controller.emit(False)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def released_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```released``` mouse event on the obstacle.\n\n        If this event occurs just after a ```pressed``` event, it is only a mouse click,\n        so display the property window.\n\n        Emit a signal to re-enable the camera controller after moving the obstacle.\n        \"\"\"\n        if not self.moving:\n            if ObstacleProperties.active_properties:\n                ObstacleProperties.active_properties.close()\n            self.properties.show()\n            self.properties.raise_()\n            self.properties.activateWindow()\n            ObstacleProperties.set_active_properties(self.properties)\n        self.moving = False\n        self.enable_controller.emit(True)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def moved_obstacle(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```moved``` mouse event on the obstacle.\n\n        Just record that the obstacle is moving, the translation is computed\n        in the [GameView][cogip.widgets.gameview.GameView] object.\n        \"\"\"\n        self.moving = True\n\n    def get_model(self) -&gt; models.Obstacle:\n        \"\"\"\n        Returns the [Obstacle][cogip.models.models.Obstacle] model.\n        Used to save the obstacles list.\n\n        Returns:\n            The obstacle model\n        \"\"\"\n        return models.Obstacle(\n            x=self.transform.translation().x(),\n            y=self.transform.translation().y(),\n            rotation=self.transform.rotationZ(),\n            length=self.mesh.yExtent(),\n            width=self.mesh.xExtent(),\n            height=self.mesh.zExtent(),\n        )\n\n    @qtSlot(QtGui.QVector3D)\n    def new_move_delta(self, delta: QtGui.QVector3D):\n        \"\"\"\n        Qt Slot\n\n        Update the obstacle position.\n\n        Arguments:\n            delta: The difference between current and new position\n        \"\"\"\n        if not delta:\n            self.moving = False\n        elif self.moving:\n            new_translation = self.transform.translation() + delta\n            self.transform.setTranslation(new_translation)\n            self.properties.spin_x.setValue(new_translation.x())\n            self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.__init__","title":"<code>__init__(parent_widget, x=0, y=0, rotation=0, length=225, width=225, height=350)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent_widget</code> <code>QWidget</code> <p>Parent widget</p> required <code>x</code> <code>int</code> <p>X position</p> <code>0</code> <code>y</code> <code>int</code> <p>Y position</p> <code>0</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>0</code> <code>length</code> <code>int</code> <p>Length</p> <code>225</code> <code>width</code> <code>int</code> <p>Width</p> <code>225</code> <code>height</code> <code>int</code> <p>Height</p> <code>350</code> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>def __init__(\n    self,\n    parent_widget: QtWidgets.QWidget,\n    x: int = 0,\n    y: int = 0,\n    rotation: int = 0,\n    length: int = 225,\n    width: int = 225,\n    height: int = 350,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent_widget: Parent widget\n        x: X position\n        y: Y position\n        rotation: Rotation\n        length: Length\n        width: Width\n        height: Height\n    \"\"\"\n    super().__init__()\n\n    self.parent_widget = parent_widget\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setXExtent(width)\n    self.mesh.setYExtent(length)\n    self.mesh.setZExtent(height)\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(x, y, self.mesh.zExtent() / 2))\n    self.transform.setRotationZ(rotation)\n    self.addComponent(self.transform)\n\n    self.picker = Qt3DRender.QObjectPicker()\n    self.picker.setDragEnabled(True)\n    self.picker.pressed.connect(self.pressed_obstacle)\n    self.picker.released.connect(self.released_obstacle)\n    self.picker.moved.connect(self.moved_obstacle)\n    self.addComponent(self.picker)\n\n    self.beacon_entity = Qt3DCore.QEntity(self)\n    self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n    self.beacon_mesh.setLength(80)\n    self.beacon_mesh.setRadius(35)\n    self.beacon_entity.addComponent(self.beacon_mesh)\n\n    self.beacon_material = Qt3DExtras.QPhongMaterial(self.beacon_entity)\n    self.beacon_entity.addComponent(self.beacon_material)\n\n    self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n    self.beacon_transform.setTranslation(\n        QtGui.QVector3D(0, 0, self.mesh.zExtent() / 2 + self.beacon_mesh.length() / 2)\n    )\n    self.beacon_transform.setRotationX(90)\n    self.beacon_entity.addComponent(self.beacon_transform)\n\n    self.moving = False\n\n    self.mesh.zExtentChanged.connect(self.updateZTranslation)\n\n    # Create a layer used by sensors to activate detection on the obstacles\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    # Create properties dialog\n    self.properties = ObstacleProperties(self.parent_widget, self)\n\n    Sensor.add_obstacle(self)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.get_model","title":"<code>get_model()</code>","text":"<p>Returns the Obstacle model. Used to save the obstacles list.</p> <p>Returns:</p> Type Description <code>Obstacle</code> <p>The obstacle model</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>def get_model(self) -&gt; models.Obstacle:\n    \"\"\"\n    Returns the [Obstacle][cogip.models.models.Obstacle] model.\n    Used to save the obstacles list.\n\n    Returns:\n        The obstacle model\n    \"\"\"\n    return models.Obstacle(\n        x=self.transform.translation().x(),\n        y=self.transform.translation().y(),\n        rotation=self.transform.rotationZ(),\n        length=self.mesh.yExtent(),\n        width=self.mesh.xExtent(),\n        height=self.mesh.zExtent(),\n    )\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.moved_obstacle","title":"<code>moved_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>moved</code> mouse event on the obstacle.</p> <p>Just record that the obstacle is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef moved_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```moved``` mouse event on the obstacle.\n\n    Just record that the obstacle is moving, the translation is computed\n    in the [GameView][cogip.widgets.gameview.GameView] object.\n    \"\"\"\n    self.moving = True\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.new_move_delta","title":"<code>new_move_delta(delta)</code>","text":"<p>Qt Slot</p> <p>Update the obstacle position.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>QVector3D</code> <p>The difference between current and new position</p> required Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(QtGui.QVector3D)\ndef new_move_delta(self, delta: QtGui.QVector3D):\n    \"\"\"\n    Qt Slot\n\n    Update the obstacle position.\n\n    Arguments:\n        delta: The difference between current and new position\n    \"\"\"\n    if not delta:\n        self.moving = False\n    elif self.moving:\n        new_translation = self.transform.translation() + delta\n        self.transform.setTranslation(new_translation)\n        self.properties.spin_x.setValue(new_translation.x())\n        self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.pressed_obstacle","title":"<code>pressed_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>pressed</code> mouse event on the obstacle.</p> <p>Emit a signal to disable the camera controller before moving the obstacle.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef pressed_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```pressed``` mouse event on the obstacle.\n\n    Emit a signal to disable the camera controller before moving the obstacle.\n    \"\"\"\n    self.enable_controller.emit(False)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.released_obstacle","title":"<code>released_obstacle(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>released</code> mouse event on the obstacle.</p> <p>If this event occurs just after a <code>pressed</code> event, it is only a mouse click, so display the property window.</p> <p>Emit a signal to re-enable the camera controller after moving the obstacle.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef released_obstacle(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```released``` mouse event on the obstacle.\n\n    If this event occurs just after a ```pressed``` event, it is only a mouse click,\n    so display the property window.\n\n    Emit a signal to re-enable the camera controller after moving the obstacle.\n    \"\"\"\n    if not self.moving:\n        if ObstacleProperties.active_properties:\n            ObstacleProperties.active_properties.close()\n        self.properties.show()\n        self.properties.raise_()\n        self.properties.activateWindow()\n        ObstacleProperties.set_active_properties(self.properties)\n    self.moving = False\n    self.enable_controller.emit(True)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.setXTranslation","title":"<code>setXTranslation(x)</code>","text":"<p>Qt Slot</p> <p>Set the X position.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(int)\ndef setXTranslation(self, x: int):\n    \"\"\"\n    Qt Slot\n\n    Set the X position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setX(float(x))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.setYTranslation","title":"<code>setYTranslation(y)</code>","text":"<p>Qt Slot</p> <p>Set the Y position.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(int)\ndef setYTranslation(self, y: int):\n    \"\"\"\n    Qt Slot\n\n    Set the Y position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setY(float(y))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleEntity.updateZTranslation","title":"<code>updateZTranslation(zExtent)</code>","text":"<p>Qt Slot</p> <p>Update the Z position based on the obstacle height. This function is called each time the height is modified to set the bottom on Z=0.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@qtSlot(float)\ndef updateZTranslation(self, zExtent: float):\n    \"\"\"\n    Qt Slot\n\n    Update the Z position based on the obstacle height.\n    This function is called each time the height is modified\n    to set the bottom on Z=0.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setZ(zExtent / 2)\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleProperties","title":"<code>ObstacleProperties</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>The property window.</p> <p>Each obstacle has its own property window.</p> <p>Attributes:</p> Name Type Description <code>active_properties</code> <code>ObstacleProperties</code> <p>The current property window displayed.</p> Source code in <code>cogip/entities/obstacle.py</code> <pre><code>class ObstacleProperties(QtWidgets.QDialog):\n    \"\"\"\n    The property window.\n\n    Each obstacle has its own property window.\n\n    Attributes:\n        active_properties: The current property window displayed.\n    \"\"\"\n\n    active_properties: \"ObstacleProperties\" = None\n\n    def __init__(self, parent: QtWidgets.QWidget, obstacle_entity: ObstacleEntity):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            obstacle_entity: The related obstacle entity\n        \"\"\"\n        super().__init__(parent)\n\n        self.obstacle_entity = obstacle_entity\n        self.setWindowTitle(\"Obstacle Properties\")\n        self.setModal(False)\n        self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        row = 0\n\n        label_x = QtWidgets.QLabel(\"X\")\n        self.spin_x = QtWidgets.QSpinBox()\n        self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_x.setMinimum(-1000)\n        self.spin_x.setMaximum(1000)\n        self.spin_x.setValue(int(self.obstacle_entity.transform.translation().x()))\n        self.spin_x.valueChanged.connect(self.obstacle_entity.setXTranslation)\n        layout.addWidget(label_x, row, 0)\n        layout.addWidget(self.spin_x, row, 1)\n        row += 1\n\n        label_y = QtWidgets.QLabel(\"Y\")\n        self.spin_y = QtWidgets.QSpinBox()\n        self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_y.setMinimum(-1500)\n        self.spin_y.setMaximum(1500)\n        self.spin_y.setValue(int(self.obstacle_entity.transform.translation().y()))\n        self.spin_y.valueChanged.connect(self.obstacle_entity.setYTranslation)\n        layout.addWidget(label_y, row, 0)\n        layout.addWidget(self.spin_y, row, 1)\n        row += 1\n\n        label_rotation = QtWidgets.QLabel(\"Rotation\")\n        self.spin_rotation = QtWidgets.QSpinBox()\n        self.spin_rotation.setSuffix(\"\u00b0\")\n        self.spin_rotation.setMinimum(-180)\n        self.spin_rotation.setMaximum(180)\n        self.spin_rotation.setValue(int(self.obstacle_entity.transform.rotationZ()))\n        self.spin_rotation.valueChanged.connect(self.obstacle_entity.transform.setRotationZ)\n        layout.addWidget(label_rotation, row, 0)\n        layout.addWidget(self.spin_rotation, row, 1)\n        row += 1\n\n        label_width = QtWidgets.QLabel(\"Width\")\n        self.spin_width = QtWidgets.QSpinBox()\n        self.spin_width.setMaximum(2000)\n        self.spin_width.setSingleStep(10)\n        self.spin_width.setValue(int(self.obstacle_entity.mesh.xExtent()))\n        self.spin_width.valueChanged.connect(self.obstacle_entity.mesh.setXExtent)\n        layout.addWidget(label_width, row, 0)\n        layout.addWidget(self.spin_width, row, 1)\n        row += 1\n\n        label_length = QtWidgets.QLabel(\"Length\")\n        self.spin_length = QtWidgets.QSpinBox()\n        self.spin_length.setMaximum(2000)\n        self.spin_length.setSingleStep(10)\n        self.spin_length.setValue(int(self.obstacle_entity.mesh.yExtent()))\n        self.spin_length.valueChanged.connect(self.obstacle_entity.mesh.setYExtent)\n        layout.addWidget(label_length, row, 0)\n        layout.addWidget(self.spin_length, row, 1)\n        row += 1\n\n        label_height = QtWidgets.QLabel(\"Height\")\n        self.spin_height = QtWidgets.QSpinBox()\n        self.spin_height.setMaximum(1000)\n        self.spin_height.setSingleStep(10)\n        self.spin_height.setValue(int(self.obstacle_entity.mesh.zExtent()))\n        self.spin_height.valueChanged.connect(self.obstacle_entity.mesh.setZExtent)\n        layout.addWidget(label_height, row, 0)\n        layout.addWidget(self.spin_height, row, 1)\n        row += 1\n\n        self.readSettings()\n\n    @classmethod\n    def set_active_properties(cls, properties: \"ObstacleProperties\"):\n        \"\"\"\n        Class method.\n\n        Set the current property window displayed.\n\n        Arguments:\n            properties: The current property\n        \"\"\"\n        cls.active_properties = properties\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Close the property windows.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        ObstacleProperties.set_active_properties(None)\n\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"obstacle_dialog/geometry\", self.saveGeometry())\n\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"obstacle_dialog/geometry\"))\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleProperties.__init__","title":"<code>__init__(parent, obstacle_entity)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>obstacle_entity</code> <code>ObstacleEntity</code> <p>The related obstacle entity</p> required Source code in <code>cogip/entities/obstacle.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget, obstacle_entity: ObstacleEntity):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        obstacle_entity: The related obstacle entity\n    \"\"\"\n    super().__init__(parent)\n\n    self.obstacle_entity = obstacle_entity\n    self.setWindowTitle(\"Obstacle Properties\")\n    self.setModal(False)\n    self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    row = 0\n\n    label_x = QtWidgets.QLabel(\"X\")\n    self.spin_x = QtWidgets.QSpinBox()\n    self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_x.setMinimum(-1000)\n    self.spin_x.setMaximum(1000)\n    self.spin_x.setValue(int(self.obstacle_entity.transform.translation().x()))\n    self.spin_x.valueChanged.connect(self.obstacle_entity.setXTranslation)\n    layout.addWidget(label_x, row, 0)\n    layout.addWidget(self.spin_x, row, 1)\n    row += 1\n\n    label_y = QtWidgets.QLabel(\"Y\")\n    self.spin_y = QtWidgets.QSpinBox()\n    self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_y.setMinimum(-1500)\n    self.spin_y.setMaximum(1500)\n    self.spin_y.setValue(int(self.obstacle_entity.transform.translation().y()))\n    self.spin_y.valueChanged.connect(self.obstacle_entity.setYTranslation)\n    layout.addWidget(label_y, row, 0)\n    layout.addWidget(self.spin_y, row, 1)\n    row += 1\n\n    label_rotation = QtWidgets.QLabel(\"Rotation\")\n    self.spin_rotation = QtWidgets.QSpinBox()\n    self.spin_rotation.setSuffix(\"\u00b0\")\n    self.spin_rotation.setMinimum(-180)\n    self.spin_rotation.setMaximum(180)\n    self.spin_rotation.setValue(int(self.obstacle_entity.transform.rotationZ()))\n    self.spin_rotation.valueChanged.connect(self.obstacle_entity.transform.setRotationZ)\n    layout.addWidget(label_rotation, row, 0)\n    layout.addWidget(self.spin_rotation, row, 1)\n    row += 1\n\n    label_width = QtWidgets.QLabel(\"Width\")\n    self.spin_width = QtWidgets.QSpinBox()\n    self.spin_width.setMaximum(2000)\n    self.spin_width.setSingleStep(10)\n    self.spin_width.setValue(int(self.obstacle_entity.mesh.xExtent()))\n    self.spin_width.valueChanged.connect(self.obstacle_entity.mesh.setXExtent)\n    layout.addWidget(label_width, row, 0)\n    layout.addWidget(self.spin_width, row, 1)\n    row += 1\n\n    label_length = QtWidgets.QLabel(\"Length\")\n    self.spin_length = QtWidgets.QSpinBox()\n    self.spin_length.setMaximum(2000)\n    self.spin_length.setSingleStep(10)\n    self.spin_length.setValue(int(self.obstacle_entity.mesh.yExtent()))\n    self.spin_length.valueChanged.connect(self.obstacle_entity.mesh.setYExtent)\n    layout.addWidget(label_length, row, 0)\n    layout.addWidget(self.spin_length, row, 1)\n    row += 1\n\n    label_height = QtWidgets.QLabel(\"Height\")\n    self.spin_height = QtWidgets.QSpinBox()\n    self.spin_height.setMaximum(1000)\n    self.spin_height.setSingleStep(10)\n    self.spin_height.setValue(int(self.obstacle_entity.mesh.zExtent()))\n    self.spin_height.valueChanged.connect(self.obstacle_entity.mesh.setZExtent)\n    layout.addWidget(label_height, row, 0)\n    layout.addWidget(self.spin_height, row, 1)\n    row += 1\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleProperties.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Close the property windows.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/entities/obstacle.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Close the property windows.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    ObstacleProperties.set_active_properties(None)\n\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"obstacle_dialog/geometry\", self.saveGeometry())\n\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/entities/obstacle/#cogip.entities.obstacle.ObstacleProperties.set_active_properties","title":"<code>set_active_properties(properties)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Set the current property window displayed.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>ObstacleProperties</code> <p>The current property</p> required Source code in <code>cogip/entities/obstacle.py</code> <pre><code>@classmethod\ndef set_active_properties(cls, properties: \"ObstacleProperties\"):\n    \"\"\"\n    Class method.\n\n    Set the current property window displayed.\n\n    Arguments:\n        properties: The current property\n    \"\"\"\n    cls.active_properties = properties\n</code></pre>"},{"location":"reference/cogip/entities/path/","title":"path","text":""},{"location":"reference/cogip/entities/path/#cogip.entities.path.PathEntity","title":"<code>PathEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A simple entity drawing a path along a list of vertices.</p> Source code in <code>cogip/entities/path.py</code> <pre><code>class PathEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A simple entity drawing a path along a list of vertices.\n    \"\"\"\n\n    def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            color: color\n            parent: parent entity\n        \"\"\"\n        super().__init__(parent)\n        self.points = []\n        self.color = color\n        self.lines: list[LineEntity] = []\n        self.lines_pool: list[LineEntity] = []\n\n    def set_points(self, points: list[models.Vertex]):\n        \"\"\"\n        Set points of the path.\n\n        Arguments:\n            points: list of vertices composing the line\n        \"\"\"\n        self.points = points\n\n        if len(self.points) &lt; 2:\n            return\n\n        for line in self.lines:\n            line.setEnabled(False)\n            self.lines_pool.append(line)\n\n        self.lines = []\n\n        start = self.points.pop(0)\n        for next in self.points:\n            if len(self.lines_pool) == 0:\n                self.lines_pool.append(LineEntity(self.color, self))\n            line = self.lines_pool.pop()\n            line.setEnabled(True)\n            line.set_points(start, next)\n            self.lines.append(line)\n            start = next\n</code></pre>"},{"location":"reference/cogip/entities/path/#cogip.entities.path.PathEntity.__init__","title":"<code>__init__(color=QtCore.Qt.blue, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>color</p> <code>blue</code> <code>parent</code> <code>QEntity | None</code> <p>parent entity</p> <code>None</code> Source code in <code>cogip/entities/path.py</code> <pre><code>def __init__(self, color: QtGui.QColor = QtCore.Qt.blue, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        color: color\n        parent: parent entity\n    \"\"\"\n    super().__init__(parent)\n    self.points = []\n    self.color = color\n    self.lines: list[LineEntity] = []\n    self.lines_pool: list[LineEntity] = []\n</code></pre>"},{"location":"reference/cogip/entities/path/#cogip.entities.path.PathEntity.set_points","title":"<code>set_points(points)</code>","text":"<p>Set points of the path.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Vertex]</code> <p>list of vertices composing the line</p> required Source code in <code>cogip/entities/path.py</code> <pre><code>def set_points(self, points: list[models.Vertex]):\n    \"\"\"\n    Set points of the path.\n\n    Arguments:\n        points: list of vertices composing the line\n    \"\"\"\n    self.points = points\n\n    if len(self.points) &lt; 2:\n        return\n\n    for line in self.lines:\n        line.setEnabled(False)\n        self.lines_pool.append(line)\n\n    self.lines = []\n\n    start = self.points.pop(0)\n    for next in self.points:\n        if len(self.lines_pool) == 0:\n            self.lines_pool.append(LineEntity(self.color, self))\n        line = self.lines_pool.pop()\n        line.setEnabled(True)\n        line.set_points(start, next)\n        self.lines.append(line)\n        start = next\n</code></pre>"},{"location":"reference/cogip/entities/robot/","title":"robot","text":""},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity","title":"<code>RobotEntity</code>","text":"<p>               Bases: <code>AssetEntity</code></p> <p>The robot entity displayed on the table.</p> <p>Attributes:</p> Name Type Description <code>sensors_update_interval</code> <code>int</code> <p>Interval in milliseconds between each sensors update</p> <code>sensors_emit_interval</code> <code>int</code> <p>Interval in milliseconds between each sensors data emission</p> <code>sensors_emit_data_signal</code> <code>Signal</code> <p>Qt Signal emitting sensors data</p> <code>order_robot</code> <code>RobotOrderEntity</code> <p>: Entity that represents the robot next destination</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>class RobotEntity(AssetEntity):\n    \"\"\"\n    The robot entity displayed on the table.\n\n    Attributes:\n        sensors_update_interval: Interval in milliseconds between each sensors update\n        sensors_emit_interval: Interval in milliseconds between each sensors data emission\n        sensors_emit_data_signal: Qt Signal emitting sensors data\n        order_robot:: Entity that represents the robot next destination\n    \"\"\"\n\n    sensors_update_interval: int = 5\n    sensors_emit_interval: int = 20\n    sensors_emit_data_signal: qtSignal = qtSignal(int, list)\n    order_robot: RobotOrderEntity = None\n\n    def __init__(self, robot_id: int, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Inherits [AssetEntity][cogip.entities.asset.AssetEntity].\n        \"\"\"\n        asset_path = Path(f\"assets/{'robot' if robot_id == 1 else 'pami'}2024.dae\")\n        super().__init__(asset_path, parent=parent)\n        self.robot_id = robot_id\n        self.sensors = []\n        self.rect_obstacles_pool = []\n        self.round_obstacles_pool = []\n        self.beacon_entity: Qt3DCore.QEntity | None = None\n\n        if robot_id == 1:\n            self.beacon_entity = Qt3DCore.QEntity(self)\n            self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n            self.beacon_mesh.setLength(80)\n            self.beacon_mesh.setRadius(40)\n            self.beacon_entity.addComponent(self.beacon_mesh)\n\n            self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n            self.beacon_transform.setTranslation(QtGui.QVector3D(0, 0, 350 + self.beacon_mesh.length() / 2))\n            self.beacon_transform.setRotationX(90)\n            self.beacon_entity.addComponent(self.beacon_transform)\n\n            # Create a layer used by sensors to activate detection on the beacon\n            self.beacon_entity.layer = Qt3DRender.QLayer(self.beacon_entity)\n            self.beacon_entity.layer.setRecursive(True)\n            self.beacon_entity.layer.setEnabled(True)\n            self.beacon_entity.addComponent(self.beacon_entity.layer)\n\n        # Use a timer to trigger sensors update\n        self.sensors_update_timer = QtCore.QTimer()\n\n        self.sensors_emit_timer = QtCore.QTimer()\n        self.sensors_emit_timer.timeout.connect(self.emit_sensors_data)\n\n    def post_init(self):\n        \"\"\"\n        Function called once the asset has been loaded.\n\n        Set the color and enable sensors.\n        \"\"\"\n        super().post_init()\n\n        if self.robot_id == 1:\n            self.add_lidar_sensors()\n        else:\n            self.add_tof_sensor()\n\n        self.order_robot = RobotOrderEntity(self.parent(), self.robot_id)\n\n        if self.beacon_entity:\n            Sensor.add_obstacle(self.beacon_entity)\n\n    def add_lidar_sensors(self):\n        \"\"\"\n        Add LIDAR sensors to the robot entity,\n        one by degree around the top of the robot.\n        \"\"\"\n\n        radius = 65.0 / 2\n\n        sensors_properties = []\n\n        for i in range(0, 360):\n            angle = (360 - i) % 360\n            origin_x = radius * math.sin(math.radians(90 - angle))\n            origin_y = radius * math.cos(math.radians(90 - angle))\n            sensors_properties.append(\n                {\n                    \"name\": f\"Lidar {angle}\",\n                    \"origin_x\": origin_x,\n                    \"origin_y\": origin_y,\n                    \"direction_x\": origin_x,\n                    \"direction_y\": origin_y,\n                }\n            )\n\n        # Add sensors\n        for prop in sensors_properties:\n            sensor = LidarSensor(asset_entity=self, **prop)\n            self.sensors_update_timer.timeout.connect(sensor.update_hit)\n            self.sensors.append(sensor)\n\n    def add_tof_sensor(self):\n        \"\"\"\n        Add a ToF sensor in front of the robot entity.\n        \"\"\"\n        sensor = ToFSensor(asset_entity=self, name=\"ToF\", origin_x=106, origin_y=0)\n        self.sensors_update_timer.timeout.connect(sensor.update_hit)\n        self.sensors.append(sensor)\n\n    @qtSlot(Pose)\n    def new_robot_pose_current(self, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Qt slot called to set the robot's new pose current.\n\n        Arguments:\n            new_pose: new robot pose\n        \"\"\"\n        self.transform_component.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n        self.transform_component.setRotationZ(new_pose.O)\n\n    @qtSlot(Pose)\n    def new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Qt slot called to set the robot's new pose order.\n\n        Arguments:\n            new_pose: new robot pose\n        \"\"\"\n        if self.order_robot:\n            self.order_robot.transform.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n            self.order_robot.transform.setRotationZ(new_pose.O)\n\n    def start_sensors_emulation(self) -&gt; None:\n        \"\"\"\n        Start timers triggering sensors update and Lidar data emission.\n        \"\"\"\n        self.sensors_update_timer.start(RobotEntity.sensors_update_interval)\n        self.sensors_emit_timer.start(RobotEntity.sensors_emit_interval)\n\n    def stop_sensors_emulation(self) -&gt; None:\n        \"\"\"\n        Stop timers triggering sensors update and sensors data emission.\n        \"\"\"\n        self.sensors_update_timer.stop()\n        self.sensors_emit_timer.stop()\n\n    def sensors_data(self) -&gt; list[int]:\n        \"\"\"\n        Return a list of distances for each 360 Lidar angles or ToF distance.\n        \"\"\"\n        return [sensor.distance for sensor in self.sensors]\n\n    @qtSlot()\n    def emit_sensors_data(self) -&gt; None:\n        \"\"\"\n        Qt Slot called to emit sensors data.\n        \"\"\"\n        self.sensors_emit_data_signal.emit(self.robot_id, self.sensors_data())\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.__init__","title":"<code>__init__(robot_id, parent=None)</code>","text":"<p>Class constructor.</p> <p>Inherits AssetEntity.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def __init__(self, robot_id: int, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Inherits [AssetEntity][cogip.entities.asset.AssetEntity].\n    \"\"\"\n    asset_path = Path(f\"assets/{'robot' if robot_id == 1 else 'pami'}2024.dae\")\n    super().__init__(asset_path, parent=parent)\n    self.robot_id = robot_id\n    self.sensors = []\n    self.rect_obstacles_pool = []\n    self.round_obstacles_pool = []\n    self.beacon_entity: Qt3DCore.QEntity | None = None\n\n    if robot_id == 1:\n        self.beacon_entity = Qt3DCore.QEntity(self)\n        self.beacon_mesh = Qt3DExtras.QCylinderMesh(self.beacon_entity)\n        self.beacon_mesh.setLength(80)\n        self.beacon_mesh.setRadius(40)\n        self.beacon_entity.addComponent(self.beacon_mesh)\n\n        self.beacon_transform = Qt3DCore.QTransform(self.beacon_entity)\n        self.beacon_transform.setTranslation(QtGui.QVector3D(0, 0, 350 + self.beacon_mesh.length() / 2))\n        self.beacon_transform.setRotationX(90)\n        self.beacon_entity.addComponent(self.beacon_transform)\n\n        # Create a layer used by sensors to activate detection on the beacon\n        self.beacon_entity.layer = Qt3DRender.QLayer(self.beacon_entity)\n        self.beacon_entity.layer.setRecursive(True)\n        self.beacon_entity.layer.setEnabled(True)\n        self.beacon_entity.addComponent(self.beacon_entity.layer)\n\n    # Use a timer to trigger sensors update\n    self.sensors_update_timer = QtCore.QTimer()\n\n    self.sensors_emit_timer = QtCore.QTimer()\n    self.sensors_emit_timer.timeout.connect(self.emit_sensors_data)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.add_lidar_sensors","title":"<code>add_lidar_sensors()</code>","text":"<p>Add LIDAR sensors to the robot entity, one by degree around the top of the robot.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def add_lidar_sensors(self):\n    \"\"\"\n    Add LIDAR sensors to the robot entity,\n    one by degree around the top of the robot.\n    \"\"\"\n\n    radius = 65.0 / 2\n\n    sensors_properties = []\n\n    for i in range(0, 360):\n        angle = (360 - i) % 360\n        origin_x = radius * math.sin(math.radians(90 - angle))\n        origin_y = radius * math.cos(math.radians(90 - angle))\n        sensors_properties.append(\n            {\n                \"name\": f\"Lidar {angle}\",\n                \"origin_x\": origin_x,\n                \"origin_y\": origin_y,\n                \"direction_x\": origin_x,\n                \"direction_y\": origin_y,\n            }\n        )\n\n    # Add sensors\n    for prop in sensors_properties:\n        sensor = LidarSensor(asset_entity=self, **prop)\n        self.sensors_update_timer.timeout.connect(sensor.update_hit)\n        self.sensors.append(sensor)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.add_tof_sensor","title":"<code>add_tof_sensor()</code>","text":"<p>Add a ToF sensor in front of the robot entity.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def add_tof_sensor(self):\n    \"\"\"\n    Add a ToF sensor in front of the robot entity.\n    \"\"\"\n    sensor = ToFSensor(asset_entity=self, name=\"ToF\", origin_x=106, origin_y=0)\n    self.sensors_update_timer.timeout.connect(sensor.update_hit)\n    self.sensors.append(sensor)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.emit_sensors_data","title":"<code>emit_sensors_data()</code>","text":"<p>Qt Slot called to emit sensors data.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>@qtSlot()\ndef emit_sensors_data(self) -&gt; None:\n    \"\"\"\n    Qt Slot called to emit sensors data.\n    \"\"\"\n    self.sensors_emit_data_signal.emit(self.robot_id, self.sensors_data())\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.new_robot_pose_current","title":"<code>new_robot_pose_current(new_pose)</code>","text":"<p>Qt slot called to set the robot's new pose current.</p> <p>Parameters:</p> Name Type Description Default <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/entities/robot.py</code> <pre><code>@qtSlot(Pose)\ndef new_robot_pose_current(self, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Qt slot called to set the robot's new pose current.\n\n    Arguments:\n        new_pose: new robot pose\n    \"\"\"\n    self.transform_component.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n    self.transform_component.setRotationZ(new_pose.O)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.new_robot_pose_order","title":"<code>new_robot_pose_order(new_pose)</code>","text":"<p>Qt slot called to set the robot's new pose order.</p> <p>Parameters:</p> Name Type Description Default <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/entities/robot.py</code> <pre><code>@qtSlot(Pose)\ndef new_robot_pose_order(self, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Qt slot called to set the robot's new pose order.\n\n    Arguments:\n        new_pose: new robot pose\n    \"\"\"\n    if self.order_robot:\n        self.order_robot.transform.setTranslation(QtGui.QVector3D(new_pose.x, new_pose.y, 0))\n        self.order_robot.transform.setRotationZ(new_pose.O)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.post_init","title":"<code>post_init()</code>","text":"<p>Function called once the asset has been loaded.</p> <p>Set the color and enable sensors.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def post_init(self):\n    \"\"\"\n    Function called once the asset has been loaded.\n\n    Set the color and enable sensors.\n    \"\"\"\n    super().post_init()\n\n    if self.robot_id == 1:\n        self.add_lidar_sensors()\n    else:\n        self.add_tof_sensor()\n\n    self.order_robot = RobotOrderEntity(self.parent(), self.robot_id)\n\n    if self.beacon_entity:\n        Sensor.add_obstacle(self.beacon_entity)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.sensors_data","title":"<code>sensors_data()</code>","text":"<p>Return a list of distances for each 360 Lidar angles or ToF distance.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def sensors_data(self) -&gt; list[int]:\n    \"\"\"\n    Return a list of distances for each 360 Lidar angles or ToF distance.\n    \"\"\"\n    return [sensor.distance for sensor in self.sensors]\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.start_sensors_emulation","title":"<code>start_sensors_emulation()</code>","text":"<p>Start timers triggering sensors update and Lidar data emission.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def start_sensors_emulation(self) -&gt; None:\n    \"\"\"\n    Start timers triggering sensors update and Lidar data emission.\n    \"\"\"\n    self.sensors_update_timer.start(RobotEntity.sensors_update_interval)\n    self.sensors_emit_timer.start(RobotEntity.sensors_emit_interval)\n</code></pre>"},{"location":"reference/cogip/entities/robot/#cogip.entities.robot.RobotEntity.stop_sensors_emulation","title":"<code>stop_sensors_emulation()</code>","text":"<p>Stop timers triggering sensors update and sensors data emission.</p> Source code in <code>cogip/entities/robot.py</code> <pre><code>def stop_sensors_emulation(self) -&gt; None:\n    \"\"\"\n    Stop timers triggering sensors update and sensors data emission.\n    \"\"\"\n    self.sensors_update_timer.stop()\n    self.sensors_emit_timer.stop()\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/","title":"robot_manual","text":""},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity","title":"<code>RobotManualEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>An robot entity that can be moved and rotated manually on the table.</p> <p>When selected with a mouse click, a property window is displayed to modify the robot properties.</p> <p>The robot can also be moved using the mouse.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>QColor</code> <p>Robot color</p> <code>enable_controller</code> <p>Qt signal used to disable the camera controller when moving the robot using the mouse</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>class RobotManualEntity(Qt3DCore.QEntity):\n    \"\"\"\n    An robot entity that can be moved and rotated manually on the table.\n\n    When selected with a mouse click, a property window is displayed\n    to modify the robot properties.\n\n    The robot can also be moved using the mouse.\n\n    Attributes:\n        color: Robot color\n        enable_controller: Qt signal used to disable the camera controller\n            when moving the robot using the mouse\n    \"\"\"\n\n    color: QtGui.QColor = QtGui.QColor.fromRgb(17, 70, 92, 100)\n    enable_controller = qtSignal(bool)\n\n    def __init__(\n        self,\n        parent: Qt3DCore.QEntity,\n        parent_widget: QtWidgets.QWidget,\n        robot_id: int = 1,\n        x: int = 1200,\n        y: int = 1200,\n        rotation: int = 180,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent entity\n            parent_widget: Parent widget\n            x: X position\n            y: Y position\n            rotation: Rotation\n        \"\"\"\n        super().__init__(parent)\n\n        self.parent_widget = parent_widget\n\n        self.mesh = Qt3DRender.QMesh(self)\n        self.mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2024.stl\"))\n        self.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial(self)\n        self.material.setShininess(1.0)\n        self.material.setDiffuse(self.color)\n        self.material.setSpecular(self.color)\n        self.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform(self)\n        self.transform.setTranslation(QtGui.QVector3D(x, y, 0))\n        self.transform.setRotationZ(rotation)\n        self.addComponent(self.transform)\n\n        self.picker = Qt3DRender.QObjectPicker()\n        self.picker.setDragEnabled(True)\n        self.picker.pressed.connect(self.pressed)\n        self.picker.released.connect(self.released)\n        self.picker.moved.connect(self.moved)\n        self.addComponent(self.picker)\n\n        self.moving = False\n\n        # Create a layer used by sensors to activate detection on the robot\n        self.layer = Qt3DRender.QLayer(self)\n        self.layer.setRecursive(True)\n        self.layer.setEnabled(True)\n        self.addComponent(self.layer)\n\n        # Create properties dialog\n        self.properties = RobotManualProperties(self.parent_widget, self)\n\n    @qtSlot(int)\n    def setXTranslation(self, x: int):\n        \"\"\"\n        Qt Slot\n\n        Set the X position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setX(float(x))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(int)\n    def setYTranslation(self, y: int):\n        \"\"\"\n        Qt Slot\n\n        Set the Y position.\n        \"\"\"\n        translation = self.transform.translation()\n        translation.setY(float(y))\n        self.transform.setTranslation(translation)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```pressed``` mouse event on the robot.\n\n        Emit a signal to disable the camera controller before moving the robot.\n        \"\"\"\n        self.enable_controller.emit(False)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def released(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```released``` mouse event on the robot.\n\n        If this event occurs just after a ```pressed``` event, it is only a mouse click,\n        so display the property window.\n\n        Emit a signal to re-enable the camera controller after moving the robot.\n        \"\"\"\n        if not self.moving:\n            if RobotManualProperties.active_properties:\n                RobotManualProperties.active_properties.close()\n            self.properties.show()\n            self.properties.raise_()\n            self.properties.activateWindow()\n            RobotManualProperties.set_active_properties(self.properties)\n        self.moving = False\n        self.enable_controller.emit(True)\n\n    @qtSlot(Qt3DRender.QPickEvent)\n    def moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Qt Slot\n\n        Slot called on a ```moved``` mouse event on the robot.\n\n        Just record that the robot is moving, the translation is computed\n        in the [GameView][cogip.widgets.gameview.GameView] object.\n        \"\"\"\n        self.moving = True\n\n    @qtSlot(QtGui.QVector3D)\n    def new_move_delta(self, delta: QtGui.QVector3D):\n        \"\"\"\n        Qt Slot\n\n        Update the robot position.\n\n        Arguments:\n            delta: The difference between current and new position\n        \"\"\"\n        if not delta:\n            self.moving = False\n        elif self.moving:\n            new_translation = self.transform.translation() + delta\n            self.transform.setTranslation(new_translation)\n            self.properties.spin_x.setValue(new_translation.x())\n            self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.__init__","title":"<code>__init__(parent, parent_widget, robot_id=1, x=1200, y=1200, rotation=180)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QEntity</code> <p>The parent entity</p> required <code>parent_widget</code> <code>QWidget</code> <p>Parent widget</p> required <code>x</code> <code>int</code> <p>X position</p> <code>1200</code> <code>y</code> <code>int</code> <p>Y position</p> <code>1200</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>180</code> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>def __init__(\n    self,\n    parent: Qt3DCore.QEntity,\n    parent_widget: QtWidgets.QWidget,\n    robot_id: int = 1,\n    x: int = 1200,\n    y: int = 1200,\n    rotation: int = 180,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent entity\n        parent_widget: Parent widget\n        x: X position\n        y: Y position\n        rotation: Rotation\n    \"\"\"\n    super().__init__(parent)\n\n    self.parent_widget = parent_widget\n\n    self.mesh = Qt3DRender.QMesh(self)\n    self.mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2024.stl\"))\n    self.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial(self)\n    self.material.setShininess(1.0)\n    self.material.setDiffuse(self.color)\n    self.material.setSpecular(self.color)\n    self.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform(self)\n    self.transform.setTranslation(QtGui.QVector3D(x, y, 0))\n    self.transform.setRotationZ(rotation)\n    self.addComponent(self.transform)\n\n    self.picker = Qt3DRender.QObjectPicker()\n    self.picker.setDragEnabled(True)\n    self.picker.pressed.connect(self.pressed)\n    self.picker.released.connect(self.released)\n    self.picker.moved.connect(self.moved)\n    self.addComponent(self.picker)\n\n    self.moving = False\n\n    # Create a layer used by sensors to activate detection on the robot\n    self.layer = Qt3DRender.QLayer(self)\n    self.layer.setRecursive(True)\n    self.layer.setEnabled(True)\n    self.addComponent(self.layer)\n\n    # Create properties dialog\n    self.properties = RobotManualProperties(self.parent_widget, self)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.moved","title":"<code>moved(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>moved</code> mouse event on the robot.</p> <p>Just record that the robot is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```moved``` mouse event on the robot.\n\n    Just record that the robot is moving, the translation is computed\n    in the [GameView][cogip.widgets.gameview.GameView] object.\n    \"\"\"\n    self.moving = True\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.new_move_delta","title":"<code>new_move_delta(delta)</code>","text":"<p>Qt Slot</p> <p>Update the robot position.</p> <p>Parameters:</p> Name Type Description Default <code>delta</code> <code>QVector3D</code> <p>The difference between current and new position</p> required Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(QtGui.QVector3D)\ndef new_move_delta(self, delta: QtGui.QVector3D):\n    \"\"\"\n    Qt Slot\n\n    Update the robot position.\n\n    Arguments:\n        delta: The difference between current and new position\n    \"\"\"\n    if not delta:\n        self.moving = False\n    elif self.moving:\n        new_translation = self.transform.translation() + delta\n        self.transform.setTranslation(new_translation)\n        self.properties.spin_x.setValue(new_translation.x())\n        self.properties.spin_y.setValue(new_translation.y())\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.pressed","title":"<code>pressed(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>pressed</code> mouse event on the robot.</p> <p>Emit a signal to disable the camera controller before moving the robot.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```pressed``` mouse event on the robot.\n\n    Emit a signal to disable the camera controller before moving the robot.\n    \"\"\"\n    self.enable_controller.emit(False)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.released","title":"<code>released(pick)</code>","text":"<p>Qt Slot</p> <p>Slot called on a <code>released</code> mouse event on the robot.</p> <p>If this event occurs just after a <code>pressed</code> event, it is only a mouse click, so display the property window.</p> <p>Emit a signal to re-enable the camera controller after moving the robot.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(Qt3DRender.QPickEvent)\ndef released(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Qt Slot\n\n    Slot called on a ```released``` mouse event on the robot.\n\n    If this event occurs just after a ```pressed``` event, it is only a mouse click,\n    so display the property window.\n\n    Emit a signal to re-enable the camera controller after moving the robot.\n    \"\"\"\n    if not self.moving:\n        if RobotManualProperties.active_properties:\n            RobotManualProperties.active_properties.close()\n        self.properties.show()\n        self.properties.raise_()\n        self.properties.activateWindow()\n        RobotManualProperties.set_active_properties(self.properties)\n    self.moving = False\n    self.enable_controller.emit(True)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.setXTranslation","title":"<code>setXTranslation(x)</code>","text":"<p>Qt Slot</p> <p>Set the X position.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(int)\ndef setXTranslation(self, x: int):\n    \"\"\"\n    Qt Slot\n\n    Set the X position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setX(float(x))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualEntity.setYTranslation","title":"<code>setYTranslation(y)</code>","text":"<p>Qt Slot</p> <p>Set the Y position.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@qtSlot(int)\ndef setYTranslation(self, y: int):\n    \"\"\"\n    Qt Slot\n\n    Set the Y position.\n    \"\"\"\n    translation = self.transform.translation()\n    translation.setY(float(y))\n    self.transform.setTranslation(translation)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualProperties","title":"<code>RobotManualProperties</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>The property window.</p> <p>Attributes:</p> Name Type Description <code>active_properties</code> <code>RobotManualProperties</code> <p>The current property window displayed.</p> Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>class RobotManualProperties(QtWidgets.QDialog):\n    \"\"\"\n    The property window.\n\n    Attributes:\n        active_properties: The current property window displayed.\n    \"\"\"\n\n    active_properties: \"RobotManualProperties\" = None\n\n    def __init__(self, parent: QtWidgets.QWidget, robot_entity: RobotManualEntity):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            robot_entity: The related robot entity\n        \"\"\"\n        super().__init__(parent)\n\n        self.robot_entity = robot_entity\n        self.setWindowTitle(\"Robot Properties\")\n        self.setModal(False)\n        self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        row = 0\n\n        label_x = QtWidgets.QLabel(\"X\")\n        self.spin_x = QtWidgets.QSpinBox()\n        self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_x.setMinimum(-1200)\n        self.spin_x.setMaximum(1200)\n        self.spin_x.setValue(int(self.robot_entity.transform.translation().x()))\n        self.spin_x.valueChanged.connect(self.robot_entity.setXTranslation)\n        layout.addWidget(label_x, row, 0)\n        layout.addWidget(self.spin_x, row, 1)\n        row += 1\n\n        label_y = QtWidgets.QLabel(\"Y\")\n        self.spin_y = QtWidgets.QSpinBox()\n        self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n        self.spin_y.setMinimum(-1700)\n        self.spin_y.setMaximum(1700)\n        self.spin_y.setValue(int(self.robot_entity.transform.translation().y()))\n        self.spin_y.valueChanged.connect(self.robot_entity.setYTranslation)\n        layout.addWidget(label_y, row, 0)\n        layout.addWidget(self.spin_y, row, 1)\n        row += 1\n\n        label_rotation = QtWidgets.QLabel(\"Rotation\")\n        self.spin_rotation = QtWidgets.QSpinBox()\n        self.spin_rotation.setSuffix(\"\u00b0\")\n        self.spin_rotation.setMinimum(-180)\n        self.spin_rotation.setMaximum(180)\n        self.spin_rotation.setValue(int(self.robot_entity.transform.rotationZ()))\n        self.spin_rotation.valueChanged.connect(self.robot_entity.transform.setRotationZ)\n        layout.addWidget(label_rotation, row, 0)\n        layout.addWidget(self.spin_rotation, row, 1)\n        row += 1\n\n        self.readSettings()\n\n    @classmethod\n    def set_active_properties(cls, properties: \"RobotManualProperties\"):\n        \"\"\"\n        Class method.\n\n        Set the current property window displayed.\n\n        Arguments:\n            properties: The current property\n        \"\"\"\n        cls.active_properties = properties\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Close the property windows.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        RobotManualProperties.set_active_properties(None)\n\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"manual_robot_dialog/geometry\", self.saveGeometry())\n\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"manual_robot_dialog/geometry\"))\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualProperties.__init__","title":"<code>__init__(parent, robot_entity)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> required <code>robot_entity</code> <code>RobotManualEntity</code> <p>The related robot entity</p> required Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget, robot_entity: RobotManualEntity):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        robot_entity: The related robot entity\n    \"\"\"\n    super().__init__(parent)\n\n    self.robot_entity = robot_entity\n    self.setWindowTitle(\"Robot Properties\")\n    self.setModal(False)\n    self.setMinimumWidth(self.fontMetrics().horizontalAdvance(self.windowTitle()))\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    row = 0\n\n    label_x = QtWidgets.QLabel(\"X\")\n    self.spin_x = QtWidgets.QSpinBox()\n    self.spin_x.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_x.setMinimum(-1200)\n    self.spin_x.setMaximum(1200)\n    self.spin_x.setValue(int(self.robot_entity.transform.translation().x()))\n    self.spin_x.valueChanged.connect(self.robot_entity.setXTranslation)\n    layout.addWidget(label_x, row, 0)\n    layout.addWidget(self.spin_x, row, 1)\n    row += 1\n\n    label_y = QtWidgets.QLabel(\"Y\")\n    self.spin_y = QtWidgets.QSpinBox()\n    self.spin_y.setStepType(QtWidgets.QAbstractSpinBox.AdaptiveDecimalStepType)\n    self.spin_y.setMinimum(-1700)\n    self.spin_y.setMaximum(1700)\n    self.spin_y.setValue(int(self.robot_entity.transform.translation().y()))\n    self.spin_y.valueChanged.connect(self.robot_entity.setYTranslation)\n    layout.addWidget(label_y, row, 0)\n    layout.addWidget(self.spin_y, row, 1)\n    row += 1\n\n    label_rotation = QtWidgets.QLabel(\"Rotation\")\n    self.spin_rotation = QtWidgets.QSpinBox()\n    self.spin_rotation.setSuffix(\"\u00b0\")\n    self.spin_rotation.setMinimum(-180)\n    self.spin_rotation.setMaximum(180)\n    self.spin_rotation.setValue(int(self.robot_entity.transform.rotationZ()))\n    self.spin_rotation.valueChanged.connect(self.robot_entity.transform.setRotationZ)\n    layout.addWidget(label_rotation, row, 0)\n    layout.addWidget(self.spin_rotation, row, 1)\n    row += 1\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualProperties.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Close the property windows.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Close the property windows.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    RobotManualProperties.set_active_properties(None)\n\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"manual_robot_dialog/geometry\", self.saveGeometry())\n\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/entities/robot_manual/#cogip.entities.robot_manual.RobotManualProperties.set_active_properties","title":"<code>set_active_properties(properties)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Set the current property window displayed.</p> <p>Parameters:</p> Name Type Description Default <code>properties</code> <code>RobotManualProperties</code> <p>The current property</p> required Source code in <code>cogip/entities/robot_manual.py</code> <pre><code>@classmethod\ndef set_active_properties(cls, properties: \"RobotManualProperties\"):\n    \"\"\"\n    Class method.\n\n    Set the current property window displayed.\n\n    Arguments:\n        properties: The current property\n    \"\"\"\n    cls.active_properties = properties\n</code></pre>"},{"location":"reference/cogip/entities/robot_order/","title":"robot_order","text":""},{"location":"reference/cogip/entities/robot_order/#cogip.entities.robot_order.RobotOrderEntity","title":"<code>RobotOrderEntity</code>","text":"<p>               Bases: <code>QEntity</code></p> <p>A robot entity to display to order position.</p> <p>Attributes:</p> Name Type Description <code>color</code> <code>QColor</code> <p>Robot color</p> Source code in <code>cogip/entities/robot_order.py</code> <pre><code>class RobotOrderEntity(Qt3DCore.QEntity):\n    \"\"\"\n    A robot entity to display to order position.\n\n    Attributes:\n        color: Robot color\n    \"\"\"\n\n    color: QtGui.QColor = QtGui.QColor.fromRgb(10, 77, 18, 100)\n\n    def __init__(self, parent: Qt3DCore.QEntity, robot_id: int = 1):\n        \"\"\"\n        Class constructor.\n        \"\"\"\n        super().__init__(parent)\n\n        mesh = Qt3DRender.QMesh(self)\n        mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2024.stl\"))\n\n        self.transform = Qt3DCore.QTransform(self)\n\n        self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n        self.material.setShininess(1.0)\n        self.material.setDiffuse(self.color)\n        self.material.setSpecular(self.color)\n\n        self.addComponent(mesh)\n        self.addComponent(self.transform)\n        self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/entities/robot_order/#cogip.entities.robot_order.RobotOrderEntity.__init__","title":"<code>__init__(parent, robot_id=1)</code>","text":"<p>Class constructor.</p> Source code in <code>cogip/entities/robot_order.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity, robot_id: int = 1):\n    \"\"\"\n    Class constructor.\n    \"\"\"\n    super().__init__(parent)\n\n    mesh = Qt3DRender.QMesh(self)\n    mesh.setSource(QtCore.QUrl(f\"file:assets/{'robot' if robot_id == 1 else 'pami'}2024.stl\"))\n\n    self.transform = Qt3DCore.QTransform(self)\n\n    self.material = Qt3DExtras.QDiffuseSpecularMaterial(self)\n    self.material.setShininess(1.0)\n    self.material.setDiffuse(self.color)\n    self.material.setSpecular(self.color)\n\n    self.addComponent(mesh)\n    self.addComponent(self.transform)\n    self.addComponent(self.material)\n</code></pre>"},{"location":"reference/cogip/entities/sensor/","title":"sensor","text":""},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.LidarSensor","title":"<code>LidarSensor</code>","text":"<p>               Bases: <code>Sensor</code></p> <p>Specialized LIDAR sensor.</p> <p>Its impact entity is represented by a small blue sphere.</p> Source code in <code>cogip/entities/sensor.py</code> <pre><code>class LidarSensor(Sensor):\n    \"\"\"\n    Specialized LIDAR sensor.\n\n    Its impact entity is represented by a small blue sphere.\n    \"\"\"\n\n    nb_lidar_sensors = 0\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        origin_x: int,\n        origin_y: int,\n        direction_x: int,\n        direction_y: int,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n            direction_x: X direction of the ray caster\n            direction_y: Y direction of the ray caster\n        \"\"\"\n\n        super().__init__(\n            asset_entity=asset_entity,\n            name=name,\n            origin_x=origin_x,\n            origin_y=origin_y,\n            origin_z=360,\n            direction_x=direction_x,\n            direction_y=direction_y,\n            direction_z=0,\n            impact_radius=20,\n            impact_color=QtCore.Qt.cyan,\n        )\n\n        self.lidar_id = LidarSensor.nb_lidar_sensors\n        LidarSensor.nb_lidar_sensors += 1\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.LidarSensor.__init__","title":"<code>__init__(asset_entity, name, origin_x, origin_y, direction_x, direction_y)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>origin_x</code> <code>int</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>int</code> <p>Y origin of the ray caster</p> required <code>direction_x</code> <code>int</code> <p>X direction of the ray caster</p> required <code>direction_y</code> <code>int</code> <p>Y direction of the ray caster</p> required Source code in <code>cogip/entities/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    origin_x: int,\n    origin_y: int,\n    direction_x: int,\n    direction_y: int,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n        direction_x: X direction of the ray caster\n        direction_y: Y direction of the ray caster\n    \"\"\"\n\n    super().__init__(\n        asset_entity=asset_entity,\n        name=name,\n        origin_x=origin_x,\n        origin_y=origin_y,\n        origin_z=360,\n        direction_x=direction_x,\n        direction_y=direction_y,\n        direction_z=0,\n        impact_radius=20,\n        impact_color=QtCore.Qt.cyan,\n    )\n\n    self.lidar_id = LidarSensor.nb_lidar_sensors\n    LidarSensor.nb_lidar_sensors += 1\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor","title":"<code>Sensor</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Base class for all sensors.</p> <p>The sensors are based on QRayCaster. It casts a ray and detects collisions with obstacles. Detected collision is represented using a ImpactEntity object.</p> <p>Attributes:</p> Name Type Description <code>obstacles</code> <code>list[QEntity]</code> <p>Class attribute recording all entities that should be detected</p> <code>all_sensors</code> <code>list[Sensor]</code> <p>Class attribute recording all sensors</p> <code>hit</code> <code>QRayCasterHit | None</code> <p>Last hit of this sensor</p> Source code in <code>cogip/entities/sensor.py</code> <pre><code>class Sensor(QtCore.QObject):\n    \"\"\"\n    Base class for all sensors.\n\n    The sensors are based on [QRayCaster](https://doc.qt.io/qtforpython-6/PySide6/Qt3DRender/QRayCaster.html).\n    It casts a ray and detects collisions with obstacles.\n    Detected collision is represented using a [ImpactEntity][cogip.entities.impact.ImpactEntity] object.\n\n    Attributes:\n        obstacles: Class attribute recording all entities that should be detected\n        all_sensors: Class attribute recording all sensors\n        hit: Last hit of this sensor\n    \"\"\"\n\n    obstacles: list[Qt3DCore.QEntity] = []\n    all_sensors: list[\"Sensor\"] = []\n    hit: Qt3DRender.QRayCasterHit | None = None\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        origin_x: int,\n        origin_y: int,\n        origin_z: int,\n        direction_x: int,\n        direction_y: int,\n        direction_z: int,\n        impact_radius: float = 50,\n        impact_color: QtCore.Qt.GlobalColor = QtCore.Qt.red,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Origin and direction are relative to the parent entity (the robot).\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n            origin_z: Z origin of the ray caster\n            direction_x: X direction of the ray caster\n            direction_y: Y direction of the ray caster\n            direction_z: Z direction of the ray caster\n            impact_radius: Radius of the `ImpactEntity` representing the collision\n            impact_color: Color of the `ImpactEntity` representing the collision\n        \"\"\"\n        super().__init__()\n\n        Sensor.all_sensors.append(self)\n\n        self.origin_x = origin_x\n        self.origin_y = origin_y\n        self.asset_entity = asset_entity\n        self.name = name\n\n        self.ray_caster = Qt3DRender.QRayCaster()\n        self.ray_caster.setEnabled(False)  # Start casting only when the first obstacle is registered\n        self.ray_caster.setLength(0)  # Infinite\n        self.ray_caster.setRunMode(Qt3DRender.QAbstractRayCaster.Continuous)\n        self.ray_caster.setFilterMode(Qt3DRender.QAbstractRayCaster.AcceptAnyMatchingLayers)\n        self.ray_caster.setOrigin(QtGui.QVector3D(float(origin_x), float(origin_y), float(origin_z)))\n        self.ray_caster.setDirection(QtGui.QVector3D(direction_x, direction_y, direction_z))\n        self.asset_entity.addComponent(self.ray_caster)\n\n        # Add layers for obstacles already present\n        for obstacle in self.obstacles:\n            self.add_obstacle_layer(obstacle)\n\n        # Add impact entity\n        self.impact_entity = ImpactEntity(radius=impact_radius, color=impact_color)\n        self.impact_entity.setParent(self.asset_entity.parent().parent().parent())\n\n    @qtSlot()\n    def update_hit(self):\n        \"\"\"\n        Qt Slot\n\n        Compute the distance with the closest detected obstacle.\n        \"\"\"\n        distances = [hit for hit in self.ray_caster.hits() if hit.distance() != 0.0]\n        self.hit = None\n        if len(distances):\n            self.hit = min(distances, key=lambda x: x.distance())\n\n        self.update_impact()\n\n    def update_impact(self):\n        \"\"\"\n        Display the impact entity at the collision point.\n        \"\"\"\n        if self.hit:\n            self.impact_entity.setEnabled(True)\n            self.impact_entity.transform.setTranslation(self.hit.worldIntersection())\n        else:\n            self.impact_entity.setEnabled(False)\n\n    @classmethod\n    def add_obstacle(cls, obstacle: Qt3DCore.QEntity):\n        \"\"\"\n        Class method.\n\n        Register an obstacle added on the table.\n\n        Arguments:\n            obstacle: The obstacle to register\n        \"\"\"\n        cls.obstacles.append(obstacle)\n        for sensor in cls.all_sensors:\n            sensor.add_obstacle_layer(obstacle)\n\n    def add_obstacle_layer(self, obstacle: Qt3DCore.QEntity):\n        \"\"\"\n        Add the obstacle layer to the ray caster.\n        This allows the obstacle to be detected by the ray caster.\n\n        Arguments:\n            obstacle: The obstacle to detect\n        \"\"\"\n        self.ray_caster.addLayer(obstacle.layer)\n        # Activate if not already done\n        self.ray_caster.trigger()\n\n    @property\n    def distance(self) -&gt; int:\n        \"\"\"\n        Last sensor hit distance if any.\n        \"\"\"\n        dist = 65535\n        if self.hit:\n            dist = self.hit.distance()\n            dist += math.dist((0, 0), (self.origin_x, self.origin_y))\n        return int(dist)\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.distance","title":"<code>distance: int</code>  <code>property</code>","text":"<p>Last sensor hit distance if any.</p>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.__init__","title":"<code>__init__(asset_entity, name, origin_x, origin_y, origin_z, direction_x, direction_y, direction_z, impact_radius=50, impact_color=QtCore.Qt.red)</code>","text":"<p>Class constructor.</p> <p>Origin and direction are relative to the parent entity (the robot).</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>origin_x</code> <code>int</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>int</code> <p>Y origin of the ray caster</p> required <code>origin_z</code> <code>int</code> <p>Z origin of the ray caster</p> required <code>direction_x</code> <code>int</code> <p>X direction of the ray caster</p> required <code>direction_y</code> <code>int</code> <p>Y direction of the ray caster</p> required <code>direction_z</code> <code>int</code> <p>Z direction of the ray caster</p> required <code>impact_radius</code> <code>float</code> <p>Radius of the <code>ImpactEntity</code> representing the collision</p> <code>50</code> <code>impact_color</code> <code>GlobalColor</code> <p>Color of the <code>ImpactEntity</code> representing the collision</p> <code>red</code> Source code in <code>cogip/entities/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    origin_x: int,\n    origin_y: int,\n    origin_z: int,\n    direction_x: int,\n    direction_y: int,\n    direction_z: int,\n    impact_radius: float = 50,\n    impact_color: QtCore.Qt.GlobalColor = QtCore.Qt.red,\n):\n    \"\"\"\n    Class constructor.\n\n    Origin and direction are relative to the parent entity (the robot).\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n        origin_z: Z origin of the ray caster\n        direction_x: X direction of the ray caster\n        direction_y: Y direction of the ray caster\n        direction_z: Z direction of the ray caster\n        impact_radius: Radius of the `ImpactEntity` representing the collision\n        impact_color: Color of the `ImpactEntity` representing the collision\n    \"\"\"\n    super().__init__()\n\n    Sensor.all_sensors.append(self)\n\n    self.origin_x = origin_x\n    self.origin_y = origin_y\n    self.asset_entity = asset_entity\n    self.name = name\n\n    self.ray_caster = Qt3DRender.QRayCaster()\n    self.ray_caster.setEnabled(False)  # Start casting only when the first obstacle is registered\n    self.ray_caster.setLength(0)  # Infinite\n    self.ray_caster.setRunMode(Qt3DRender.QAbstractRayCaster.Continuous)\n    self.ray_caster.setFilterMode(Qt3DRender.QAbstractRayCaster.AcceptAnyMatchingLayers)\n    self.ray_caster.setOrigin(QtGui.QVector3D(float(origin_x), float(origin_y), float(origin_z)))\n    self.ray_caster.setDirection(QtGui.QVector3D(direction_x, direction_y, direction_z))\n    self.asset_entity.addComponent(self.ray_caster)\n\n    # Add layers for obstacles already present\n    for obstacle in self.obstacles:\n        self.add_obstacle_layer(obstacle)\n\n    # Add impact entity\n    self.impact_entity = ImpactEntity(radius=impact_radius, color=impact_color)\n    self.impact_entity.setParent(self.asset_entity.parent().parent().parent())\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.add_obstacle","title":"<code>add_obstacle(obstacle)</code>  <code>classmethod</code>","text":"<p>Class method.</p> <p>Register an obstacle added on the table.</p> <p>Parameters:</p> Name Type Description Default <code>obstacle</code> <code>QEntity</code> <p>The obstacle to register</p> required Source code in <code>cogip/entities/sensor.py</code> <pre><code>@classmethod\ndef add_obstacle(cls, obstacle: Qt3DCore.QEntity):\n    \"\"\"\n    Class method.\n\n    Register an obstacle added on the table.\n\n    Arguments:\n        obstacle: The obstacle to register\n    \"\"\"\n    cls.obstacles.append(obstacle)\n    for sensor in cls.all_sensors:\n        sensor.add_obstacle_layer(obstacle)\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.add_obstacle_layer","title":"<code>add_obstacle_layer(obstacle)</code>","text":"<p>Add the obstacle layer to the ray caster. This allows the obstacle to be detected by the ray caster.</p> <p>Parameters:</p> Name Type Description Default <code>obstacle</code> <code>QEntity</code> <p>The obstacle to detect</p> required Source code in <code>cogip/entities/sensor.py</code> <pre><code>def add_obstacle_layer(self, obstacle: Qt3DCore.QEntity):\n    \"\"\"\n    Add the obstacle layer to the ray caster.\n    This allows the obstacle to be detected by the ray caster.\n\n    Arguments:\n        obstacle: The obstacle to detect\n    \"\"\"\n    self.ray_caster.addLayer(obstacle.layer)\n    # Activate if not already done\n    self.ray_caster.trigger()\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.update_hit","title":"<code>update_hit()</code>","text":"<p>Qt Slot</p> <p>Compute the distance with the closest detected obstacle.</p> Source code in <code>cogip/entities/sensor.py</code> <pre><code>@qtSlot()\ndef update_hit(self):\n    \"\"\"\n    Qt Slot\n\n    Compute the distance with the closest detected obstacle.\n    \"\"\"\n    distances = [hit for hit in self.ray_caster.hits() if hit.distance() != 0.0]\n    self.hit = None\n    if len(distances):\n        self.hit = min(distances, key=lambda x: x.distance())\n\n    self.update_impact()\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.Sensor.update_impact","title":"<code>update_impact()</code>","text":"<p>Display the impact entity at the collision point.</p> Source code in <code>cogip/entities/sensor.py</code> <pre><code>def update_impact(self):\n    \"\"\"\n    Display the impact entity at the collision point.\n    \"\"\"\n    if self.hit:\n        self.impact_entity.setEnabled(True)\n        self.impact_entity.transform.setTranslation(self.hit.worldIntersection())\n    else:\n        self.impact_entity.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.ToFSensor","title":"<code>ToFSensor</code>","text":"<p>               Bases: <code>Sensor</code></p> <p>Specialized ToF sensor.</p> <p>It is represented by a small red cube placed at the origin of the ray caster.</p> <p>Its impact entity is represented by a small red sphere.</p> Source code in <code>cogip/entities/sensor.py</code> <pre><code>class ToFSensor(Sensor):\n    \"\"\"\n    Specialized ToF sensor.\n\n    It is represented by a small red cube placed at the origin of the ray caster.\n\n    Its impact entity is represented by a small red sphere.\n    \"\"\"\n\n    nb_tof_sensors = 0\n\n    def __init__(\n        self,\n        asset_entity: AssetEntity,\n        name: str,\n        origin_x: int,\n        origin_y: int,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            asset_entity: Entity containing the sensor\n            name: Name of the sensor\n            origin_x: X origin of the ray caster\n            origin_y: Y origin of the ray caster\n        \"\"\"\n        super().__init__(\n            asset_entity=asset_entity,\n            name=name,\n            origin_x=origin_x,\n            origin_y=origin_y,\n            origin_z=60,\n            direction_x=origin_x,\n            direction_y=origin_y,\n            direction_z=0,\n            impact_radius=50,\n            impact_color=QtCore.Qt.red,\n        )\n        self.tof_id = ToFSensor.nb_tof_sensors\n        ToFSensor.nb_tof_sensors += 1\n\n        rotation = math.degrees(math.acos(origin_x / math.dist((0, 0), (origin_x, origin_y))))\n\n        self.entity = Qt3DCore.QEntity()\n        self.entity.setParent(self.asset_entity)\n\n        self.mesh = Qt3DExtras.QCuboidMesh()\n        self.mesh.setXExtent(10)\n        self.mesh.setYExtent(10)\n        self.mesh.setZExtent(10)\n        self.entity.addComponent(self.mesh)\n\n        self.material = Qt3DExtras.QPhongMaterial()\n        self.material.setDiffuse(QtGui.QColor(QtCore.Qt.red))\n        self.entity.addComponent(self.material)\n\n        self.transform = Qt3DCore.QTransform()\n        self.transform.setTranslation(QtGui.QVector3D(origin_x, origin_y, 60))\n        self.transform.setRotationZ(rotation)\n        self.entity.addComponent(self.transform)\n</code></pre>"},{"location":"reference/cogip/entities/sensor/#cogip.entities.sensor.ToFSensor.__init__","title":"<code>__init__(asset_entity, name, origin_x, origin_y)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>asset_entity</code> <code>AssetEntity</code> <p>Entity containing the sensor</p> required <code>name</code> <code>str</code> <p>Name of the sensor</p> required <code>origin_x</code> <code>int</code> <p>X origin of the ray caster</p> required <code>origin_y</code> <code>int</code> <p>Y origin of the ray caster</p> required Source code in <code>cogip/entities/sensor.py</code> <pre><code>def __init__(\n    self,\n    asset_entity: AssetEntity,\n    name: str,\n    origin_x: int,\n    origin_y: int,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        asset_entity: Entity containing the sensor\n        name: Name of the sensor\n        origin_x: X origin of the ray caster\n        origin_y: Y origin of the ray caster\n    \"\"\"\n    super().__init__(\n        asset_entity=asset_entity,\n        name=name,\n        origin_x=origin_x,\n        origin_y=origin_y,\n        origin_z=60,\n        direction_x=origin_x,\n        direction_y=origin_y,\n        direction_z=0,\n        impact_radius=50,\n        impact_color=QtCore.Qt.red,\n    )\n    self.tof_id = ToFSensor.nb_tof_sensors\n    ToFSensor.nb_tof_sensors += 1\n\n    rotation = math.degrees(math.acos(origin_x / math.dist((0, 0), (origin_x, origin_y))))\n\n    self.entity = Qt3DCore.QEntity()\n    self.entity.setParent(self.asset_entity)\n\n    self.mesh = Qt3DExtras.QCuboidMesh()\n    self.mesh.setXExtent(10)\n    self.mesh.setYExtent(10)\n    self.mesh.setZExtent(10)\n    self.entity.addComponent(self.mesh)\n\n    self.material = Qt3DExtras.QPhongMaterial()\n    self.material.setDiffuse(QtGui.QColor(QtCore.Qt.red))\n    self.entity.addComponent(self.material)\n\n    self.transform = Qt3DCore.QTransform()\n    self.transform.setTranslation(QtGui.QVector3D(origin_x, origin_y, 60))\n    self.transform.setRotationZ(rotation)\n    self.entity.addComponent(self.transform)\n</code></pre>"},{"location":"reference/cogip/entities/table/","title":"table","text":""},{"location":"reference/cogip/entities/table/#cogip.entities.table.TableEntity","title":"<code>TableEntity</code>","text":"<p>               Bases: <code>AssetEntity</code></p> <p>The table entity.</p> <p>Attributes:</p> Name Type Description <code>asset_path</code> <code>Path</code> <p>Path of the asset file</p> Source code in <code>cogip/entities/table.py</code> <pre><code>class TableEntity(AssetEntity):\n    \"\"\"\n    The table entity.\n\n    Attributes:\n        asset_path: Path of the asset file\n    \"\"\"\n\n    asset_path: Path = Path(\"assets/table2024.dae\")\n\n    def __init__(self, parent: Qt3DCore.QEntity | None = None):\n        \"\"\"\n        Class constructor.\n\n        Inherits [AssetEntity][cogip.entities.asset.AssetEntity].\n        \"\"\"\n        super().__init__(self.asset_path, parent=parent)\n        self._parent = parent\n</code></pre>"},{"location":"reference/cogip/entities/table/#cogip.entities.table.TableEntity.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Inherits AssetEntity.</p> Source code in <code>cogip/entities/table.py</code> <pre><code>def __init__(self, parent: Qt3DCore.QEntity | None = None):\n    \"\"\"\n    Class constructor.\n\n    Inherits [AssetEntity][cogip.entities.asset.AssetEntity].\n    \"\"\"\n    super().__init__(self.asset_path, parent=parent)\n    self._parent = parent\n</code></pre>"},{"location":"reference/cogip/models/actuators/","title":"actuators","text":""},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorBase","title":"<code>ActuatorBase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base model for actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorBase(BaseModel):\n    \"\"\"Base model for actuators\"\"\"\n\n    enabled: bool = Field(\n        False,\n        title=\"Enabled\",\n        description=\"An actuator is enabled if it has been initialized with its current value\",\n    )\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ActuatorsKindEnum","title":"<code>ActuatorsKindEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining actuators kind</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ActuatorsKindEnum(IntEnum):\n    \"\"\"Enum defining actuators kind\"\"\"\n\n    servo = 0\n    positional_actuator = 1\n    bool_sensor = 2\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensor","title":"<code>BoolSensor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining bool sensor state</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensor(BaseModel):\n    \"\"\"Model defining bool sensor state\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.bool_sensor] = ActuatorsKindEnum.bool_sensor\n    id: Annotated[\n        BoolSensorEnum,\n        Field(\n            title=\"Id\",\n            description=\"Bool sensor identifier\",\n        ),\n    ]\n    state: Annotated[\n        bool,\n        Field(\n            title=\"State\",\n            description=\"Bool sensor state\",\n        ),\n    ] = False\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.BoolSensorEnum","title":"<code>BoolSensorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining bool sensors IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class BoolSensorEnum(IntEnum):\n    \"\"\"Enum defining bool sensors IDs\"\"\"\n\n    BOTTOM_GRIP_LEFT = 0\n    BOTTOM_GRIP_RIGHT = 1\n    TOP_GRIP_LEFT = 2\n    TOP_GRIP_RIGHT = 3\n    MAGNET_LEFT = 4\n    MAGNET_RIGHT = 5\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuator","title":"<code>PositionalActuator</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>PositionalActuatorCommand</code></p> <p>Full model for positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuator(ActuatorBase, PositionalActuatorCommand):\n    \"Full model for positional actuators\"\n\n    pass\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand","title":"<code>PositionalActuatorCommand</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining a command to send to positional actuators</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorCommand(BaseModel):\n    \"\"\"Model defining a command to send to positional actuators\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.positional_actuator] = ActuatorsKindEnum.positional_actuator\n    id: PositionalActuatorEnum = Field(..., title=\"Id\", description=\"Positional Actuator identifier\")\n    command: int = Field(\n        0,\n        ge=-100,\n        le=999,\n        title=\"Position Command\",\n        description=\"Current positional actuator position command\",\n    )\n\n    @field_validator(\"kind\", mode=\"before\")\n    @classmethod\n    def validate_kind(cls, v: str) -&gt; ActuatorsKindEnum:\n        try:\n            value = ActuatorsKindEnum[v]\n        except KeyError:\n            try:\n                value = ActuatorsKindEnum(v)\n            except Exception:\n                raise ValueError(\"Not a ActuatorsKindEnum\")\n        if value != ActuatorsKindEnum.positional_actuator:\n            raise ValueError(\"Not ActuatorsKindEnum.positional_actuator value\")\n        return value\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def validate_id(cls, v: str) -&gt; PositionalActuatorEnum:\n        try:\n            return PositionalActuatorEnum[v]\n        except KeyError:\n            try:\n                return PositionalActuatorEnum(v)\n            except Exception:\n                raise ValueError(\"Not a PositionalActuatorEnum\")\n\n    def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n        \"\"\"Copy values to Protobuf message\"\"\"\n        message.id = self.id\n        message.command = self.command\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorCommand.pb_copy","title":"<code>pb_copy(message)</code>","text":"<p>Copy values to Protobuf message</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>def pb_copy(self, message: PB_PositionalActuatorCommand) -&gt; None:\n    \"\"\"Copy values to Protobuf message\"\"\"\n    message.id = self.id\n    message.command = self.command\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.PositionalActuatorEnum","title":"<code>PositionalActuatorEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining positional actuators IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class PositionalActuatorEnum(IntEnum):\n    \"\"\"Enum defining positional actuators IDs\"\"\"\n\n    MOTOR_BOTTOM_LIFT = 0\n    MOTOR_TOP_LIFT = 1\n    ANALOGSERVO_BOTTOM_GRIP_LEFT = 2\n    ANALOGSERVO_BOTTOM_GRIP_RIGHT = 3\n    ANALOGSERVO_TOP_GRIP_LEFT = 4\n    ANALOGSERVO_TOP_GRIP_RIGHT = 5\n    CART_MAGNET_LEFT = 6\n    CART_MAGNET_RIGHT = 7\n    ANALOGSERVO_PAMI = 8\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.Servo","title":"<code>Servo</code>","text":"<p>               Bases: <code>ActuatorBase</code>, <code>ServoCommand</code></p> <p>Full model for servos</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class Servo(ActuatorBase, ServoCommand):\n    \"Full model for servos\"\n\n    position: int = Field(\n        0,\n        ge=0,\n        le=999,\n        title=\"Position\",\n        description=\"Current servo position\",\n    )\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ServoCommand","title":"<code>ServoCommand</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model defining a command to send to servos</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ServoCommand(BaseModel):\n    \"\"\"Model defining a command to send to servos\"\"\"\n\n    kind: Literal[ActuatorsKindEnum.servo] = ActuatorsKindEnum.servo\n    id: ServoEnum = Field(\n        ...,\n        title=\"Id\",\n        description=\"Servo identifier\",\n    )\n    command: int = Field(\n        0,\n        ge=0,\n        le=999,\n        title=\"Position Command\",\n        description=\"Current servo position command\",\n    )\n\n    @field_validator(\"kind\", mode=\"before\")\n    @classmethod\n    def validate_kind(cls, v: str) -&gt; ActuatorsKindEnum:\n        try:\n            value = ActuatorsKindEnum[v]\n        except KeyError:\n            try:\n                value = ActuatorsKindEnum(v)\n            except Exception:\n                raise ValueError(\"Not a ActuatorsKindEnum\")\n        if value != ActuatorsKindEnum.servo:\n            raise ValueError(\"Not ActuatorsKindEnum.servo value\")\n        return value\n\n    @field_validator(\"id\", mode=\"before\")\n    @classmethod\n    def validate_id(cls, v: str) -&gt; ServoEnum:\n        try:\n            return ServoEnum[v]\n        except KeyError:\n            try:\n                return ServoEnum(v)\n            except Exception:\n                raise ValueError(\"Not a ServoEnum\")\n\n    def pb_copy(self, message: PB_ServoCommand) -&gt; None:\n        \"\"\"Copy values to Protobuf message\"\"\"\n        message.id = self.id\n        message.command = self.command\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ServoCommand.pb_copy","title":"<code>pb_copy(message)</code>","text":"<p>Copy values to Protobuf message</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>def pb_copy(self, message: PB_ServoCommand) -&gt; None:\n    \"\"\"Copy values to Protobuf message\"\"\"\n    message.id = self.id\n    message.command = self.command\n</code></pre>"},{"location":"reference/cogip/models/actuators/#cogip.models.actuators.ServoEnum","title":"<code>ServoEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum defining servo IDs</p> Source code in <code>cogip/models/actuators.py</code> <pre><code>class ServoEnum(IntEnum):\n    \"\"\"Enum defining servo IDs\"\"\"\n\n    LXSERVO_LEFT_CART = 0\n    LXSERVO_RIGHT_CART = 1\n    LXSERVO_ARM_PANEL = 2\n</code></pre>"},{"location":"reference/cogip/models/artifacts/","title":"artifacts","text":""},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.DropoffZoneID","title":"<code>DropoffZoneID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify drop-off zones.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class DropoffZoneID(IntEnum):\n    \"\"\"\n    Enum to identify drop-off zones.\n    \"\"\"\n\n    Top = auto()\n    Bottom = auto()\n    Opposite = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.PlantSupplyID","title":"<code>PlantSupplyID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify plant supplies.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class PlantSupplyID(IntEnum):\n    \"\"\"\n    Enum to identify plant supplies.\n    \"\"\"\n\n    CenterTop = auto()\n    CenterBottom = auto()\n    LocalTop = auto()\n    LocalBottom = auto()\n    OppositeTop = auto()\n    OppositeBottom = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.PlanterID","title":"<code>PlanterID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify planters.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class PlanterID(IntEnum):\n    \"\"\"\n    Enum to identify planters.\n    \"\"\"\n\n    Top = auto()\n    LocalSide = auto()\n    OppositeSide = auto()\n    Test = auto()  # To use on the training table only\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.PotSupplyID","title":"<code>PotSupplyID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify pot supplies.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class PotSupplyID(IntEnum):\n    \"\"\"\n    Enum to identify pot supplies.\n    \"\"\"\n\n    LocalTop = auto()\n    LocalMiddle = auto()\n    LocalBottom = auto()\n    OppositeTop = auto()\n    OppositeMiddle = auto()\n    OppositeBottom = auto()\n</code></pre>"},{"location":"reference/cogip/models/artifacts/#cogip.models.artifacts.SolarPanelsID","title":"<code>SolarPanelsID</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum to identify solar panels.</p> Source code in <code>cogip/models/artifacts.py</code> <pre><code>class SolarPanelsID(IntEnum):\n    \"\"\"\n    Enum to identify solar panels.\n    \"\"\"\n\n    Local = auto()\n    Shared = auto()\n</code></pre>"},{"location":"reference/cogip/models/models/","title":"models","text":"<p>This module contains all data models used in the monitor.</p> <p>The models are based on Pydantic models, allowing them to be loaded from/exported to JSON strings/files. All values are automatically verified and converted to the expected data type, an exception being raised if impossible.</p>"},{"location":"reference/cogip/models/models/#cogip.models.models.CameraExtrinsicParameters","title":"<code>CameraExtrinsicParameters</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing camera extrinsic properties</p> Source code in <code>cogip/models/models.py</code> <pre><code>class CameraExtrinsicParameters(BaseModel):\n    \"\"\"Model representing camera extrinsic properties\"\"\"\n\n    x: float\n    y: float\n    z: float\n    angle: float\n\n    @property\n    def tvec(self) -&gt; ArrayLike:\n        return np.array([self.x, self.y, self.z])\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect","title":"<code>DynObstacleRect</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic rectangle obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X coordinate of the obstacle center</p> <code>y</code> <code>float</code> <p>Y coordinate of the obstacle center</p> <code>angle</code> <code>float</code> <p>Orientation of the obstacle</p> <code>length_x</code> <code>float</code> <p>length along X axis</p> <code>length_y</code> <code>float</code> <p>length along Y axis</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynObstacleRect(BaseModel):\n    \"\"\"\n    A dynamic rectangle obstacle created by the robot.\n\n    Attributes:\n        x: X coordinate of the obstacle center\n        y: Y coordinate of the obstacle center\n        angle: Orientation of the obstacle\n        length_x: length along X axis\n        length_y: length along Y axis\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    angle: float\n    length_x: float\n    length_y: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        return (self.x - half_length_x &lt;= point.x &lt;= self.x + half_length_x) and (\n            self.y - half_length_y &lt;= point.y &lt;= self.y + half_length_y\n        )\n\n    def create_bounding_box(self, bb_radius: float, nb_vertices: int = 4):\n        half_length_x = self.length_x / 2\n        half_length_y = self.length_y / 2\n\n        self.bb = [\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y + half_length_y + bb_radius),\n            Vertex(x=self.x + half_length_x + bb_radius, y=self.y - half_length_y - bb_radius),\n            Vertex(x=self.x - half_length_x - bb_radius, y=self.y - half_length_y - bb_radius),\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynObstacleRect.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle","title":"<code>DynRoundObstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A dynamic round obstacle created by the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>Center X position</p> <code>y</code> <code>float</code> <p>Center Y position</p> <code>radius</code> <code>float</code> <p>Radius of the obstacle</p> <code>bb</code> <code>list[Vertex]</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class DynRoundObstacle(BaseModel):\n    \"\"\"\n    A dynamic round obstacle created by the robot.\n\n    Attributes:\n        x: Center X position\n        y: Center Y position\n        radius: Radius of the obstacle\n        bb: bounding box\n    \"\"\"\n\n    x: float\n    y: float\n    radius: float\n    bb: list[Vertex] = []\n\n    def contains(self, point: Vertex) -&gt; bool:\n        return (point.x - self.x) * (point.x - self.x) + (point.y - self.y) * (point.y - self.y) &lt;= self.radius**2\n\n    def create_bounding_box(self, bb_radius, nb_vertices):\n        self.bb = [\n            Vertex(\n                x=self.x + bb_radius * math.cos(tmp := (i * 2 * math.pi) / nb_vertices),\n                y=self.y + bb_radius * math.sin(tmp),\n            )\n            for i in reversed(range(nb_vertices))\n        ]\n\n    def __hash__(self):\n        \"\"\"\n        Hash function to allow this class to be used as a key in a dict.\n        \"\"\"\n        return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.DynRoundObstacle.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash function to allow this class to be used as a key in a dict.</p> Source code in <code>cogip/models/models.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Hash function to allow this class to be used as a key in a dict.\n    \"\"\"\n    return hash((type(self),) + tuple(self.__root__))\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.LogMessage","title":"<code>LogMessage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A log received on the serial port.</p> <p>Attributes:</p> Name Type Description <code>log</code> <code>str</code> <p>message</p> Source code in <code>cogip/models/models.py</code> <pre><code>class LogMessage(BaseModel):\n    \"\"\"\n    A log received on the serial port.\n\n    Attributes:\n        log: message\n    \"\"\"\n\n    log: str\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.MenuEntry","title":"<code>MenuEntry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents one entry in a firmware's shell menu</p> <p>Attributes:</p> Name Type Description <code>cmd</code> <code>str</code> <p>Command name</p> <code>desc</code> <code>str</code> <p>Description of the command</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>MenuEntry.model_validate_json(\"{\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\")\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class MenuEntry(BaseModel):\n    \"\"\"\n    Represents one entry in a firmware's shell menu\n\n    Attributes:\n        cmd: Command name\n        desc: Description of the command\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        MenuEntry.model_validate_json(\"{\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\")\n        ```\n    \"\"\"\n\n    cmd: str\n    desc: str\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Obstacle","title":"<code>Obstacle</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains the properties of an obstacle added on the table.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>int</code> <p>X position</p> <code>y</code> <code>int</code> <p>Y position</p> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>length</code> <code>int</code> <p>Length</p> <code>width</code> <code>int</code> <p>Width</p> <code>height</code> <code>int</code> <p>Height</p> <code>bb</code> <code>int</code> <p>bounding box</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Obstacle(BaseModel):\n    \"\"\"\n    Contains the properties of an obstacle added on the table.\n\n    Attributes:\n        x: X position\n        y: Y position\n        rotation: Rotation\n        length: Length\n        width: Width\n        height: Height\n        bb: bounding box\n    \"\"\"\n\n    x: int = 0\n    y: int = 1000\n    rotation: int = 0\n    length: int = 200\n    width: int = 200\n    height: int = 600\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose","title":"<code>PathPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Class representing a position in a path.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>X coordinate</p> <code>y</code> <p>Y coordinate</p> <code>O</code> <p>0-orientation</p> <code>max_speed_linear</code> <code>int</code> <p>max linear speed in percentage of the robot max linear speed</p> <code>max_speed_angular</code> <code>int</code> <p>max angular speed in percentage of the robot max angular speed</p> <code>allow_reverse</code> <code>bool</code> <p>reverse mode</p> <code>bypass_anti_blocking</code> <code>bool</code> <p>send pose_reached if robot is blocked</p> <code>timeout_ms</code> <code>int</code> <p>max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout</p> <code>bypass_final_orientation</code> <code>bool</code> <p>do not set orientation pose order</p> Source code in <code>cogip/models/models.py</code> <pre><code>class PathPose(Pose):\n    \"\"\"\n    Class representing a position in a path.\n\n    Attributes:\n        x: X coordinate\n        y: Y coordinate\n        O: 0-orientation\n        max_speed_linear: max linear speed in percentage of the robot max linear speed\n        max_speed_angular: max angular speed in percentage of the robot max angular speed\n        allow_reverse: reverse mode\n        bypass_anti_blocking: send pose_reached if robot is blocked\n        timeout_ms: max time is milliseconds to reach the pose, the robot stops if timeout is reached, 0 for no timeout\n        bypass_final_orientation: do not set orientation pose order\n    \"\"\"\n\n    max_speed_linear: int = 66\n    max_speed_angular: int = 66\n    allow_reverse: bool = True\n    bypass_anti_blocking: bool = False\n    timeout_ms: int = 0\n    bypass_final_orientation: bool = False\n\n    @property\n    def pose(self) -&gt; Pose:\n        return Pose(**self.model_dump())\n\n    def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n        \"\"\"\n        Copy data in a Protobuf message.\n\n        Arguments:\n            pb_path_pose: Protobuf message to fill\n        \"\"\"\n        pb_path_pose.pose.x = int(self.x)\n        pb_path_pose.pose.y = int(self.y)\n        pb_path_pose.pose.O = int(self.O)  # noqa\n        pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n        pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n        pb_path_pose.allow_reverse = self.allow_reverse\n        pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n        pb_path_pose.timeout_ms = self.timeout_ms\n        pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.PathPose.copy_pb","title":"<code>copy_pb(pb_path_pose)</code>","text":"<p>Copy data in a Protobuf message.</p> <p>Parameters:</p> Name Type Description Default <code>pb_path_pose</code> <code>PB_PathPose</code> <p>Protobuf message to fill</p> required Source code in <code>cogip/models/models.py</code> <pre><code>def copy_pb(self, pb_path_pose: PB_PathPose) -&gt; None:\n    \"\"\"\n    Copy data in a Protobuf message.\n\n    Arguments:\n        pb_path_pose: Protobuf message to fill\n    \"\"\"\n    pb_path_pose.pose.x = int(self.x)\n    pb_path_pose.pose.y = int(self.y)\n    pb_path_pose.pose.O = int(self.O)  # noqa\n    pb_path_pose.max_speed_ratio_linear = self.max_speed_linear\n    pb_path_pose.max_speed_ratio_angular = self.max_speed_angular\n    pb_path_pose.allow_reverse = self.allow_reverse\n    pb_path_pose.bypass_anti_blocking = self.bypass_anti_blocking\n    pb_path_pose.timeout_ms = self.timeout_ms\n    pb_path_pose.bypass_final_orientation = self.bypass_final_orientation\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>Vertex</code></p> <p>A position of the robot.</p> <p>Attributes:</p> Name Type Description <code>x</code> <p>X position</p> <code>y</code> <p>Y position</p> <code>O</code> <code>float | None</code> <p>Rotation</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Pose(Vertex):\n    \"\"\"\n    A position of the robot.\n\n    Attributes:\n        x: X position\n        y: Y position\n        O: Rotation\n    \"\"\"\n\n    O: float | None = 0.0  # noqa\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.RobotState","title":"<code>RobotState</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>This contains information about robot state, like mode, cycle, positions, speed, path and obstacles. It is given by the firmware through the serial port.</p> <p>Attributes:</p> Name Type Description <code>pose_order</code> <code>Pose</code> <p>Position to reach</p> <code>cycle</code> <code>int</code> <p>Current cycle</p> <code>speed_current</code> <code>Speed</code> <p>Current speed</p> <code>speed_order</code> <code>Speed</code> <p>Speed order</p> <code>path</code> <code>Speed</code> <p>Computed path</p> Source code in <code>cogip/models/models.py</code> <pre><code>class RobotState(BaseModel):\n    \"\"\"\n    This contains information about robot state,\n    like mode, cycle, positions, speed, path and obstacles.\n    It is given by the firmware through the serial port.\n\n    Attributes:\n        pose_order: Position to reach\n        cycle: Current cycle\n        speed_current: Current speed\n        speed_order: Speed order\n        path: Computed path\n    \"\"\"\n\n    pose_current: Pose = Pose()\n    pose_order: Pose = Pose()\n    cycle: int = 0\n    speed_current: Speed = Speed()\n    speed_order: Speed = Speed()\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.ShellMenu","title":"<code>ShellMenu</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a firmware's shell menu.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the menu</p> <code>entries</code> <code>list[MenuEntry]</code> <p>List of the menu entries</p> <p>Examples:</p> <p>The following line shows how to initialize this class from a JSON string received on the serial port:</p> <pre><code>ShellMenu.model_validate_json(\n    \"{\\\"name\\\": \\\"planner\\\",\"\n    \" \\\"entries\\\": [\"\n    \"    {\\\"cmd\\\": \\\"_help_json\\\", \\\"desc\\\": \\\"Display available commands in JSON format\\\"},\"\n    \"    {\\\"cmd\\\": \\\"_state\\\", \\\"desc\\\": \\\"Print current state\\\"}\n    \"]}\"\n)\n</code></pre> Source code in <code>cogip/models/models.py</code> <pre><code>class ShellMenu(BaseModel):\n    \"\"\"\n    Represents a firmware's shell menu.\n\n    Attributes:\n        name: Name of the menu\n        entries: List of the menu entries\n\n    Examples:\n        The following line shows how to initialize this class from a JSON\n        string received on the serial port:\n        ```py\n        ShellMenu.model_validate_json(\n            \"{\\\\\"name\\\\\": \\\\\"planner\\\\\",\"\n            \" \\\\\"entries\\\\\": [\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_help_json\\\\\", \\\\\"desc\\\\\": \\\\\"Display available commands in JSON format\\\\\"},\"\n            \"    {\\\\\"cmd\\\\\": \\\\\"_state\\\\\", \\\\\"desc\\\\\": \\\\\"Print current state\\\\\"}\n            \"]}\"\n        )\n        ```\n    \"\"\"\n\n    name: str\n    entries: list[MenuEntry]\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Speed","title":"<code>Speed</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A speed value.</p> <p>Attributes:</p> Name Type Description <code>distance</code> <code>float</code> <p>Linear speed</p> <code>angle</code> <code>float</code> <p>Angular speed</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Speed(BaseModel):\n    \"\"\"\n    A speed value.\n\n    Attributes:\n        distance: Linear speed\n        angle: Angular speed\n    \"\"\"\n\n    distance: float = 0.0\n    angle: float = 0.0\n</code></pre>"},{"location":"reference/cogip/models/models/#cogip.models.models.Vertex","title":"<code>Vertex</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a point in 2D/3D coordinates.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>float</code> <p>X position</p> <code>y</code> <code>float</code> <p>Y position</p> <code>z</code> <code>float</code> <p>Z position (optional)</p> Source code in <code>cogip/models/models.py</code> <pre><code>class Vertex(BaseModel):\n    \"\"\"\n    Represents a point in 2D/3D coordinates.\n\n    Attributes:\n        x: X position\n        y: Y position\n        z: Z position (optional)\n    \"\"\"\n\n    x: float = 0.0\n    y: float = 0.0\n    z: float = 0.0\n\n    def __hash__(self):\n        return hash((type(self),) + tuple(self.__dict__.values()))\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/beaconcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/beaconcam/app/#cogip.tools.beaconcam.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/beaconcam/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = CameraServer()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization, sample detection.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization, sample detection.\n    \"\"\"\n\n    _camera_device: Path = None  # Camera device\n    _camera_codec: VideoCodec = None  # Video codec\n    _camera_frame_width: int = None  # Camera frame width\n    _camera_frame_height: int = None  # Camera frame height\n    _camera_capture: cv2.VideoCapture = None  # OpenCV video capture\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _frame_rate: float = 6  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        signal.signal(signal.SIGTERM, self.exit_handler)\n\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False)\n        self.register_sio_events()\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            )\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera and aruco markers detection parameters.\n        \"\"\"\n        self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n        if not self._camera_capture.isOpened():\n            logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n            self._camera_capture.release()\n            self._camera_capture = None\n            return\n\n        fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n        ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n        if not ret:\n            logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n            self.settings.camera_codec = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n        if not ret:\n            logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n            self.settings.camera_width = None\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n        if not ret:\n            logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n            self.settings.camera_height = None\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self._camera_capture:\n            try:\n                self._camera_capture.release()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self._camera_capture = None\n\n    def open_last_frame(self, size: int) -&gt; None:\n        \"\"\"\n        Open the shared memory used to exchange last frame with the server.\n\n        Arguments:\n            size: Size of the shared memory\n        \"\"\"\n        if not self._last_frame:\n            try:\n                self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n                logger.info(\"Camera handler: shared memory for last_frame created.\")\n            except FileExistsError as exc:\n                logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n                self._last_frame = None\n\n    def close_last_frame(self) -&gt; None:\n        \"\"\"\n        Close last frame shared memory.\n        \"\"\"\n        if self._last_frame:\n            try:\n                self._last_frame.close()\n                self._last_frame.unlink()\n                logger.info(\"Camera handler: Shared memory for last frame closed.\")\n            except Exception as exc:\n                logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n        self._last_frame = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self._camera_capture:\n                    self.open_camera()\n\n                if not self._camera_capture:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except (KeyboardInterrupt, ExitSignal):\n            pass\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_last_frame()\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_color: np.ndarray\n        ret, image_color = self._camera_capture.read()\n        if not ret:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        image_stream: np.ndarray = image_color\n\n        # Encode the frame in BMP format (larger but faster than JPEG)\n        encoded_image: np.ndarray\n        ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        frame = encoded_image.tobytes()\n        self.open_last_frame(len(frame))\n\n        if self._last_frame:\n            self._last_frame.buf[0 : len(frame)] = frame\n\n        if self.record_writer:\n            self.record_writer.write(image_stream)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"beacon_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter_fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/beaconcam\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/beaconcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/beaconcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/beaconcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    signal.signal(signal.SIGTERM, self.exit_handler)\n\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False)\n    self.register_sio_events()\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        )\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self._camera_capture:\n                self.open_camera()\n\n            if not self._camera_capture:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except (KeyboardInterrupt, ExitSignal):\n        pass\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_last_frame()\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self._camera_capture:\n        try:\n            self._camera_capture.release()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self._camera_capture = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.close_last_frame","title":"<code>close_last_frame()</code>","text":"<p>Close last frame shared memory.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def close_last_frame(self) -&gt; None:\n    \"\"\"\n    Close last frame shared memory.\n    \"\"\"\n    if self._last_frame:\n        try:\n            self._last_frame.close()\n            self._last_frame.unlink()\n            logger.info(\"Camera handler: Shared memory for last frame closed.\")\n        except Exception as exc:\n            logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n    self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera and aruco markers detection parameters.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera and aruco markers detection parameters.\n    \"\"\"\n    self._camera_capture = cv2.VideoCapture(str(self.settings.camera_device), cv2.CAP_V4L2)\n    if not self._camera_capture.isOpened():\n        logger.error(f\"Camera handler: Cannot open camera device {self.settings.camera_device}\")\n        self._camera_capture.release()\n        self._camera_capture = None\n        return\n\n    fourcc = cv2.VideoWriter_fourcc(*self.settings.camera_codec.value)\n    ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {self.settings.camera_codec} not supported\")\n        self.settings.camera_codec = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n        self.settings.camera_width = None\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n        self.settings.camera_height = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.open_last_frame","title":"<code>open_last_frame(size)</code>","text":"<p>Open the shared memory used to exchange last frame with the server.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the shared memory</p> required Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def open_last_frame(self, size: int) -&gt; None:\n    \"\"\"\n    Open the shared memory used to exchange last frame with the server.\n\n    Arguments:\n        size: Size of the shared memory\n    \"\"\"\n    if not self._last_frame:\n        try:\n            self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n            logger.info(\"Camera handler: shared memory for last_frame created.\")\n        except FileExistsError as exc:\n            logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n            self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_color: np.ndarray\n    ret, image_color = self._camera_capture.read()\n    if not ret:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    image_stream: np.ndarray = image_color\n\n    # Encode the frame in BMP format (larger but faster than JPEG)\n    encoded_image: np.ndarray\n    ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    frame = encoded_image.tobytes()\n    self.open_last_frame(len(frame))\n\n    if self._last_frame:\n        self._last_frame.buf[0 : len(frame)] = frame\n\n    if self.record_writer:\n        self.record_writer.write(image_stream)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/camera/#cogip.tools.beaconcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/beaconcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(str(self.settings.socketio_server_url), namespaces=[\"/beaconcam\"])\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/codecs/","title":"codecs","text":""},{"location":"reference/cogip/tools/beaconcam/codecs/#cogip.tools.beaconcam.codecs.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/beaconcam/codecs.py</code> <pre><code>class VideoCodec(str, Enum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/beaconcam/main/#cogip.tools.beaconcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Beacon Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-beaconcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/beaconcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Beacon Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-beaconcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler)\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        \"cogip.tools.beaconcam.app:app\",\n        host=\"0.0.0.0\",\n        port=8100,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n\n        if CameraServer._last_frame:\n            try:\n                CameraServer._last_frame.close()\n                logger.info(\"Camera server: Detached shared memory for last frame.\")\n            except FileNotFoundError:\n                pass\n\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def camera_connect(self) -&gt; bool:\n        if self._exiting:\n            return True\n\n        try:\n            CameraServer._last_frame = SharedMemory(name=\"last_frame\")\n        except Exception:\n            CameraServer._last_frame = None\n            logger.warning(\"Camera server: Failed to attach to shared memory last_frame, retrying in 1s.\")\n            return False\n        logger.info(\"Camera server: Attached to shared memory last_frame.\")\n        return True\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n            yield bytes(self._last_frame.buf)\n            yield b\"\\r\\n\"\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.on_event(\"startup\")\n        async def startup_event():\n            \"\"\"\n            Function called at FastAPI server startup.\n            \"\"\"\n            # Poll in background to wait for camera server connection through shared memory.\n            Thread(\n                target=lambda: polling2.poll(\n                    self.camera_connect,\n                    step=1,\n                    poll_forever=True,\n                )\n            ).start()\n\n        @self.app.on_event(\"shutdown\")\n        async def shutdown_event():\n            \"\"\"\n            Function called at FastAPI server shutdown.\n            \"\"\"\n            pass\n\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if CameraServer._last_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        async def snapshot(camp: Camp.Colors):\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"beacon-snapshot-{timestamp}-{camp.name}\"\n\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            record_filename_full = self.records_dir / f\"{basename}_full.jpg\"\n            cv2.imwrite(str(record_filename_full), frame)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.app = FastAPI(title=\"COGIP Beacon Camera Streamer\", debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.beaconcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        yield b\"--frame\\r\\n\"\n        yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n        yield bytes(self._last_frame.buf)\n        yield b\"\\r\\n\"\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/server/#cogip.tools.beaconcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/beaconcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n\n    if CameraServer._last_frame:\n        try:\n            CameraServer._last_frame.close()\n            logger.info(\"Camera server: Detached shared memory for last frame.\")\n        except FileNotFoundError:\n            pass\n\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/beaconcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/camera/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/camera/__main__/#cogip.tools.camera.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Camera Tools.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-camera</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/camera/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Camera Tools.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-camera` script using this function as entrypoint.\n    \"\"\"\n    app()\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/","title":"arguments","text":""},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.CameraName","title":"<code>CameraName</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Supported cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class CameraName(ArgEnum):\n    \"\"\"Supported cameras\"\"\"\n\n    hbv = Path(\"/dev/v4l/by-id/usb-HBV_HD_CAMERA_HBV_HD_CAMERA-video-index0\")\n    sonix = Path(\"/dev/v4l/by-id/usb-Sonix_Technology_Co.__Ltd._USB_2.0_Camera_SN0001-video-index0\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/arguments/#cogip.tools.camera.arguments.VideoCodec","title":"<code>VideoCodec</code>","text":"<p>               Bases: <code>ArgEnum</code></p> <p>Video codecs supported by our cameras</p> Source code in <code>cogip/tools/camera/arguments.py</code> <pre><code>class VideoCodec(ArgEnum):\n    \"\"\"Video codecs supported by our cameras\"\"\"\n\n    mjpg = \"MJPG\"\n    yuyv = \"YUYV\"\n</code></pre>"},{"location":"reference/cogip/tools/camera/calibrate/","title":"calibrate","text":""},{"location":"reference/cogip/tools/camera/calibrate/#cogip.tools.camera.calibrate.cmd_calibrate","title":"<code>cmd_calibrate(ctx, id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, charuco_rows=13, charuco_cols=8, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=False)</code>","text":"<p>Calibrate camera using images captured by the 'capture' command</p> Source code in <code>cogip/tools/camera/calibrate.py</code> <pre><code>def cmd_calibrate(\n    ctx: typer.Context,\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 13,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 8,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = False,\n):\n    \"\"\"Calibrate camera using images captured by the 'capture' command\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n    capture_path = Path(__file__).parent  # Directory to store captured frames\n    capture_path /= f\"cameras/{id}/{camera_name.name}_{camera_codec.name}_{camera_width}x{camera_height}/images\"\n    params_filename = get_camera_intrinsic_params_filename(id, camera_name, camera_codec, camera_width, camera_height)\n\n    if not capture_path.exists():\n        logger.error(f\"Captured images directory not found: {capture_path}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_rows, charuco_cols),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    if charuco_legacy:\n        board.setLegacyPattern(True)\n\n    captured_images = list(capture_path.glob(\"image_*.jpg\"))\n    if (nb_img := len(captured_images)) &lt; 10:\n        logger.error(f\"Not enough images: {nb_img} &lt; 10\")\n        return\n\n    object_points = []\n    image_points: list[cv2.typing.MatLike] = []\n\n    board_detector = cv2.aruco.CharucoDetector(board)\n\n    for im in sorted(captured_images)[0:]:\n        frame = cv2.imread(str(im))\n        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        char_corners, char_ids, _, _ = board_detector.detectBoard(gray)\n        if char_corners is None or len(char_corners) == 0:\n            logger.info(f\"{im}: KO\")\n            continue\n        logger.info(f\"{im}: OK\")\n        frame_obj_points, frame_img_points = board.matchImagePoints(char_corners, char_ids)\n        object_points.append(frame_obj_points)\n        image_points.append(frame_img_points)\n\n        if debug:\n            cv2.aruco.drawDetectedCornersCharuco(frame, char_corners, char_ids)\n            cv2.imshow(\"img\", frame)\n            cv2.waitKey(1000)\n\n    ret, camera_matrix, dist_coefs, _, _ = cv2.calibrateCamera(\n        object_points,\n        image_points,\n        (camera_width, camera_height),\n        None,\n        None,\n    )\n\n    logger.debug(f\"Camera calibration status: {ret}\")\n    logger.debug(\"- camera matrix:\")\n    logger.debug(camera_matrix)\n    logger.debug(\"- dist coefs:\")\n    logger.debug(dist_coefs)\n\n    save_camera_intrinsic_params(camera_matrix, dist_coefs, params_filename)\n    logger.info(f\"Calibration parameters stored in: {params_filename}\")\n</code></pre>"},{"location":"reference/cogip/tools/camera/capture/","title":"capture","text":""},{"location":"reference/cogip/tools/camera/capture/#cogip.tools.camera.capture.cmd_capture","title":"<code>cmd_capture(id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, max_frames=120, capture_interval=10, charuco_rows=8, charuco_cols=13, charuco_marker_length=23, charuco_square_length=30, charuco_legacy=False)</code>","text":"<p>Capture images to be used by the 'calibrate' command</p> Source code in <code>cogip/tools/camera/capture.py</code> <pre><code>def cmd_capture(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    max_frames: Annotated[\n        int,\n        typer.Option(\n            help=\"Maximum number of frames to read before exiting\",\n            envvar=\"CAMERA_MAX_FRAMES\",\n        ),\n    ] = 120,\n    capture_interval: Annotated[\n        int,\n        typer.Option(\n            help=\"Capture an image every 'capture_interval' frames\",\n            envvar=\"CAMERA_CAPTURE_INTERVAL\",\n        ),\n    ] = 10,\n    charuco_rows: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of rows on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_ROWS\",\n        ),\n    ] = 8,\n    charuco_cols: Annotated[\n        int,\n        typer.Option(\n            help=\"Number of columns on the Charuco board\",\n            envvar=\"CAMERA_CHARUCO_COLS\",\n        ),\n    ] = 13,\n    charuco_marker_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of an Aruco marker on the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_MARKER_LENGTH\",\n        ),\n    ] = 23,\n    charuco_square_length: Annotated[\n        int,\n        typer.Option(\n            help=\"Length of a square in the Charuco board (in mm)\",\n            envvar=\"CAMERA_CHARUCO_SQUARE_LENGTH\",\n        ),\n    ] = 30,\n    charuco_legacy: Annotated[\n        bool,\n        typer.Option(\n            help=\"Use Charuco boards compatible with OpenCV &lt; 4.6\",\n            envvar=\"CAMERA_CHARUCO_LEGACY\",\n        ),\n    ] = False,\n):\n    \"\"\"Capture images to be used by the 'calibrate' command\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n    captures_frames: list[cv2.typing.MatLike] = []  # Captured frames\n    capture_path = Path(__file__).parent  # Directory to store captured frames\n    capture_path /= f\"cameras/{id}/{camera_name.name}_{camera_codec.name}_{camera_width}x{camera_height}/images\"\n    charuco_window_name = \"Charuco Board\"\n    preview_window_name = \"Detection Preview - Press Esc to exit\"\n\n    cv2.namedWindow(charuco_window_name, cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n    cv2.namedWindow(preview_window_name, cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n\n    if not Path(camera_name.val).exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_100)\n    board = cv2.aruco.CharucoBoard(\n        (charuco_rows, charuco_cols),\n        charuco_square_length,\n        charuco_marker_length,\n        aruco_dict,\n    )\n    if charuco_legacy:\n        board.setLegacyPattern(True)\n    board_image = board.generateImage((charuco_rows * charuco_square_length, charuco_cols * charuco_square_length))\n    cv2.imshow(charuco_window_name, board_image)\n\n    cap = cv2.VideoCapture(str(camera_name.val), cv2.CAP_V4L2)\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec.val)\n    ret = cap.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec.val} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {camera_width} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {camera_height} not supported\")\n\n    i = capture_interval\n    while True:\n        _, frame = cap.read()\n\n        board_detector = cv2.aruco.CharucoDetector(board)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n        elif i == 0:\n            i = capture_interval\n            captures_frames.append(frame)\n            logger.info(f\"Frame captured: {len(captures_frames)}\")\n            if len(captures_frames) == max_frames:\n                break\n        i -= 1\n\n        detected_frame = frame.copy()\n        _, _, marker_corners, marker_ids = board_detector.detectBoard(frame)\n        cv2.aruco.drawDetectedMarkers(detected_frame, marker_corners, marker_ids)\n\n        cv2.imshow(preview_window_name, detected_frame)\n\n    logger.info(f\"Writing captured frames in: {capture_path}\")\n    shutil.rmtree(capture_path, ignore_errors=True)\n    capture_path.mkdir(parents=True, exist_ok=True)\n    for n, frame in enumerate(captures_frames):\n        filename = capture_path / f\"image_{n:03}.jpg\"\n        cv2.imwrite(str(filename), frame)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/","title":"detect","text":""},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.cmd_detect","title":"<code>cmd_detect(id=1, camera_name=CameraName.hbv.name, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480, robot_position=None)</code>","text":"<p>Detect Aruco tags and estimate their positions</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def cmd_detect(\n    id: Annotated[\n        int,\n        typer.Option(\n            \"-i\",\n            \"--id\",\n            min=0,\n            help=\"Robot ID.\",\n            envvar=[\"ROBOT_ID\", \"CAMERA_ID\"],\n        ),\n    ] = 1,\n    camera_name: Annotated[\n        CameraName,\n        typer.Option(\n            help=\"Name of the camera\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = CameraName.hbv.name,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n    robot_position: Annotated[\n        Optional[int],  # noqa\n        typer.Option(\n            help=\"Define the robot position\",\n            envvar=\"CAMERA_ROBOT_POSITION\",\n            min=1,\n            max=6,\n        ),\n    ] = None,\n):\n    \"\"\"Detect Aruco tags and estimate their positions\"\"\"\n    exit_key = 27  # use this key (Esc) to exit before max_frames\n\n    if not camera_name.val.exists():\n        logger.error(f\"Camera not found: {camera_name.val}\")\n        return\n\n    # Load intrinsic parameters (mandatory)\n    intrinsic_params_filename = get_camera_intrinsic_params_filename(\n        id, camera_name, camera_codec, camera_width, camera_height\n    )\n\n    if not intrinsic_params_filename.exists():\n        logger.error(f\"Intrinsic parameters file not found: {intrinsic_params_filename}\")\n        return\n\n    camera_matrix, dist_coefs = load_camera_intrinsic_params(intrinsic_params_filename)\n\n    # Load extrinsic parameters (optional)\n    extrinsic_params_filename = get_camera_extrinsic_params_filename(\n        id, camera_name, camera_codec, camera_width, camera_height\n    )\n\n    if not extrinsic_params_filename.exists():\n        logger.warning(f\"Extrinsic parameters file not found: {extrinsic_params_filename}\")\n        return\n\n    extrinsic_params = load_camera_extrinsic_params(extrinsic_params_filename)\n\n    aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n    parameters = cv2.aruco.DetectorParameters()\n    detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)\n\n    cap = cv2.VideoCapture(str(camera_name.val), apiPreference=cv2.CAP_V4L2)\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec.val)\n    ret = cap.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec.val} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_WIDTH, camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {camera_width} not supported\")\n\n    ret = cap.set(cv2.CAP_PROP_FRAME_HEIGHT, camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {camera_height} not supported\")\n\n    cv2.namedWindow(\"Marker Detection\", cv2.WINDOW_NORMAL | cv2.WINDOW_GUI_EXPANDED)\n\n    while True:\n        _, frame = cap.read()\n\n        dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n        # Detect marker corners\n        marker_corners, marker_ids, _ = detector.detectMarkers(dst)\n\n        # Draw detected markers\n        cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n        # Classify detected markers by id and size\n        corners_by_id = {}\n        corners_by_size = {}\n        if marker_ids is not None:\n            for id, corners in zip(marker_ids, marker_corners):\n                size = marker_sizes.get(id[0])\n                if not size:\n                    continue\n                if id[0] not in corners_by_id:\n                    corners_by_id[id[0]] = []\n                corners_by_id[id[0]].append(corners)\n                if size not in corners_by_size:\n                    corners_by_size[size] = []\n                corners_by_size[size].append((id[0], corners))\n\n        # Handle table markers\n        table_markers = {\n            id: corners[0]  # There can be only one marker of each id\n            for id, corners in corners_by_id.items()\n            if id in [20, 21, 22, 23]\n        }\n        handle_table_markers(\n            table_markers,\n            camera_matrix,\n            dist_coefs,\n            get_robot_position(robot_position),\n        )\n\n        # Handle solar panel markers\n        solar_panel_markers = []\n        if 47 in corners_by_id:\n            solar_panel_markers = corners_by_id[47]\n        get_solar_panel_positions(\n            solar_panel_markers,\n            camera_matrix,\n            dist_coefs,\n            extrinsic_params,\n            get_robot_position(robot_position),\n        )\n\n        if marker_ids is not None:\n            # Draw all markers borders\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Draw all markers axes\n            for id, corner in zip(marker_ids, marker_corners):\n                marker_id = id[0]\n                if marker_id not in marker_sizes:\n                    logger.warning(f\"Unknown marker found: {marker_id}\")\n                    continue\n\n                _, rvec, tvec = cv2.solvePnP(\n                    get_marker_points(marker_sizes[marker_id]),\n                    corner,\n                    camera_matrix,\n                    dist_coefs,\n                    False,\n                    cv2.SOLVEPNP_IPPE_SQUARE,\n                )\n                cv2.drawFrameAxes(frame, camera_matrix, dist_coefs, rvec, tvec, 50)\n\n        cv2.imshow(\"Marker Detection\", frame)\n\n        k = cv2.waitKey(1)\n        if k == exit_key:\n            break\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_camera_position_on_table","title":"<code>get_camera_position_on_table(table_markers, camera_matrix, dist_coefs)</code>","text":"<p>Return a 3D NDArray of camera position and its rotation in radians in the table coordinate system.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_camera_position_on_table(\n    table_markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n) -&gt; tuple[ArrayLike, float]:\n    \"\"\"\n    Return a 3D NDArray of camera position and its rotation in radians\n    in the table coordinate system.\n    \"\"\"\n    tvecs = {}\n    rvecs = {}\n    distances = {}\n\n    for id, corners in table_markers.items():\n        # Get marker coordinates in the camera coordinate system\n        _, rvec, tvec = cv2.solvePnP(\n            get_marker_points(marker_sizes[id]),\n            corners,\n            camera_matrix,\n            dist_coefs,\n            False,\n            cv2.SOLVEPNP_IPPE_SQUARE,\n        )\n\n        # Distance from the camera to the marker\n        distance = np.sqrt(tvec[0] ** 2 + tvec[1] ** 2 + tvec[2] ** 2)\n\n        # Keep the nearest marker for each id\n        if id not in distances or distances[id] &gt; distance:\n            distances[id] = distance\n            tvecs[id] = tvec\n            rvecs[id] = rvec\n\n    # Get nearest marker: sort by value (distance) in ascending order, and take first element key (id)\n    marker_id, _ = sorted(distances.items(), key=lambda x: x[1])[0]\n    marker_tvec = tvecs[marker_id][:, 0]\n    marker_rvec = rvecs[marker_id][:, 0]\n    marker_rvec_degrees = np.rad2deg(marker_rvec)\n\n    logger.info(\n        f\"- Table marker {marker_id} position relative to camera coordinate system: \"\n        f\"X={marker_tvec[0]:.0f} \"\n        f\"Y={marker_tvec[1]:.0f} \"\n        f\"Z={marker_tvec[2]:.0f} \"\n        f\"roll={marker_rvec_degrees[0]:.0f} \"\n        f\"pitch={marker_rvec_degrees[1]:.0f} \"\n        f\"yaw={marker_rvec_degrees[2]:.0f}\"\n    )\n\n    # Get camera coordinates relative to the marker in the marker axes\n    R_ct = np.matrix(cv2.Rodrigues(marker_rvec)[0])\n    R_tc = R_ct.T\n    camera_tvec = -R_tc * np.matrix(marker_tvec).T  # 2D matrix: [[x], [y], [z]]\n    camera_tvec = np.asarray(camera_tvec).flatten()  # 1D array: [x, y, z]\n    camera_rvec = rotation_matrix_to_euler_angles(R_flip * R_tc)  # 1D array: [roll, pitch, yaw]\n    camera_rvec_degrees = np.rad2deg(camera_rvec)\n\n    logger.info(\n        \"- Camera position relative to the marker in the marker axes: \"\n        f\"X={camera_tvec[0]:.0f} \"\n        f\"Y={camera_tvec[1]:.0f} \"\n        f\"Z={camera_tvec[2]:.0f} \"\n        f\"Angle={camera_rvec_degrees[2]:.0f}\"\n    )\n\n    # Get camera position relative to the marker in the table axes\n    camera_tvec, camera_angle = marker_to_table_axes(camera_tvec, camera_rvec[2])\n    camera_angle_degrees = np.degrees(camera_angle)\n    logger.info(\n        \"- Camera position relative to the marker in the table axes: \"\n        f\"X={camera_tvec[0]:.0f} \"\n        f\"Y={camera_tvec[1]:.0f} \"\n        f\"Z={camera_tvec[2]:.0f} \"\n        f\"Angle={camera_angle_degrees:.0f}\"\n    )\n\n    # Get camera position in the table coordinate system\n    table_camera_tvec = camera_tvec + table_markers_tvecs[marker_id]\n\n    logger.info(\n        \"- Camera position in table coordinate system: \"\n        f\"X={table_camera_tvec[0]:.0f} \"\n        f\"Y={table_camera_tvec[1]:.0f} \"\n        f\"Z={table_camera_tvec[2]:.0f} \"\n        f\"Angle={camera_angle_degrees:.0f}\"\n    )\n\n    return (table_camera_tvec, camera_angle)\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_marker_points","title":"<code>get_marker_points(marker_size)</code>  <code>cached</code>","text":"<p>Get marker points matrix based on marker size, as used by cv2.solvePnP</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>@lru_cache\ndef get_marker_points(marker_size: float):\n    \"\"\"Get marker points matrix based on marker size, as used by cv2.solvePnP\"\"\"\n    return np.array(\n        [\n            [-marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, marker_size / 2, 0],\n            [marker_size / 2, -marker_size / 2, 0],\n            [-marker_size / 2, -marker_size / 2, 0],\n        ],\n        dtype=np.float32,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_robot_position","title":"<code>get_robot_position(n)</code>","text":"<p>Define the possible start positions.</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_robot_position(n: int) -&gt; Pose | None:\n    \"\"\"\n    Define the possible start positions.\n    \"\"\"\n    match n:\n        case 1:  # Back left (blue)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 2:  # Front left (blue)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=1500 - 450 + robot_width / 2,\n                O=-90,\n            )\n        case 3:  # Middle right (blue)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 4:  # Back right (yellow)\n            return Pose(\n                x=1000 - 450 + robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 5:  # Front right (yellow)\n            return Pose(\n                x=-(1000 - 450 + robot_width / 2),\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n        case 6:  # Middle left (yellow)\n            return Pose(\n                x=robot_width / 2,\n                y=-(1500 - 450 + robot_width / 2),\n                O=90,\n            )\n\n    logger.error(\"Unknown robot position: {n}\")\n\n    return None\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.get_solar_panel_positions","title":"<code>get_solar_panel_positions(markers, camera_matrix, dist_coefs, extrinsic_params, robot_position)</code>","text":"<p>Compute position of solar panels relative to the table coordinate system</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def get_solar_panel_positions(\n    markers: list[list[ArrayLike]],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n    extrinsic_params: CameraExtrinsicParameters,\n    robot_position: Pose | None,\n) -&gt; dict[int, float]:\n    \"\"\"\n    Compute position of solar panels relative to the table coordinate system\n    \"\"\"\n    panels: dict[int, float] = {}\n\n    if len(markers) == 0:\n        logger.debug(\"No solar panel marker found.\")\n        return panels\n\n    for i, corners in enumerate(markers):\n        # Get marker coordinates in the camera coordinate system\n        _, rvec, tvec = cv2.solvePnP(\n            get_marker_points(marker_sizes[47]),\n            corners,\n            camera_matrix,\n            dist_coefs,\n            False,\n            cv2.SOLVEPNP_IPPE_SQUARE,\n        )\n        marker_tvec = tvec[:, 0]\n        marker_rvec = rvec[:, 0]\n        marker_rvec_degrees = np.rad2deg(marker_rvec)\n        logger.info(f\"Solar panel marker {i}:\")\n        logger.info(\n            f\"- Position relative to camera coordinate system: \"\n            f\"X={marker_tvec[0]:.0f} \"\n            f\"Y={marker_tvec[1]:.0f} \"\n            f\"Z={marker_tvec[2]:.0f} \"\n            f\"roll={marker_rvec_degrees[0]:.0f} \"\n            f\"pitch={marker_rvec_degrees[1]:.0f} \"\n            f\"yaw={marker_rvec_degrees[2]:.0f}\"\n        )\n\n        # Get camera coordinates relative to the marker in the marker axes\n        R_ct = np.matrix(cv2.Rodrigues(marker_rvec)[0])\n        R_tc = R_ct.T\n        marker_camera_tvec = -R_tc * np.matrix(marker_tvec).T  # 2D matrix: [[x], [y], [z]]\n        marker_camera_tvec = np.asarray(marker_camera_tvec).flatten()  # 1D array: [x, y, z]\n        marker_camera_rvec = rotation_matrix_to_euler_angles(R_flip * R_tc)  # 1D array: [roll, pitch, yaw]\n\n        # Use same axes as the table\n        marker_camera_tvec[0], marker_camera_tvec[1] = marker_camera_tvec[1], marker_camera_tvec[0]\n        marker_camera_rvec[2] = -marker_camera_rvec[2]\n\n        marker_camera_rvec_degrees = np.rad2deg(marker_camera_rvec)\n\n        logger.info(\n            \"- Camera position relative to the marker in the marker axes: \"\n            f\"X={marker_camera_tvec[0]:.0f} \"\n            f\"Y={marker_camera_tvec[1]:.0f} \"\n            f\"Z={marker_camera_tvec[2]:.0f} \"\n            f\"roll={marker_camera_rvec_degrees[0]:.0f} \"\n            f\"pitch={marker_camera_rvec_degrees[1]:.0f} \"\n            f\"yaw={marker_camera_rvec_degrees[2]:.0f}\"\n        )\n\n        # Compute marker position relative to the camera in the robot axes\n        hypot = np.hypot(marker_tvec[1], marker_tvec[2])\n\n        angle_marker = np.arcsin(marker_tvec[1] / hypot)\n        angle_camera = np.pi / 2 - marker_camera_rvec[0] + angle_marker\n\n        dist_camera_to_marker_tvec = np.array(\n            [\n                hypot * np.cos(angle_camera),\n                -marker_tvec[0],\n                hypot * np.sin(angle_camera),\n            ]\n        )\n        logger.info(\n            \"- Marker position relative to the camera in the robot axes: \"\n            f\"X={dist_camera_to_marker_tvec[0]:.0f} \"\n            f\"Y={dist_camera_to_marker_tvec[1]:.0f} \"\n            f\"Z={dist_camera_to_marker_tvec[2]:.0f}\"\n        )\n\n        # Compute marker position relative to the robot in the robot axes\n        dist_robot_to_marker_tvec = np.array(\n            [\n                dist_camera_to_marker_tvec[0] - extrinsic_params.x,\n                dist_camera_to_marker_tvec[1] - extrinsic_params.y,\n                extrinsic_params.z - dist_camera_to_marker_tvec[2],\n            ]\n        )\n        logger.info(\n            \"- Marker position relative to the robot in the robot axes: \"\n            f\"X={dist_robot_to_marker_tvec[0]:.0f} \"\n            f\"Y={dist_robot_to_marker_tvec[1]:.0f} \"\n            f\"Z={dist_robot_to_marker_tvec[2]:.0f}\"\n        )\n\n        if robot_position:\n            # Compute solar panel angle in the table coordinate system\n            panel_angle = wrap_to_pi(np.deg2rad(robot_position.O) - marker_camera_rvec[2])\n            panel_angle_degrees = np.rad2deg(panel_angle)\n            logger.info(f\"- Angle in table the axes : {panel_angle_degrees:.0f} ({marker_camera_rvec[2]})\")\n\n            # Compute solar panel marker position  in the table coordinate system\n            table_robot_rotated = rotate_2d(\n                np.array([robot_position.x, robot_position.y]), -np.deg2rad(robot_position.O)\n            )\n            table_marker_rotated = table_robot_rotated + dist_robot_to_marker_tvec[0:2]\n            table_marker_xy = rotate_2d(table_marker_rotated, np.deg2rad(robot_position.O))\n            table_marker_tvec = np.array([table_marker_xy[0], table_marker_xy[1], dist_robot_to_marker_tvec[2]])\n\n            logger.info(\n                \"- Marker position relative in the table coordinates: \"\n                f\"X={table_marker_tvec[0]:.0f} \"\n                f\"Y={table_marker_tvec[1]:.0f} \"\n                f\"Z={table_marker_tvec[2]:.0f}\"\n            )\n\n            # Find solar panel id\n            for n, panel_tvec in solar_panels_tvecs.items():\n                # Solar panel are separated by a minimum of 250 mm.\n                # Considering the precision of the detection, a solar panel detected less than 60 mm around\n                # its theoretical position is enough to identify a specific solar panel.\n                maximum_detection_distance = 60\n                if np.linalg.norm(panel_tvec - table_marker_tvec) &lt; maximum_detection_distance:\n                    panels[n] = panel_angle_degrees\n                    break\n\n    return panels\n</code></pre>"},{"location":"reference/cogip/tools/camera/detect/#cogip.tools.camera.detect.handle_table_markers","title":"<code>handle_table_markers(markers, camera_matrix, dist_coefs, robot_position)</code>","text":"<p>Compute camera position on table and camera position in robot if robot position is given</p> Source code in <code>cogip/tools/camera/detect.py</code> <pre><code>def handle_table_markers(\n    markers: dict[int, MatLike],\n    camera_matrix: MatLike,\n    dist_coefs: MatLike,\n    robot_position: Vertex | None,\n):\n    \"\"\"Compute camera position on table and camera position in robot if robot position is given\"\"\"\n    if len(markers) == 0:\n        logger.debug(\"No table marker found, skip robot positioning.\")\n        return\n\n    # Compute camera position on table\n    table_camera_tvec, table_camera_angle = get_camera_position_on_table(\n        markers,\n        camera_matrix,\n        dist_coefs,\n    )\n\n    # Compute camera position in robot if robot position is given\n    if robot_position:\n        get_camera_position_in_robot(\n            robot_position,\n            table_camera_tvec,\n            table_camera_angle,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/camera/info/","title":"info","text":""},{"location":"reference/cogip/tools/camera/info/#cogip.tools.camera.info.cmd_info","title":"<code>cmd_info(ctx, camera_name=None, camera_codec=VideoCodec.yuyv.name, camera_width=640, camera_height=480)</code>","text":"<p>Get properties of connected cameras</p> Source code in <code>cogip/tools/camera/info.py</code> <pre><code>def cmd_info(\n    ctx: typer.Context,\n    camera_name: Annotated[\n        Optional[CameraName],  # noqa\n        typer.Option(\n            help=\"Name of the camera (all if not specified)\",\n            envvar=\"CAMERA_NAME\",\n        ),\n    ] = None,\n    camera_codec: Annotated[\n        VideoCodec,\n        typer.Option(\n            help=\"Camera video codec\",\n            envvar=\"CAMERA_CODEC\",\n        ),\n    ] = VideoCodec.yuyv.name,\n    camera_width: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame width\",\n            envvar=\"CAMERA_WIDTH\",\n        ),\n    ] = 640,\n    camera_height: Annotated[\n        int,\n        typer.Option(\n            help=\"Camera frame height\",\n            envvar=\"CAMERA_HEIGHT\",\n        ),\n    ] = 480,\n):\n    \"\"\"Get properties of connected cameras\"\"\"\n    obj = ctx.ensure_object(dict)\n    debug = obj.get(\"debug\", False)\n\n    if debug:\n        v4l2py.device.log.setLevel(logging.DEBUG)\n    else:\n        v4l2py.device.log.setLevel(logging.INFO)\n\n    if camera_name:\n        if not Path(camera_name.val).exists():\n            logger.error(f\"Camera not found: {camera_name}\")\n            return\n        device = v4l2py.Device(camera_name.val)\n        try:\n            device.open()\n        except OSError:\n            logger.error(f\"Failed to open {camera_name.val}\")\n            return\n        print_device_info(device)\n        device.close()\n        show_stream(camera_name, camera_codec, camera_width, camera_height)\n        return\n\n    for device in v4l2py.iter_video_capture_devices():\n        try:\n            device.open()\n        except OSError:\n            pass\n        else:\n            print_device_info(device)\n            device.close()\n            print()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/","title":"utils","text":""},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.get_camera_extrinsic_params_filename","title":"<code>get_camera_extrinsic_params_filename(robot_id, name, codec, width, height)</code>","text":"<p>Get parameters filename based on current package path and camera parameters</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def get_camera_extrinsic_params_filename(\n    robot_id: int,\n    name: CameraName,\n    codec: VideoCodec,\n    width: int,\n    height: int,\n) -&gt; Path:\n    \"\"\"Get parameters filename based on current package path and camera parameters\"\"\"\n    params_filename = Path(__file__).parent\n    params_filename /= f\"cameras/{robot_id}/{name.name}_{codec.name}_{width}x{height}/extrinsic_params.json\"\n    return params_filename\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.get_camera_intrinsic_params_filename","title":"<code>get_camera_intrinsic_params_filename(robot_id, name, codec, width, height)</code>","text":"<p>Get parameters filename based on current package path and camera parameters</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def get_camera_intrinsic_params_filename(\n    robot_id: int,\n    name: CameraName,\n    codec: VideoCodec,\n    width: int,\n    height: int,\n) -&gt; Path:\n    \"\"\"Get parameters filename based on current package path and camera parameters\"\"\"\n    params_filename = Path(__file__).parent\n    params_filename /= f\"cameras/{robot_id}/{name.name}_{codec.name}_{width}x{height}/intrinsic_params.yaml\"\n    return params_filename\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.is_rotation_matrix","title":"<code>is_rotation_matrix(R)</code>","text":"<p>Checks if a matrix is a valid rotation matrix</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def is_rotation_matrix(R):\n    \"\"\"\n    Checks if a matrix is a valid rotation matrix\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    Rt = np.transpose(R)\n    shouldBeIdentity = np.dot(Rt, R)\n    ident = np.identity(3, dtype=R.dtype)\n    n = np.linalg.norm(ident - shouldBeIdentity)\n    return n &lt; 1e-6\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_extrinsic_params","title":"<code>load_camera_extrinsic_params(path)</code>","text":"<p>Loads camera position relative to robot center.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_extrinsic_params(path: Path) -&gt; CameraExtrinsicParameters:\n    \"\"\"Loads camera position relative to robot center.\"\"\"\n    return CameraExtrinsicParameters.model_validate_json(path.read_text())\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.load_camera_intrinsic_params","title":"<code>load_camera_intrinsic_params(path)</code>","text":"<p>Loads camera matrix and distortion coefficients.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def load_camera_intrinsic_params(path: Path) -&gt; tuple[cv2.typing.MatLike, cv2.typing.MatLike]:\n    \"\"\"Loads camera matrix and distortion coefficients.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_READ)\n    camera_matrix = cv_file.getNode(\"K\").mat()\n    dist_coefs = cv_file.getNode(\"D\").mat()\n    cv_file.release()\n    return [camera_matrix, dist_coefs]\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.rotate_2d","title":"<code>rotate_2d(vector, angle)</code>","text":"<p>Rotate a 2D point with specify angle</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def rotate_2d(vector: cv2.typing.MatLike, angle: float) -&gt; cv2.typing.MatLike:\n    \"\"\"Rotate a 2D point with specify angle\"\"\"\n    rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n    vector = vector.reshape(1, 2)\n    vector = vector.T\n    rotated: cv2.typing.MatLike = (rotation_matrix @ vector).T\n    return rotated.squeeze()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.rotation_matrix_to_euler_angles","title":"<code>rotation_matrix_to_euler_angles(R)</code>","text":"<p>Calculates rotation matrix to euler angles. The result is the same as MATLAB except the order of the euler angles (x and z are swapped).</p> <p>Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def rotation_matrix_to_euler_angles(R):\n    \"\"\"\n    Calculates rotation matrix to euler angles.\n    The result is the same as MATLAB except the order\n    of the euler angles (x and z are swapped).\n\n    Source: https://www.learnopencv.com/rotation-matrix-to-euler-angles/\n    \"\"\"\n    assert is_rotation_matrix(R)\n\n    sy = np.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])\n\n    singular = sy &lt; 1e-6\n\n    if not singular:\n        x = np.arctan2(R[2, 1], R[2, 2])\n        y = np.arctan2(-R[2, 0], sy)\n        z = np.arctan2(R[1, 0], R[0, 0])\n    else:\n        x = np.arctan2(-R[1, 2], R[1, 1])\n        y = np.arctan2(-R[2, 0], sy)\n        z = 0\n\n    return np.array([x, y, z])\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_extrinsic_params","title":"<code>save_camera_extrinsic_params(params, path)</code>","text":"<p>Save the camera position relative to robot center to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_extrinsic_params(params: CameraExtrinsicParameters, path: Path):\n    \"\"\"Save the camera position relative to robot center to given path/file.\"\"\"\n    path.write_text(CameraExtrinsicParameters.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.save_camera_intrinsic_params","title":"<code>save_camera_intrinsic_params(camera_matrix, dist_coefs, path)</code>","text":"<p>Save the camera matrix and the distortion coefficients to given path/file.</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def save_camera_intrinsic_params(camera_matrix: cv2.typing.MatLike, dist_coefs: cv2.typing.MatLike, path: Path):\n    \"\"\"Save the camera matrix and the distortion coefficients to given path/file.\"\"\"\n    cv_file = cv2.FileStorage(str(path), cv2.FILE_STORAGE_WRITE)\n    cv_file.write(\"K\", camera_matrix)\n    cv_file.write(\"D\", dist_coefs)\n    cv_file.release()\n</code></pre>"},{"location":"reference/cogip/tools/camera/utils/#cogip.tools.camera.utils.wrap_to_pi","title":"<code>wrap_to_pi(angle)</code>","text":"<p>Wrap angle to PI, return a angle value between <code>-PI</code> and <code>PI</code></p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Angle in radians</p> required <p>Returns:</p> Type Description <code>float</code> <p>Wrapped angle, in radians</p> Source code in <code>cogip/tools/camera/utils.py</code> <pre><code>def wrap_to_pi(angle: float) -&gt; float:\n    \"\"\"Wrap angle to PI, return a angle value between `-PI` and `PI`\n\n    Arguments:\n        angle: Angle in radians\n\n    Returns:\n        Wrapped angle, in radians\n    \"\"\"\n    return np.arctan2(np.sin(angle), np.cos(angle))\n</code></pre>"},{"location":"reference/cogip/tools/cansend/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cansend/__main__/#cogip.tools.cansend.__main__.main","title":"<code>main()</code>","text":"<p>Run cansend utility.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-cansend</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/cansend/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Run cansend utility.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-cansend` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/copilot/__main__/#cogip.tools.copilot.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-copilot</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/copilot/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-copilot` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/controller/","title":"controller","text":""},{"location":"reference/cogip/tools/copilot/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot","title":"<code>Copilot</code>","text":"<p>Main copilot class.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>class Copilot:\n    \"\"\"\n    Main copilot class.\n    \"\"\"\n\n    loop: asyncio.AbstractEventLoop = None  # Event loop to use for all coroutines\n\n    def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            id: robot id\n            can_channel: CAN channel connected to STM32 device\n            can_bitrate: CAN bitrate\n            canfd_data_bitrate: CAN data bitrate\n        \"\"\"\n        self.server_url = server_url\n        self.id = id\n        self.retry_connection = True\n        self.shell_menu: models.ShellMenu | None = None\n        self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n        pb_message_handlers = {\n            reset_uuid: self.handle_reset,\n            menu_uuid: self.handle_message_menu,\n            pose_order_uuid: self.handle_message_pose,\n            state_uuid: self.handle_message_state,\n            pose_reached_uuid: self.handle_pose_reached,\n            actuator_state_uuid: self.handle_actuator_state,\n            pid_uuid: self.handle_pid,\n        }\n\n        self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n\n    async def run(self):\n        \"\"\"\n        Start copilot.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n\n        self.retry_connection = True\n        await self.try_connect()\n\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n        await self.pbcom.run()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    async def handle_reset(self) -&gt; None:\n        \"\"\"\n        Handle reset message. This means that the robot has just booted.\n\n        Send a reset message to all connected clients.\n        \"\"\"\n        await self.pbcom.send_can_message(copilot_connected_uuid, None)\n        await self.sio_events.emit(\"reset\")\n\n    @pb_exception_handler\n    async def handle_message_menu(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send shell menu received from the robot to connected monitors.\n        \"\"\"\n        pb_menu = PB_Menu()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_menu.ParseFromString, message)\n\n        menu = MessageToDict(pb_menu)\n        self.shell_menu = models.ShellMenu.model_validate(menu)\n        if self.sio.connected:\n            await self.sio_events.emit(\"menu\", self.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n\n    @pb_exception_handler\n    async def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot pose received from the robot to connected monitors and detector.\n        \"\"\"\n        pb_pose = PB_Pose()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n        pose = MessageToDict(\n            pb_pose,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio.connected:\n            await self.sio_events.emit(\"pose\", pose)\n\n    @pb_exception_handler\n    async def handle_message_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot state received from the robot to connected monitors.\n        \"\"\"\n        pb_state = PB_State()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n        state = MessageToDict(\n            pb_state,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio.connected:\n            await self.sio_events.emit(\"state\", state)\n\n    @pb_exception_handler\n    async def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send actuator state received from the robot.\n        \"\"\"\n        pb_actuator_state = PB_ActuatorState()\n\n        if message:\n            await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n        kind = pb_actuator_state.WhichOneof(\"type\")\n        actuator_state = MessageToDict(\n            getattr(pb_actuator_state, kind),\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n        if self.sio.connected:\n            await self.sio_events.emit(\"actuator_state\", actuator_state)\n\n    @pb_exception_handler\n    async def handle_pid(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send pids state received from the robot to connected dashboards.\n        \"\"\"\n        pb_pid = PB_Pid()\n        if message:\n            await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n        self.pb_pids[pb_pid.id] = pb_pid\n        pid = Pid(\n            id=pb_pid.id,\n            kp=pb_pid.kp,\n            ki=pb_pid.ki,\n            kd=pb_pid.kd,\n            integral_term_limit=pb_pid.integral_term_limit,\n        )\n\n        # Get JSON Schema\n        pid_schema = pid.model_json_schema()\n        # Add namespace in JSON Schema\n        pid_schema[\"namespace\"] = \"/copilot\"\n        # Add current values in JSON Schema\n        pid_schema[\"title\"] = pid.id.name\n        for prop, value in pid.model_dump().items():\n            if prop == \"id\":\n                continue\n            pid_schema[\"properties\"][prop][\"value\"] = value\n            pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n            del pid_schema[\"properties\"][prop]\n        # Send config\n        await self.sio_events.emit(\"config\", pid_schema)\n\n    async def handle_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        if self.sio.connected:\n            await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.__init__","title":"<code>__init__(server_url, id, can_channel, can_bitrate, canfd_data_bitrate)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>id</code> <code>int</code> <p>robot id</p> required <code>can_channel</code> <code>str</code> <p>CAN channel connected to STM32 device</p> required <code>can_bitrate</code> <code>int</code> <p>CAN bitrate</p> required <code>canfd_data_bitrate</code> <code>int</code> <p>CAN data bitrate</p> required Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>def __init__(self, server_url: str, id: int, can_channel: str, can_bitrate: int, canfd_data_bitrate: int):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        id: robot id\n        can_channel: CAN channel connected to STM32 device\n        can_bitrate: CAN bitrate\n        canfd_data_bitrate: CAN data bitrate\n    \"\"\"\n    self.server_url = server_url\n    self.id = id\n    self.retry_connection = True\n    self.shell_menu: models.ShellMenu | None = None\n    self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n\n    pb_message_handlers = {\n        reset_uuid: self.handle_reset,\n        menu_uuid: self.handle_message_menu,\n        pose_order_uuid: self.handle_message_pose,\n        state_uuid: self.handle_message_state,\n        pose_reached_uuid: self.handle_pose_reached,\n        actuator_state_uuid: self.handle_actuator_state,\n        pid_uuid: self.handle_pid,\n    }\n\n    self.pbcom = PBCom(can_channel, can_bitrate, canfd_data_bitrate, pb_message_handlers)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_actuator_state","title":"<code>handle_actuator_state(message=None)</code>  <code>async</code>","text":"<p>Send actuator state received from the robot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send actuator state received from the robot.\n    \"\"\"\n    pb_actuator_state = PB_ActuatorState()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n    kind = pb_actuator_state.WhichOneof(\"type\")\n    actuator_state = MessageToDict(\n        getattr(pb_actuator_state, kind),\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n    if self.sio.connected:\n        await self.sio_events.emit(\"actuator_state\", actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_menu","title":"<code>handle_message_menu(message=None)</code>  <code>async</code>","text":"<p>Send shell menu received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_menu(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send shell menu received from the robot to connected monitors.\n    \"\"\"\n    pb_menu = PB_Menu()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_menu.ParseFromString, message)\n\n    menu = MessageToDict(pb_menu)\n    self.shell_menu = models.ShellMenu.model_validate(menu)\n    if self.sio.connected:\n        await self.sio_events.emit(\"menu\", self.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_pose","title":"<code>handle_message_pose(message=None)</code>  <code>async</code>","text":"<p>Send robot pose received from the robot to connected monitors and detector.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot pose received from the robot to connected monitors and detector.\n    \"\"\"\n    pb_pose = PB_Pose()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n    pose = MessageToDict(\n        pb_pose,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio.connected:\n        await self.sio_events.emit(\"pose\", pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_message_state","title":"<code>handle_message_state(message=None)</code>  <code>async</code>","text":"<p>Send robot state received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot state received from the robot to connected monitors.\n    \"\"\"\n    pb_state = PB_State()\n\n    if message:\n        await self.loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n    state = MessageToDict(\n        pb_state,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio.connected:\n        await self.sio_events.emit(\"state\", state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pid","title":"<code>handle_pid(message=None)</code>  <code>async</code>","text":"<p>Send pids state received from the robot to connected dashboards.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_pid(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send pids state received from the robot to connected dashboards.\n    \"\"\"\n    pb_pid = PB_Pid()\n    if message:\n        await self.loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n    self.pb_pids[pb_pid.id] = pb_pid\n    pid = Pid(\n        id=pb_pid.id,\n        kp=pb_pid.kp,\n        ki=pb_pid.ki,\n        kd=pb_pid.kd,\n        integral_term_limit=pb_pid.integral_term_limit,\n    )\n\n    # Get JSON Schema\n    pid_schema = pid.model_json_schema()\n    # Add namespace in JSON Schema\n    pid_schema[\"namespace\"] = \"/copilot\"\n    # Add current values in JSON Schema\n    pid_schema[\"title\"] = pid.id.name\n    for prop, value in pid.model_dump().items():\n        if prop == \"id\":\n            continue\n        pid_schema[\"properties\"][prop][\"value\"] = value\n        pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n        del pid_schema[\"properties\"][prop]\n    # Send config\n    await self.sio_events.emit(\"config\", pid_schema)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_pose_reached","title":"<code>handle_pose_reached()</code>  <code>async</code>","text":"<p>Handle pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    if self.sio.connected:\n        await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.handle_reset","title":"<code>handle_reset()</code>  <code>async</code>","text":"<p>Handle reset message. This means that the robot has just booted.</p> <p>Send a reset message to all connected clients.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def handle_reset(self) -&gt; None:\n    \"\"\"\n    Handle reset message. This means that the robot has just booted.\n\n    Send a reset message to all connected clients.\n    \"\"\"\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n    await self.sio_events.emit(\"reset\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start copilot.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start copilot.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n\n    self.retry_connection = True\n    await self.try_connect()\n\n    await self.pbcom.send_can_message(copilot_connected_uuid, None)\n\n    await self.pbcom.run()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/copilot/#cogip.tools.copilot.copilot.Copilot.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/copilot/copilot.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/copilot/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/copilot/pbcom/","title":"pbcom","text":""},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom","title":"<code>PBCom</code>","text":"Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>class PBCom:\n    can_is_fd: bool = True  # CAN frames are FD frames\n\n    def __init__(\n        self,\n        can_channel: str,\n        can_bitrate: int,\n        canfd_data_bitrate: int,\n        message_handlers: dict[int, Callable],\n    ):\n        self.can_bus = can.Bus(\n            interface=\"socketcan\",\n            channel=can_channel,\n            bitrate=can_bitrate,\n            data_bitrate=canfd_data_bitrate,\n            fd=self.can_is_fd,\n        )\n        self.message_handlers = message_handlers\n\n        # Create asyncio queues\n        self.messages_received = asyncio.Queue()  # Queue for messages received\n        self.messages_to_send = asyncio.Queue()  # Queue for messages waiting to be sent\n\n    async def run(self):\n        \"\"\"\n        Start PBCom.\n        \"\"\"\n        self.loop = asyncio.get_running_loop()\n        self.can_reader = can.AsyncBufferedReader()\n        self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n        try:\n            await asyncio.gather(\n                self.payload_decoder(),\n                self.can_receiver(),\n                self.can_sender(),\n            )\n        except asyncio.CancelledError:\n            self.can_bus.shutdown()\n\n    async def payload_decoder(self):\n        \"\"\"\n        Async worker decoding messages received from the robot.\n        \"\"\"\n        uuid: int\n        encoded_payload: bytes\n\n        try:\n            while True:\n                uuid, encoded_payload = await self.messages_received.get()\n                request_handler = self.message_handlers.get(uuid)\n                if not request_handler:\n                    print(f\"No handler found for message uuid '{uuid}'\")\n                else:\n                    if not encoded_payload:\n                        await request_handler()\n                    else:\n                        await request_handler(encoded_payload)\n\n                self.messages_received.task_done()\n        except asyncio.CancelledError:\n            raise\n\n    async def send_can_message(self, *args) -&gt; None:\n        await self.messages_to_send.put(args)\n\n    async def can_receiver(self):\n        \"\"\"\n        Async worker reading messages from the robot on CAN bus.\n\n        Messages is base64-encoded.\n        After decoding, first byte is the message type, following bytes are\n        the Protobuf encoded message (if any).\n        \"\"\"\n        try:\n            while True:\n                # Read next message\n                can_message = await self.can_reader.get_message()\n\n                # Get message uuid on first bytes\n                uuid = can_message.arbitration_id\n\n                if can_message.dlc == 0:\n                    await self.messages_received.put((uuid, None))\n                    continue\n\n                # Base64 decoding\n                try:\n                    pb_message = base64.decodebytes(can_message.data)\n                except binascii.Error:\n                    print(\"Failed to decode base64 message.\")\n                    continue\n\n                # Send Protobuf message for decoding\n                await self.messages_received.put((uuid, pb_message))\n        except asyncio.CancelledError:\n            raise\n\n    async def can_sender(self):\n        \"\"\"\n        Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n        See `can_receiver` for message encoding.\n        \"\"\"\n        try:\n            while True:\n                uuid, pb_message = await self.messages_to_send.get()\n                logger.info(f\"Send 0x{uuid:4x}:\\n{pb_message}\")\n                if pb_message:\n                    response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                    response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n                else:\n                    response_base64 = None\n                try:\n                    self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n                except Exception as e:\n                    logger.error(e)\n                self.messages_to_send.task_done()\n        except asyncio.CancelledError:\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_receiver","title":"<code>can_receiver()</code>  <code>async</code>","text":"<p>Async worker reading messages from the robot on CAN bus.</p> <p>Messages is base64-encoded. After decoding, first byte is the message type, following bytes are the Protobuf encoded message (if any).</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_receiver(self):\n    \"\"\"\n    Async worker reading messages from the robot on CAN bus.\n\n    Messages is base64-encoded.\n    After decoding, first byte is the message type, following bytes are\n    the Protobuf encoded message (if any).\n    \"\"\"\n    try:\n        while True:\n            # Read next message\n            can_message = await self.can_reader.get_message()\n\n            # Get message uuid on first bytes\n            uuid = can_message.arbitration_id\n\n            if can_message.dlc == 0:\n                await self.messages_received.put((uuid, None))\n                continue\n\n            # Base64 decoding\n            try:\n                pb_message = base64.decodebytes(can_message.data)\n            except binascii.Error:\n                print(\"Failed to decode base64 message.\")\n                continue\n\n            # Send Protobuf message for decoding\n            await self.messages_received.put((uuid, pb_message))\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.can_sender","title":"<code>can_sender()</code>  <code>async</code>","text":"<p>Async worker encoding and sending Protobuf messages to the robot on CAN bus.</p> <p>See <code>can_receiver</code> for message encoding.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def can_sender(self):\n    \"\"\"\n    Async worker encoding and sending Protobuf messages to the robot on CAN bus.\n\n    See `can_receiver` for message encoding.\n    \"\"\"\n    try:\n        while True:\n            uuid, pb_message = await self.messages_to_send.get()\n            logger.info(f\"Send 0x{uuid:4x}:\\n{pb_message}\")\n            if pb_message:\n                response_serialized = await self.loop.run_in_executor(None, pb_message.SerializeToString)\n                response_base64 = await self.loop.run_in_executor(None, base64.encodebytes, response_serialized)\n            else:\n                response_base64 = None\n            try:\n                self.can_bus.send(can.Message(arbitration_id=uuid, data=response_base64, is_fd=self.can_is_fd))\n            except Exception as e:\n                logger.error(e)\n            self.messages_to_send.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.payload_decoder","title":"<code>payload_decoder()</code>  <code>async</code>","text":"<p>Async worker decoding messages received from the robot.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def payload_decoder(self):\n    \"\"\"\n    Async worker decoding messages received from the robot.\n    \"\"\"\n    uuid: int\n    encoded_payload: bytes\n\n    try:\n        while True:\n            uuid, encoded_payload = await self.messages_received.get()\n            request_handler = self.message_handlers.get(uuid)\n            if not request_handler:\n                print(f\"No handler found for message uuid '{uuid}'\")\n            else:\n                if not encoded_payload:\n                    await request_handler()\n                else:\n                    await request_handler(encoded_payload)\n\n            self.messages_received.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pbcom/#cogip.tools.copilot.pbcom.PBCom.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start PBCom.</p> Source code in <code>cogip/tools/copilot/pbcom.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start PBCom.\n    \"\"\"\n    self.loop = asyncio.get_running_loop()\n    self.can_reader = can.AsyncBufferedReader()\n    self.notifier = can.Notifier(bus=self.can_bus, listeners=[self.can_reader], timeout=None, loop=self.loop)\n\n    try:\n        await asyncio.gather(\n            self.payload_decoder(),\n            self.can_receiver(),\n            self.can_sender(),\n        )\n    except asyncio.CancelledError:\n        self.can_bus.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/copilot/pid/","title":"pid","text":""},{"location":"reference/cogip/tools/copilot/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, copilot: \"copilot.Copilot\"):\n        super().__init__(\"/copilot\")\n        self.copilot = copilot\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        if self.copilot.shell_menu:\n            await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n        await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_command(self, data):\n        \"\"\"\n        Callback on tool command message.\n        \"\"\"\n        cmd, _, _ = data.partition(\" \")\n        pid_id = PB_Pid_Id()\n        match cmd:\n            case \"angular_speed_pid_config\":\n                # Request angular speed pid state\n                pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_speed_pid_config\":\n                # Request linear_speed pid state\n                pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"angular_position_pid_config\":\n                # Request angular position pid state\n                pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_position_pid_config\":\n                # Request linear position pid state\n                pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n                await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_shell_command(self, data):\n        \"\"\"\n        Callback on shell command message.\n\n        Build the Protobuf command message:\n\n        * split received string at first space if any.\n        * first is the command and goes to `cmd` attribute.\n        * second part is arguments, if any, and goes to `desc` attribute.\n        \"\"\"\n        response = PB_Command()\n        response.cmd, _, response.desc = data.partition(\" \")\n        await self.copilot.pbcom.send_can_message(copilot.command_uuid, response)\n\n    async def on_pose_start(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose start (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        start_pose = models.PathPose.model_validate(data)\n        pb_start_pose = PB_PathPose()\n        start_pose.copy_pb(pb_start_pose)\n        await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n\n    async def on_pose_order(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose order (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        pose_order = models.PathPose.model_validate(data)\n        pb_pose_order = PB_PathPose()\n        pose_order.copy_pb(pb_pose_order)\n        await self.copilot.pbcom.send_can_message(copilot.pose_order_uuid, pb_pose_order)\n\n    async def on_actuators_start(self):\n        \"\"\"\n        Callback on actuators_start (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n\n    async def on_actuators_stop(self):\n        \"\"\"\n        Callback on actuators_stop (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n\n    async def on_actuator_command(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_command (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n        pb_command = PB_ActuatorCommand()\n        if isinstance(command, ServoCommand):\n            command.pb_copy(pb_command.servo)\n        elif isinstance(command, PositionalActuatorCommand):\n            command.pb_copy(pb_command.positional_actuator)\n        await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n\n    async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on config_updated from dashboard.\n        Update pid PB message and send it back to firmware.\n        \"\"\"\n        pid_id, _, name = config[\"name\"].partition(\"-\")\n        if pid_id and name:\n            setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n            await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n\n    async def on_set_controller(self, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to firmware.\n        \"\"\"\n        pb_controller = PB_Controller()\n        pb_controller.id = controller\n        await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n\n    async def on_game_start(self):\n        \"\"\"\n        Callback on game_start message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game_end message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n\n    async def on_game_reset(self):\n        \"\"\"\n        Callback on game_reset message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n\n    async def on_brake(self):\n        \"\"\"\n        Callback on brake message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuator_command","title":"<code>on_actuator_command(data)</code>  <code>async</code>","text":"<p>Callback on actuator_command (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuator_command(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_command (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n    pb_command = PB_ActuatorCommand()\n    if isinstance(command, ServoCommand):\n        command.pb_copy(pb_command.servo)\n    elif isinstance(command, PositionalActuatorCommand):\n        command.pb_copy(pb_command.positional_actuator)\n    await self.copilot.pbcom.send_can_message(copilot.actuator_command_uuid, pb_command)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_start","title":"<code>on_actuators_start()</code>  <code>async</code>","text":"<p>Callback on actuators_start (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_start(self):\n    \"\"\"\n    Callback on actuators_start (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_actuators_stop","title":"<code>on_actuators_stop()</code>  <code>async</code>","text":"<p>Callback on actuators_stop (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_actuators_stop(self):\n    \"\"\"\n    Callback on actuators_stop (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.actuators_thread_stop_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_brake","title":"<code>on_brake()</code>  <code>async</code>","text":"<p>Callback on brake message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_brake(self):\n    \"\"\"\n    Callback on brake message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_command","title":"<code>on_command(data)</code>  <code>async</code>","text":"<p>Callback on tool command message.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_command(self, data):\n    \"\"\"\n    Callback on tool command message.\n    \"\"\"\n    cmd, _, _ = data.partition(\" \")\n    pid_id = PB_Pid_Id()\n    match cmd:\n        case \"angular_speed_pid_config\":\n            # Request angular speed pid state\n            pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_speed_pid_config\":\n            # Request linear_speed pid state\n            pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"angular_position_pid_config\":\n            # Request angular position pid state\n            pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_position_pid_config\":\n            # Request linear position pid state\n            pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n            await self.copilot.pbcom.send_can_message(copilot.pid_request_uuid, pid_id)\n        case _:\n            logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config_updated from dashboard. Update pid PB message and send it back to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on config_updated from dashboard.\n    Update pid PB message and send it back to firmware.\n    \"\"\"\n    pid_id, _, name = config[\"name\"].partition(\"-\")\n    if pid_id and name:\n        setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n        await self.copilot.pbcom.send_can_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    if self.copilot.shell_menu:\n        await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n    await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game_end message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game_end message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.game_end_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_reset","title":"<code>on_game_reset()</code>  <code>async</code>","text":"<p>Callback on game_reset message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_reset(self):\n    \"\"\"\n    Callback on game_reset message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.game_reset_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_game_start","title":"<code>on_game_start()</code>  <code>async</code>","text":"<p>Callback on game_start message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_game_start(self):\n    \"\"\"\n    Callback on game_start message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_can_message(copilot.game_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_pose_order","title":"<code>on_pose_order(data)</code>  <code>async</code>","text":"<p>Callback on pose order (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_pose_order(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose order (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    pose_order = models.PathPose.model_validate(data)\n    pb_pose_order = PB_PathPose()\n    pose_order.copy_pb(pb_pose_order)\n    await self.copilot.pbcom.send_can_message(copilot.pose_order_uuid, pb_pose_order)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_pose_start","title":"<code>on_pose_start(data)</code>  <code>async</code>","text":"<p>Callback on pose start (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_pose_start(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose start (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    start_pose = models.PathPose.model_validate(data)\n    pb_start_pose = PB_PathPose()\n    start_pose.copy_pb(pb_start_pose)\n    await self.copilot.pbcom.send_can_message(copilot.pose_start_uuid, pb_start_pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_set_controller","title":"<code>on_set_controller(controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_set_controller(self, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to firmware.\n    \"\"\"\n    pb_controller = PB_Controller()\n    pb_controller.id = controller\n    await self.copilot.pbcom.send_can_message(copilot.controller_uuid, pb_controller)\n</code></pre>"},{"location":"reference/cogip/tools/copilot/sio_events/#cogip.tools.copilot.sio_events.SioEvents.on_shell_command","title":"<code>on_shell_command(data)</code>  <code>async</code>","text":"<p>Callback on shell command message.</p> <p>Build the Protobuf command message:</p> <ul> <li>split received string at first space if any.</li> <li>first is the command and goes to <code>cmd</code> attribute.</li> <li>second part is arguments, if any, and goes to <code>desc</code> attribute.</li> </ul> Source code in <code>cogip/tools/copilot/sio_events.py</code> <pre><code>async def on_shell_command(self, data):\n    \"\"\"\n    Callback on shell command message.\n\n    Build the Protobuf command message:\n\n    * split received string at first space if any.\n    * first is the command and goes to `cmd` attribute.\n    * second part is arguments, if any, and goes to `desc` attribute.\n    \"\"\"\n    response = PB_Command()\n    response.cmd, _, response.desc = data.partition(\" \")\n    await self.copilot.pbcom.send_can_message(copilot.command_uuid, response)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/copilot_pami/__main__/#cogip.tools.copilot_pami.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP PAMI Copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-copilot-pami</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/copilot_pami/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP PAMI Copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-copilot-pami` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/controller/","title":"controller","text":""},{"location":"reference/cogip/tools/copilot_pami/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot","title":"<code>Copilot</code>","text":"<p>Main copilot class.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>class Copilot:\n    \"\"\"\n    Main copilot class.\n    \"\"\"\n\n    _loop: asyncio.AbstractEventLoop = None  # Event loop to use for all coroutines\n\n    def __init__(self, server_url: str, id: int, serial_port: Path, serial_baud: int):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            id: robot id\n            serial_port: serial port connected to STM32 device\n            serial_baud: baud rate\n        \"\"\"\n        self.server_url = server_url\n        self.id = id\n        self.retry_connection = True\n        self.shell_menu: models.ShellMenu | None = None\n        self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_events = SioEvents(self)\n        self.sio.register_namespace(self.sio_events)\n\n        pb_message_handlers = {\n            reset_uuid: self.handle_reset,\n            menu_uuid: self.handle_message_menu,\n            pose_order_uuid: self.handle_message_pose,\n            state_uuid: self.handle_message_state,\n            pose_reached_uuid: self.handle_pose_reached,\n            actuator_state_uuid: self.handle_actuator_state,\n            pid_uuid: self.handle_pid,\n        }\n\n        self._pbcom = PBCom(serial_port, serial_baud, pb_message_handlers)\n\n    async def run(self):\n        \"\"\"\n        Start copilot.\n        \"\"\"\n        self._loop = asyncio.get_running_loop()\n\n        self.retry_connection = True\n        await self.try_connect()\n\n        await self._pbcom.send_serial_message(copilot_connected_uuid, None)\n\n        await self._pbcom.run()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    @property\n    def pbcom(self) -&gt; PBCom:\n        return self._pbcom\n\n    async def handle_reset(self) -&gt; None:\n        \"\"\"\n        Handle reset message. This means that the robot has just booted.\n\n        Send a reset message to all connected clients.\n        \"\"\"\n        await self._pbcom.send_serial_message(copilot_connected_uuid, None)\n        await self.sio_events.emit(\"reset\")\n\n    @pb_exception_handler\n    async def handle_message_menu(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send shell menu received from the robot to connected monitors.\n        \"\"\"\n        pb_menu = PB_Menu()\n\n        if message:\n            await self._loop.run_in_executor(None, pb_menu.ParseFromString, message)\n\n        menu = MessageToDict(pb_menu)\n        self.shell_menu = models.ShellMenu.model_validate(menu)\n        if self.sio.connected:\n            await self.sio_events.emit(\"menu\", self.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n\n    @pb_exception_handler\n    async def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot pose received from the robot to connected monitors and detector.\n        \"\"\"\n        pb_pose = PB_Pose()\n\n        if message:\n            await self._loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n        pose = MessageToDict(\n            pb_pose,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio.connected:\n            await self.sio_events.emit(\"pose\", pose)\n\n    @pb_exception_handler\n    async def handle_message_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send robot state received from the robot to connected monitors.\n        \"\"\"\n        pb_state = PB_State()\n\n        if message:\n            await self._loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n        state = MessageToDict(\n            pb_state,\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        if self.sio.connected:\n            await self.sio_events.emit(\"state\", state)\n\n    @pb_exception_handler\n    async def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send actuator state received from the robot.\n        \"\"\"\n        pb_actuator_state = PB_ActuatorState()\n\n        if message:\n            await self._loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n        kind = pb_actuator_state.WhichOneof(\"type\")\n        actuator_state = MessageToDict(\n            getattr(pb_actuator_state, kind),\n            including_default_value_fields=True,\n            preserving_proto_field_name=True,\n            use_integers_for_enums=True,\n        )\n        actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n        if self.sio.connected:\n            await self.sio_events.emit(\"actuator_state\", actuator_state)\n\n    @pb_exception_handler\n    async def handle_pid(self, message: bytes | None = None) -&gt; None:\n        \"\"\"\n        Send pids state received from the robot to connected dashboards.\n        \"\"\"\n        pb_pid = PB_Pid()\n        if message:\n            await self._loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n        self.pb_pids[pb_pid.id] = pb_pid\n        pid = Pid(\n            id=pb_pid.id,\n            kp=pb_pid.kp,\n            ki=pb_pid.ki,\n            kd=pb_pid.kd,\n            integral_term_limit=pb_pid.integral_term_limit,\n        )\n\n        # Get JSON Schema\n        pid_schema = pid.model_json_schema()\n        # Add namespace in JSON Schema\n        pid_schema[\"namespace\"] = \"/copilot\"\n        # Add current values in JSON Schema\n        pid_schema[\"title\"] = pid.id.name\n        for prop, value in pid.model_dump().items():\n            if prop == \"id\":\n                continue\n            pid_schema[\"properties\"][prop][\"value\"] = value\n            pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n            del pid_schema[\"properties\"][prop]\n        # Send config\n        await self.sio_events.emit(\"config\", pid_schema)\n\n    async def handle_pose_reached(self) -&gt; None:\n        \"\"\"\n        Handle pose reached message.\n\n        Forward info to the planner.\n        \"\"\"\n        if self.sio.connected:\n            await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.__init__","title":"<code>__init__(server_url, id, serial_port, serial_baud)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>id</code> <code>int</code> <p>robot id</p> required <code>serial_port</code> <code>Path</code> <p>serial port connected to STM32 device</p> required <code>serial_baud</code> <code>int</code> <p>baud rate</p> required Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>def __init__(self, server_url: str, id: int, serial_port: Path, serial_baud: int):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        id: robot id\n        serial_port: serial port connected to STM32 device\n        serial_baud: baud rate\n    \"\"\"\n    self.server_url = server_url\n    self.id = id\n    self.retry_connection = True\n    self.shell_menu: models.ShellMenu | None = None\n    self.pb_pids: dict[PB_PidEnum, PB_Pid] = {}\n\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_events = SioEvents(self)\n    self.sio.register_namespace(self.sio_events)\n\n    pb_message_handlers = {\n        reset_uuid: self.handle_reset,\n        menu_uuid: self.handle_message_menu,\n        pose_order_uuid: self.handle_message_pose,\n        state_uuid: self.handle_message_state,\n        pose_reached_uuid: self.handle_pose_reached,\n        actuator_state_uuid: self.handle_actuator_state,\n        pid_uuid: self.handle_pid,\n    }\n\n    self._pbcom = PBCom(serial_port, serial_baud, pb_message_handlers)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_actuator_state","title":"<code>handle_actuator_state(message=None)</code>  <code>async</code>","text":"<p>Send actuator state received from the robot.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_actuator_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send actuator state received from the robot.\n    \"\"\"\n    pb_actuator_state = PB_ActuatorState()\n\n    if message:\n        await self._loop.run_in_executor(None, pb_actuator_state.ParseFromString, message)\n\n    kind = pb_actuator_state.WhichOneof(\"type\")\n    actuator_state = MessageToDict(\n        getattr(pb_actuator_state, kind),\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    actuator_state[\"kind\"] = ActuatorsKindEnum[kind]\n    if self.sio.connected:\n        await self.sio_events.emit(\"actuator_state\", actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_message_menu","title":"<code>handle_message_menu(message=None)</code>  <code>async</code>","text":"<p>Send shell menu received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_menu(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send shell menu received from the robot to connected monitors.\n    \"\"\"\n    pb_menu = PB_Menu()\n\n    if message:\n        await self._loop.run_in_executor(None, pb_menu.ParseFromString, message)\n\n    menu = MessageToDict(pb_menu)\n    self.shell_menu = models.ShellMenu.model_validate(menu)\n    if self.sio.connected:\n        await self.sio_events.emit(\"menu\", self.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_message_pose","title":"<code>handle_message_pose(message=None)</code>  <code>async</code>","text":"<p>Send robot pose received from the robot to connected monitors and detector.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_pose(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot pose received from the robot to connected monitors and detector.\n    \"\"\"\n    pb_pose = PB_Pose()\n\n    if message:\n        await self._loop.run_in_executor(None, pb_pose.ParseFromString, message)\n\n    pose = MessageToDict(\n        pb_pose,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio.connected:\n        await self.sio_events.emit(\"pose\", pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_message_state","title":"<code>handle_message_state(message=None)</code>  <code>async</code>","text":"<p>Send robot state received from the robot to connected monitors.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_message_state(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send robot state received from the robot to connected monitors.\n    \"\"\"\n    pb_state = PB_State()\n\n    if message:\n        await self._loop.run_in_executor(None, pb_state.ParseFromString, message)\n\n    state = MessageToDict(\n        pb_state,\n        including_default_value_fields=True,\n        preserving_proto_field_name=True,\n        use_integers_for_enums=True,\n    )\n    if self.sio.connected:\n        await self.sio_events.emit(\"state\", state)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_pid","title":"<code>handle_pid(message=None)</code>  <code>async</code>","text":"<p>Send pids state received from the robot to connected dashboards.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>@pb_exception_handler\nasync def handle_pid(self, message: bytes | None = None) -&gt; None:\n    \"\"\"\n    Send pids state received from the robot to connected dashboards.\n    \"\"\"\n    pb_pid = PB_Pid()\n    if message:\n        await self._loop.run_in_executor(None, pb_pid.ParseFromString, message)\n\n    self.pb_pids[pb_pid.id] = pb_pid\n    pid = Pid(\n        id=pb_pid.id,\n        kp=pb_pid.kp,\n        ki=pb_pid.ki,\n        kd=pb_pid.kd,\n        integral_term_limit=pb_pid.integral_term_limit,\n    )\n\n    # Get JSON Schema\n    pid_schema = pid.model_json_schema()\n    # Add namespace in JSON Schema\n    pid_schema[\"namespace\"] = \"/copilot\"\n    # Add current values in JSON Schema\n    pid_schema[\"title\"] = pid.id.name\n    for prop, value in pid.model_dump().items():\n        if prop == \"id\":\n            continue\n        pid_schema[\"properties\"][prop][\"value\"] = value\n        pid_schema[\"properties\"][f\"{pid.id}-{prop}\"] = pid_schema[\"properties\"][prop]\n        del pid_schema[\"properties\"][prop]\n    # Send config\n    await self.sio_events.emit(\"config\", pid_schema)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_pose_reached","title":"<code>handle_pose_reached()</code>  <code>async</code>","text":"<p>Handle pose reached message.</p> <p>Forward info to the planner.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>async def handle_pose_reached(self) -&gt; None:\n    \"\"\"\n    Handle pose reached message.\n\n    Forward info to the planner.\n    \"\"\"\n    if self.sio.connected:\n        await self.sio_events.emit(\"pose_reached\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.handle_reset","title":"<code>handle_reset()</code>  <code>async</code>","text":"<p>Handle reset message. This means that the robot has just booted.</p> <p>Send a reset message to all connected clients.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>async def handle_reset(self) -&gt; None:\n    \"\"\"\n    Handle reset message. This means that the robot has just booted.\n\n    Send a reset message to all connected clients.\n    \"\"\"\n    await self._pbcom.send_serial_message(copilot_connected_uuid, None)\n    await self.sio_events.emit(\"reset\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start copilot.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start copilot.\n    \"\"\"\n    self._loop = asyncio.get_running_loop()\n\n    self.retry_connection = True\n    await self.try_connect()\n\n    await self._pbcom.send_serial_message(copilot_connected_uuid, None)\n\n    await self._pbcom.run()\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/copilot/#cogip.tools.copilot_pami.copilot.Copilot.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/copilot_pami/copilot.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/copilot\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/copilot_pami/pbcom/","title":"pbcom","text":""},{"location":"reference/cogip/tools/copilot_pami/pbcom/#cogip.tools.copilot_pami.pbcom.PBCom","title":"<code>PBCom</code>","text":"Source code in <code>cogip/tools/copilot_pami/pbcom.py</code> <pre><code>class PBCom:\n    _loop: asyncio.AbstractEventLoop = None  # Event loop to use for all async objects\n    _serial_port: AioSerial = None  # Async serial port\n    _serial_messages_received: asyncio.Queue = None  # Queue for messages received from serial port\n    _serial_messages_to_send: asyncio.Queue = None  # Queue for messages waiting to be sent on serial port\n\n    def __init__(self, serial_port: Path, serial_baud: int, message_handlers: dict[int, Callable]):\n        self._serial_port = AioSerial()\n        self._serial_port.port = str(serial_port)\n        self._serial_port.baudrate = serial_baud\n        self._message_handlers = message_handlers\n\n        # Create asyncio queues\n        self._serial_messages_received = asyncio.Queue()\n        self._serial_messages_received = asyncio.Queue()\n        self._serial_messages_to_send = asyncio.Queue()\n\n        self._serial_port.open()\n\n    async def run(self):\n        \"\"\"\n        Start PBCom.\n        \"\"\"\n        self._loop = asyncio.get_running_loop()\n\n        try:\n            await asyncio.gather(\n                self.serial_decoder(),\n                self.serial_receiver(),\n                self.serial_sender(),\n            )\n        except asyncio.CancelledError:\n            pass\n\n    async def serial_decoder(self):\n        \"\"\"\n        Async worker decoding messages received from the robot.\n        \"\"\"\n        uuid: int\n        encoded_message: bytes\n\n        try:\n            while True:\n                uuid, encoded_message = await self._serial_messages_received.get()\n                request_handler = self._message_handlers.get(uuid)\n                if not request_handler:\n                    print(f\"No handler found for message uuid '{uuid}'\")\n                else:\n                    if not encoded_message:\n                        await request_handler()\n                    else:\n                        await request_handler(encoded_message)\n\n                self._serial_messages_received.task_done()\n        except asyncio.CancelledError:\n            raise\n\n    async def send_serial_message(self, *args) -&gt; None:\n        await self._serial_messages_to_send.put(args)\n\n    async def serial_receiver(self):\n        \"\"\"\n        Async worker reading messages from the robot on serial ports.\n\n        Messages is base64-encoded and separated by `\\\\n`.\n        After decoding, first byte is the message type, following bytes are\n        the Protobuf encoded message (if any).\n        \"\"\"\n        try:\n            while True:\n                # Read next message\n                message = await self._serial_port.readline_async()\n                message = message.rstrip(b\"\\n\")\n\n                # Get message uuid on first bytes\n                uuid = int.from_bytes(message[:4], \"little\")\n\n                if len(message) == 4:\n                    await self._serial_messages_received.put((uuid, None))\n                    continue\n\n                # Base64 decoding\n                try:\n                    pb_message = base64.decodebytes(message[4:])\n                except binascii.Error:\n                    print(\"Failed to decode base64 message.\")\n                    continue\n\n                # Send Protobuf message for decoding\n                await self._serial_messages_received.put((uuid, pb_message))\n        except asyncio.CancelledError:\n            raise\n\n    async def serial_sender(self):\n        \"\"\"\n        Async worker encoding and sending Protobuf messages to the robot on serial ports.\n\n        See `serial_receiver` for message encoding.\n        \"\"\"\n        try:\n            while True:\n                uuid, pb_message = await self._serial_messages_to_send.get()\n                logger.info(f\"Send PB message: {uuid} {pb_message}\")\n                await self._serial_port.write_async(uuid.to_bytes(4, \"little\"))\n                if pb_message:\n                    response_serialized = await self._loop.run_in_executor(None, pb_message.SerializeToString)\n                    response_base64 = await self._loop.run_in_executor(None, base64.encodebytes, response_serialized)\n                    await self._serial_port.write_async(response_base64)\n                await self._serial_port.write_async(b\"\\0\")\n                self._serial_messages_to_send.task_done()\n        except asyncio.CancelledError:\n            raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/pbcom/#cogip.tools.copilot_pami.pbcom.PBCom.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Start PBCom.</p> Source code in <code>cogip/tools/copilot_pami/pbcom.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Start PBCom.\n    \"\"\"\n    self._loop = asyncio.get_running_loop()\n\n    try:\n        await asyncio.gather(\n            self.serial_decoder(),\n            self.serial_receiver(),\n            self.serial_sender(),\n        )\n    except asyncio.CancelledError:\n        pass\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/pbcom/#cogip.tools.copilot_pami.pbcom.PBCom.serial_decoder","title":"<code>serial_decoder()</code>  <code>async</code>","text":"<p>Async worker decoding messages received from the robot.</p> Source code in <code>cogip/tools/copilot_pami/pbcom.py</code> <pre><code>async def serial_decoder(self):\n    \"\"\"\n    Async worker decoding messages received from the robot.\n    \"\"\"\n    uuid: int\n    encoded_message: bytes\n\n    try:\n        while True:\n            uuid, encoded_message = await self._serial_messages_received.get()\n            request_handler = self._message_handlers.get(uuid)\n            if not request_handler:\n                print(f\"No handler found for message uuid '{uuid}'\")\n            else:\n                if not encoded_message:\n                    await request_handler()\n                else:\n                    await request_handler(encoded_message)\n\n            self._serial_messages_received.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/pbcom/#cogip.tools.copilot_pami.pbcom.PBCom.serial_receiver","title":"<code>serial_receiver()</code>  <code>async</code>","text":"<p>Async worker reading messages from the robot on serial ports.</p> <p>Messages is base64-encoded and separated by <code>\\n</code>. After decoding, first byte is the message type, following bytes are the Protobuf encoded message (if any).</p> Source code in <code>cogip/tools/copilot_pami/pbcom.py</code> <pre><code>async def serial_receiver(self):\n    \"\"\"\n    Async worker reading messages from the robot on serial ports.\n\n    Messages is base64-encoded and separated by `\\\\n`.\n    After decoding, first byte is the message type, following bytes are\n    the Protobuf encoded message (if any).\n    \"\"\"\n    try:\n        while True:\n            # Read next message\n            message = await self._serial_port.readline_async()\n            message = message.rstrip(b\"\\n\")\n\n            # Get message uuid on first bytes\n            uuid = int.from_bytes(message[:4], \"little\")\n\n            if len(message) == 4:\n                await self._serial_messages_received.put((uuid, None))\n                continue\n\n            # Base64 decoding\n            try:\n                pb_message = base64.decodebytes(message[4:])\n            except binascii.Error:\n                print(\"Failed to decode base64 message.\")\n                continue\n\n            # Send Protobuf message for decoding\n            await self._serial_messages_received.put((uuid, pb_message))\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/pbcom/#cogip.tools.copilot_pami.pbcom.PBCom.serial_sender","title":"<code>serial_sender()</code>  <code>async</code>","text":"<p>Async worker encoding and sending Protobuf messages to the robot on serial ports.</p> <p>See <code>serial_receiver</code> for message encoding.</p> Source code in <code>cogip/tools/copilot_pami/pbcom.py</code> <pre><code>async def serial_sender(self):\n    \"\"\"\n    Async worker encoding and sending Protobuf messages to the robot on serial ports.\n\n    See `serial_receiver` for message encoding.\n    \"\"\"\n    try:\n        while True:\n            uuid, pb_message = await self._serial_messages_to_send.get()\n            logger.info(f\"Send PB message: {uuid} {pb_message}\")\n            await self._serial_port.write_async(uuid.to_bytes(4, \"little\"))\n            if pb_message:\n                response_serialized = await self._loop.run_in_executor(None, pb_message.SerializeToString)\n                response_base64 = await self._loop.run_in_executor(None, base64.encodebytes, response_serialized)\n                await self._serial_port.write_async(response_base64)\n            await self._serial_port.write_async(b\"\\0\")\n            self._serial_messages_to_send.task_done()\n    except asyncio.CancelledError:\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/pid/","title":"pid","text":""},{"location":"reference/cogip/tools/copilot_pami/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, copilot: \"copilot.Copilot\"):\n        super().__init__(\"/copilot\")\n        self.copilot = copilot\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=1,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n\n        if self.copilot.shell_menu:\n            await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n        await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n\n    async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if isinstance(data, dict) and \"message\" in data:\n            message = data[\"message\"]\n        else:\n            message = data\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n\n    async def on_command(self, data):\n        \"\"\"\n        Callback on tool command message.\n        \"\"\"\n        cmd, _, _ = data.partition(\" \")\n        pid_id = PB_Pid_Id()\n        match cmd:\n            case \"angular_speed_pid_config\":\n                # Request angular speed pid state\n                pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n                await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_speed_pid_config\":\n                # Request linear_speed pid state\n                pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n                await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n            case \"angular_position_pid_config\":\n                # Request angular position pid state\n                pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n                await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n            case \"linear_position_pid_config\":\n                # Request linear position pid state\n                pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n                await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_shell_command(self, data):\n        \"\"\"\n        Callback on shell command message.\n\n        Build the Protobuf command message:\n\n        * split received string at first space if any.\n        * first is the command and goes to `cmd` attribute.\n        * second part is arguments, if any, and goes to `desc` attribute.\n        \"\"\"\n        response = PB_Command()\n        response.cmd, _, response.desc = data.partition(\" \")\n        await self.copilot.pbcom.send_serial_message(copilot.command_uuid, response)\n\n    async def on_pose_start(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose start (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        start_pose = models.PathPose.model_validate(data)\n        pb_start_pose = PB_PathPose()\n        start_pose.copy_pb(pb_start_pose)\n        await self.copilot.pbcom.send_serial_message(copilot.pose_start_uuid, pb_start_pose)\n\n    async def on_pose_order(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on pose order (from planner).\n        Forward to mcu-firmware.\n        \"\"\"\n        pose_order = models.PathPose.model_validate(data)\n        pb_pose_order = PB_PathPose()\n        pose_order.copy_pb(pb_pose_order)\n        await self.copilot.pbcom.send_serial_message(copilot.pose_order_uuid, pb_pose_order)\n\n    async def on_actuators_start(self):\n        \"\"\"\n        Callback on actuators_start (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.actuators_thread_start_uuid, None)\n\n    async def on_actuators_stop(self):\n        \"\"\"\n        Callback on actuators_stop (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.actuators_thread_stop_uuid, None)\n\n    async def on_actuator_command(self, data: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_command (from dashboard).\n        Forward to mcu-firmware.\n        \"\"\"\n        command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n        pb_command = PB_ActuatorCommand()\n        if isinstance(command, ServoCommand):\n            command.pb_copy(pb_command.servo)\n        elif isinstance(command, PositionalActuatorCommand):\n            command.pb_copy(pb_command.positional_actuator)\n        await self.copilot.pbcom.send_serial_message(copilot.actuator_command_uuid, pb_command)\n\n    async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on config_updated from dashboard.\n        Update pid PB message and send it back to firmware.\n        \"\"\"\n        pid_id, _, name = config[\"name\"].partition(\"-\")\n        if pid_id and name:\n            setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n            await self.copilot.pbcom.send_serial_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n\n    async def on_set_controller(self, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to firmware.\n        \"\"\"\n        pb_controller = PB_Controller()\n        pb_controller.id = controller\n        await self.copilot.pbcom.send_serial_message(copilot.controller_uuid, pb_controller)\n\n    async def on_game_start(self):\n        \"\"\"\n        Callback on game_start message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.game_start_uuid, None)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game_end message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.game_end_uuid, None)\n\n    async def on_game_reset(self):\n        \"\"\"\n        Callback on game_reset message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.game_reset_uuid, None)\n\n    async def on_brake(self):\n        \"\"\"\n        Callback on brake message.\n        Forward to firmware.\n        \"\"\"\n        await self.copilot.pbcom.send_serial_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_actuator_command","title":"<code>on_actuator_command(data)</code>  <code>async</code>","text":"<p>Callback on actuator_command (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_actuator_command(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_command (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    command = TypeAdapter(ActuatorCommand).validate_python(data)\n\n    pb_command = PB_ActuatorCommand()\n    if isinstance(command, ServoCommand):\n        command.pb_copy(pb_command.servo)\n    elif isinstance(command, PositionalActuatorCommand):\n        command.pb_copy(pb_command.positional_actuator)\n    await self.copilot.pbcom.send_serial_message(copilot.actuator_command_uuid, pb_command)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_actuators_start","title":"<code>on_actuators_start()</code>  <code>async</code>","text":"<p>Callback on actuators_start (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_actuators_start(self):\n    \"\"\"\n    Callback on actuators_start (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.actuators_thread_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_actuators_stop","title":"<code>on_actuators_stop()</code>  <code>async</code>","text":"<p>Callback on actuators_stop (from dashboard). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_actuators_stop(self):\n    \"\"\"\n    Callback on actuators_stop (from dashboard).\n    Forward to mcu-firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.actuators_thread_stop_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_brake","title":"<code>on_brake()</code>  <code>async</code>","text":"<p>Callback on brake message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_brake(self):\n    \"\"\"\n    Callback on brake message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.brake_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_command","title":"<code>on_command(data)</code>  <code>async</code>","text":"<p>Callback on tool command message.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_command(self, data):\n    \"\"\"\n    Callback on tool command message.\n    \"\"\"\n    cmd, _, _ = data.partition(\" \")\n    pid_id = PB_Pid_Id()\n    match cmd:\n        case \"angular_speed_pid_config\":\n            # Request angular speed pid state\n            pid_id.id = PB_PidEnum.ANGULAR_SPEED_PID\n            await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_speed_pid_config\":\n            # Request linear_speed pid state\n            pid_id.id = PB_PidEnum.LINEAR_SPEED_PID\n            await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n        case \"angular_position_pid_config\":\n            # Request angular position pid state\n            pid_id.id = PB_PidEnum.ANGULAR_POSE_PID\n            await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n        case \"linear_position_pid_config\":\n            # Request linear position pid state\n            pid_id.id = PB_PidEnum.LINEAR_POSE_PID\n            await self.copilot.pbcom.send_serial_message(copilot.pid_request_uuid, pid_id)\n        case _:\n            logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config_updated from dashboard. Update pid PB message and send it back to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on config_updated from dashboard.\n    Update pid PB message and send it back to firmware.\n    \"\"\"\n    pid_id, _, name = config[\"name\"].partition(\"-\")\n    if pid_id and name:\n        setattr(self.copilot.pb_pids[int(pid_id)], name, config[\"value\"])\n        await self.copilot.pbcom.send_serial_message(copilot.pid_uuid, self.copilot.pb_pids[int(pid_id)])\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=1,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n\n    if self.copilot.shell_menu:\n        await self.emit(\"menu\", self.copilot.shell_menu.model_dump(exclude_defaults=True, exclude_unset=True))\n    await self.emit(\"register_menu\", {\"name\": \"copilot\", \"menu\": menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if isinstance(data, dict) and \"message\" in data:\n        message = data[\"message\"]\n    else:\n        message = data\n    logger.error(f\"Connection to cogip-server failed: {message}\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game_end message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game_end message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.game_end_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_game_reset","title":"<code>on_game_reset()</code>  <code>async</code>","text":"<p>Callback on game_reset message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_game_reset(self):\n    \"\"\"\n    Callback on game_reset message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.game_reset_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_game_start","title":"<code>on_game_start()</code>  <code>async</code>","text":"<p>Callback on game_start message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_game_start(self):\n    \"\"\"\n    Callback on game_start message.\n    Forward to firmware.\n    \"\"\"\n    await self.copilot.pbcom.send_serial_message(copilot.game_start_uuid, None)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_pose_order","title":"<code>on_pose_order(data)</code>  <code>async</code>","text":"<p>Callback on pose order (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_pose_order(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose order (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    pose_order = models.PathPose.model_validate(data)\n    pb_pose_order = PB_PathPose()\n    pose_order.copy_pb(pb_pose_order)\n    await self.copilot.pbcom.send_serial_message(copilot.pose_order_uuid, pb_pose_order)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_pose_start","title":"<code>on_pose_start(data)</code>  <code>async</code>","text":"<p>Callback on pose start (from planner). Forward to mcu-firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_pose_start(self, data: dict[str, Any]):\n    \"\"\"\n    Callback on pose start (from planner).\n    Forward to mcu-firmware.\n    \"\"\"\n    start_pose = models.PathPose.model_validate(data)\n    pb_start_pose = PB_PathPose()\n    start_pose.copy_pb(pb_start_pose)\n    await self.copilot.pbcom.send_serial_message(copilot.pose_start_uuid, pb_start_pose)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_set_controller","title":"<code>on_set_controller(controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to firmware.</p> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_set_controller(self, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to firmware.\n    \"\"\"\n    pb_controller = PB_Controller()\n    pb_controller.id = controller\n    await self.copilot.pbcom.send_serial_message(copilot.controller_uuid, pb_controller)\n</code></pre>"},{"location":"reference/cogip/tools/copilot_pami/sio_events/#cogip.tools.copilot_pami.sio_events.SioEvents.on_shell_command","title":"<code>on_shell_command(data)</code>  <code>async</code>","text":"<p>Callback on shell command message.</p> <p>Build the Protobuf command message:</p> <ul> <li>split received string at first space if any.</li> <li>first is the command and goes to <code>cmd</code> attribute.</li> <li>second part is arguments, if any, and goes to <code>desc</code> attribute.</li> </ul> Source code in <code>cogip/tools/copilot_pami/sio_events.py</code> <pre><code>async def on_shell_command(self, data):\n    \"\"\"\n    Callback on shell command message.\n\n    Build the Protobuf command message:\n\n    * split received string at first space if any.\n    * first is the command and goes to `cmd` attribute.\n    * second part is arguments, if any, and goes to `desc` attribute.\n    \"\"\"\n    response = PB_Command()\n    response.cmd, _, response.desc = data.partition(\" \")\n    await self.copilot.pbcom.send_serial_message(copilot.command_uuid, response)\n</code></pre>"},{"location":"reference/cogip/tools/cpp_example/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/cpp_example/__main__/#cogip.tools.cpp_example.__main__.main","title":"<code>main()</code>","text":"<p>Example calling a function from a C++ class..</p> <p>During installation of cogip-tools, a script called <code>cogip-cpp-example</code> will be created using this function as entrypoint.</p> Source code in <code>cogip/tools/cpp_example/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Example calling a function from a C++ class..\n\n    During installation of cogip-tools, a script called `cogip-cpp-example`\n    will be created using this function as entrypoint.\n    \"\"\"\n    example = PyExample()\n    print(example.get_message())\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/dashboard/__main__/#cogip.tools.dashboard.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Dashboard.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-dashboard</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/dashboard/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Dashboard.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-dashboard` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/app/","title":"app","text":""},{"location":"reference/cogip/tools/dashboard/app/#cogip.tools.dashboard.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/dashboard/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    dashboard = Dashboard()\n    return dashboard.app\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard","title":"<code>Dashboard</code>","text":"Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>class Dashboard:\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _original_uvicorn_exit_handler = Server.handle_exit  # Backup of original exit handler to overload it\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application.\n        \"\"\"\n        self.app = FastAPI(title=\"COGIP Web Monitor\", debug=False)\n\n        # Overload default Uvicorn exit handler\n        Server.handle_exit = self.handle_exit\n\n        # Mount static files\n        current_dir = Path(__file__).parent\n        self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n        # Create HTML templates\n        self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n        # Register routes\n        self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Dashboard._exiting = True\n        Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application.</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application.\n    \"\"\"\n    self.app = FastAPI(title=\"COGIP Web Monitor\", debug=False)\n\n    # Overload default Uvicorn exit handler\n    Server.handle_exit = self.handle_exit\n\n    # Mount static files\n    current_dir = Path(__file__).parent\n    self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n    # Create HTML templates\n    self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n    # Register routes\n    self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/dashboard/#cogip.tools.dashboard.dashboard.Dashboard.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/dashboard/dashboard.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Dashboard._exiting = True\n    Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter","title":"<code>BeaconRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>class BeaconRouter(APIRouter):\n    def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        @self.get(\"/\", response_class=HTMLResponse)\n        async def index(request: Request):\n            \"\"\"\n            Homepage of the dashboard web server.\n            \"\"\"\n            return templates.TemplateResponse(\"dashboard.html\", {\"request\": request})\n</code></pre>"},{"location":"reference/cogip/tools/dashboard/routes/beacon/#cogip.tools.dashboard.routes.beacon.BeaconRouter.__init__","title":"<code>__init__(templates, *args, **kwargs)</code>","text":"Source code in <code>cogip/tools/dashboard/routes/beacon.py</code> <pre><code>def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    @self.get(\"/\", response_class=HTMLResponse)\n    async def index(request: Request):\n        \"\"\"\n        Homepage of the dashboard web server.\n        \"\"\"\n        return templates.TemplateResponse(\"dashboard.html\", {\"request\": request})\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/dashboard_beacon/__main__/#cogip.tools.dashboard_beacon.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Beacon Dashboard.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-dashboard-beacon</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/dashboard_beacon/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Beacon Dashboard.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-dashboard-beacon` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/app/","title":"app","text":""},{"location":"reference/cogip/tools/dashboard_beacon/app/#cogip.tools.dashboard_beacon.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/dashboard_beacon/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    dashboard = Dashboard()\n    return dashboard.app\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/dashboard_beacon/dashboard/#cogip.tools.dashboard_beacon.dashboard.Dashboard","title":"<code>Dashboard</code>","text":"Source code in <code>cogip/tools/dashboard_beacon/dashboard.py</code> <pre><code>class Dashboard:\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _original_uvicorn_exit_handler = Server.handle_exit  # Backup of original exit handler to overload it\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application.\n        \"\"\"\n        self.app = FastAPI(title=\"COGIP Beacon Dashboard\", debug=False)\n\n        # Overload default Uvicorn exit handler\n        Server.handle_exit = self.handle_exit\n\n        # Mount static files\n        current_dir = Path(__file__).parent\n        self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n        # Create HTML templates\n        self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n        # Register routes\n        self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Dashboard._exiting = True\n        Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/dashboard/#cogip.tools.dashboard_beacon.dashboard.Dashboard.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application.</p> Source code in <code>cogip/tools/dashboard_beacon/dashboard.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application.\n    \"\"\"\n    self.app = FastAPI(title=\"COGIP Beacon Dashboard\", debug=False)\n\n    # Overload default Uvicorn exit handler\n    Server.handle_exit = self.handle_exit\n\n    # Mount static files\n    current_dir = Path(__file__).parent\n    self.app.mount(\"/static\", StaticFiles(directory=current_dir / \"static\"), name=\"static\")\n\n    # Create HTML templates\n    self.templates = Jinja2Templates(directory=current_dir / \"templates\")\n\n    # Register routes\n    self.app.include_router(routes.BeaconRouter(self.templates), prefix=\"\")\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/dashboard/#cogip.tools.dashboard_beacon.dashboard.Dashboard.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/dashboard_beacon/dashboard.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Dashboard._exiting = True\n    Dashboard._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/routes/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/dashboard_beacon/routes/beacon/#cogip.tools.dashboard_beacon.routes.beacon.BeaconRouter","title":"<code>BeaconRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> Source code in <code>cogip/tools/dashboard_beacon/routes/beacon.py</code> <pre><code>class BeaconRouter(APIRouter):\n    def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        @self.get(\"/\", response_class=HTMLResponse)\n        async def index(request: Request):\n            \"\"\"\n            Homepage of the dashboard web server.\n            \"\"\"\n            return templates.TemplateResponse(\"dashboard.html\", {\"request\": request})\n</code></pre>"},{"location":"reference/cogip/tools/dashboard_beacon/routes/beacon/#cogip.tools.dashboard_beacon.routes.beacon.BeaconRouter.__init__","title":"<code>__init__(templates, *args, **kwargs)</code>","text":"Source code in <code>cogip/tools/dashboard_beacon/routes/beacon.py</code> <pre><code>def __init__(self, templates: Jinja2Templates, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    @self.get(\"/\", response_class=HTMLResponse)\n    async def index(request: Request):\n        \"\"\"\n        Homepage of the dashboard web server.\n        \"\"\"\n        return templates.TemplateResponse(\"dashboard.html\", {\"request\": request})\n</code></pre>"},{"location":"reference/cogip/tools/detector/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/detector/__main__/#cogip.tools.detector.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Obstacle Detector.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-detector</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/detector/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Obstacle Detector.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-detector` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector","title":"<code>Detector</code>","text":"<p>Main detector class.</p> <p>Read Lidar data from the Lidar in monitoring mode or fake data provided by <code>Monitor</code> in emulation Mode.</p> <p>Build obstacles and send the list to the server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>class Detector:\n    \"\"\"\n    Main detector class.\n\n    Read Lidar data from the Lidar in monitoring mode\n    or fake data provided by `Monitor` in emulation Mode.\n\n    Build obstacles and send the list to the server.\n    \"\"\"\n\n    NB_ANGLES_WITHOUT_OBSTACLE_TO_IGNORE: int = 3\n\n    def __init__(\n        self,\n        server_url: str,\n        lidar_port: str | None,\n        min_distance: int,\n        max_distance: int,\n        beacon_radius: int,\n        refresh_interval: float,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            lidar_port: Serial port connected to the Lidar\n            min_distance: Minimum distance to detect an obstacle\n            max_distance: Maximum distance to detect an obstacle\n            beacon_radius: Radius of the opponent beacon support (a cylinder of 70mm diameter to a cube of 100mm width)\n            refresh_interval: Interval between each update of the obstacle list (in seconds)\n        \"\"\"\n        self._server_url = server_url\n        self._lidar_port = lidar_port\n        self._properties = Properties(\n            min_distance=min_distance,\n            max_distance=max_distance,\n            beacon_radius=beacon_radius,\n            refresh_interval=refresh_interval,\n        )\n        self._lidar_data: list[int] = list()\n        self._lidar_data_lock = threading.Lock()\n        self._robot_pose = models.Pose()\n        self._robot_pose_lock = threading.Lock()\n\n        self._obstacles_updater_loop = ThreadLoop(\n            \"Obstacles updater loop\",\n            refresh_interval,\n            self.process_lidar_data,\n            logger=True,\n        )\n\n        self._lidar_reader_loop = ThreadLoop(\n            \"Lidar reader loop\",\n            refresh_interval,\n            self.read_lidar,\n            logger=True,\n        )\n\n        self._laser: ydlidar.CYdLidar | None = None\n        self._scan: ydlidar.LaserScan | None = None\n        if ydlidar and not self._lidar_port:\n            for _, value in ydlidar.lidarPortList().items():\n                self._lidar_port = value\n        if self._lidar_port:\n            self._laser = ydlidar.CYdLidar()\n            self._laser.setlidaropt(ydlidar.LidarPropSerialPort, str(self._lidar_port))\n            self._laser.setlidaropt(ydlidar.LidarPropSerialBaudrate, 230400)\n            self._laser.setlidaropt(ydlidar.LidarPropLidarType, ydlidar.TYPE_TRIANGLE)\n            self._laser.setlidaropt(ydlidar.LidarPropDeviceType, ydlidar.YDLIDAR_TYPE_SERIAL)\n            self._laser.setlidaropt(ydlidar.LidarPropSingleChannel, False)\n            self._laser.setlidaropt(ydlidar.LidarPropSampleRate, 5)\n            self._laser.setlidaropt(ydlidar.LidarPropIntenstiy, True)\n            self._laser.setlidaropt(ydlidar.LidarPropScanFrequency, 5.0)\n            self._laser.setlidaropt(ydlidar.LidarPropMaxRange, (max_distance - beacon_radius) / 1000)\n            self._laser.setlidaropt(ydlidar.LidarPropMinRange, min_distance / 1000)\n            self._laser.setlidaropt(ydlidar.LidarPropInverted, False)\n\n            self._scan = ydlidar.LaserScan()\n\n        self._sio = socketio.Client(logger=False)\n        self._sio.register_namespace(SioEvents(self))\n\n    def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        threading.Thread(target=self.try_connect).start()\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start updating obstacles list.\n        \"\"\"\n        self._obstacles_updater_loop.start()\n        if self._laser:\n            self._lidar_reader_loop.start()\n            self.start_lidar()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop updating obstacles list.\n        \"\"\"\n        self._obstacles_updater_loop.stop()\n        if self._laser:\n            self._lidar_reader_loop.stop()\n            self.stop_lidar()\n\n    def try_connect(self):\n        \"\"\"\n        Poll to wait for the first cogip-server connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while True:\n            try:\n                self._sio.connect(\n                    self._server_url,\n                    namespaces=[\"/detector\"],\n                )\n                self._sio.wait()\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    @property\n    def properties(self) -&gt; Properties:\n        return self._properties\n\n    @property\n    def robot_pose(self) -&gt; models.Pose:\n        \"\"\"\n        Last position of the robot.\n        \"\"\"\n        return self._robot_pose\n\n    @robot_pose.setter\n    def robot_pose(self, new_pose: models.Pose) -&gt; None:\n        with self._robot_pose_lock:\n            self._robot_pose = new_pose\n\n    def update_refresh_interval(self) -&gt; None:\n        self._obstacles_updater_loop.interval = self._properties.refresh_interval\n        self._lidar_reader_loop.interval = self._properties.refresh_interval\n\n    def update_lidar_data(self, lidar_data: list[int]):\n        \"\"\"\n        Receive Lidar data.\n        \"\"\"\n        with self._lidar_data_lock:\n            self._lidar_data[:] = lidar_data[:]\n\n    def filter_distances(self) -&gt; list[int]:\n        \"\"\"\n        Find consecutive obstacles and keep the nearest obstacle at the middle.\n        \"\"\"\n        filtered_distances = [self.properties.max_distance - self.properties.beacon_radius] * 360\n\n        # Find an angle without obstacle\n        angles_without_obstacles = [\n            i\n            for i, d in enumerate(self._lidar_data)\n            if d &gt;= self.properties.max_distance - self.properties.beacon_radius\n        ]\n\n        # Exit if no obstacle detected\n        if len(angles_without_obstacles) == 0:\n            return filtered_distances\n\n        start = angles_without_obstacles[0]\n\n        # Iterate over all angles, starting by the first angle without obstacle\n        first = start\n        while first &lt; start + 360:\n            dist_min = self._lidar_data[first % 360]\n\n            # Find the next angle with obstacle\n            if dist_min &gt;= self.properties.max_distance - self.properties.beacon_radius:\n                first += 1\n                continue\n\n            # An angle (first) with obstacle is found, iterate until the next angle without obstacle\n            for last in range(first + 1, start + 360 + 1):\n                dist_current = self._lidar_data[last % 360]\n\n                # Keep the nearest distance of consecutive obstacles\n                if dist_current &lt; (self.properties.max_distance - self.properties.beacon_radius) or self._lidar_data[\n                    (last + 1) % 360\n                ] &lt; (self.properties.max_distance - self.properties.beacon_radius):\n                    dist_min = dist_current if dist_current &lt; dist_min else dist_min\n                    continue\n\n                # Do not exit the loop only if NB_ANGLES_WITHOUT_OBSTACLE_TO_IGNORE consecutive\n                # angles have no obstacle.\n                continue_loop = False\n                for next in range(last + 1, last + self.NB_ANGLES_WITHOUT_OBSTACLE_TO_IGNORE):\n                    if self._lidar_data[next % 360] &lt; self.properties.max_distance - self.properties.beacon_radius:\n                        continue_loop = True\n                        break\n\n                if continue_loop:\n                    continue\n\n                # Only keep one angle at the middle of the consecutive angles with obstacles\n                # Set its distance to the minimum distance of the range\n                last = last - 1\n                middle = first + int((last - first) / 2 + 0.5)\n                filtered_distances[middle % 360] = dist_min\n                first = last + 1\n                break\n            first += 1\n\n        return filtered_distances\n\n    def generate_obstacles(self, robot_pose: models.Pose, distances: list[int]) -&gt; list[models.Vertex]:\n        \"\"\"\n        Update obstacles list from lidar data.\n        \"\"\"\n        obstacles: list[models.Vertex] = []\n\n        for angle, distance in enumerate(distances):\n            if (\n                distance &lt; self.properties.min_distance\n                or distance &gt;= self.properties.max_distance - self.properties.beacon_radius\n            ):\n                continue\n\n            angle = (360 - angle) % 360\n\n            # Compute obstacle position\n            obstacle_angle = math.radians((int(robot_pose.O) + angle) % 360)\n            x = robot_pose.x + distance * math.cos(obstacle_angle)\n            y = robot_pose.y + distance * math.sin(obstacle_angle)\n\n            obstacles.append(models.Vertex(x=x, y=y))\n\n        return obstacles\n\n    def process_lidar_data(self):\n        \"\"\"\n        Function executed in a thread loop to update and send dynamic obstacles.\n        \"\"\"\n        with self._lidar_data_lock:\n            filtered_distances = self.filter_distances()\n        with self._robot_pose_lock:\n            robot_pose = self.robot_pose.model_copy()\n\n        obstacles = self.generate_obstacles(robot_pose, filtered_distances)\n        logger.debug(f\"Generated obstacles: {obstacles}\")\n        if self._sio.connected:\n            self._sio.emit(\"obstacles\", [o.model_dump(exclude_defaults=True) for o in obstacles], namespace=\"/detector\")\n\n    def start_lidar(self):\n        \"\"\"\n        Start the Lidar.\n        \"\"\"\n        if self._laser:\n            self._laser.initialize()\n            self._laser.turnOn()\n\n    def read_lidar(self):\n        \"\"\"\n        Function executed in a thread loop to read Lidar data.\n        \"\"\"\n        if not ydlidar.os_isOk():\n            return\n\n        ret = self._laser.doProcessSimple(self._scan)\n        if ret:\n            tmp_distances = [[] for _ in range(360)]\n            result = []\n\n            # Build a list of points for each integer degree\n            for point in self._scan.points:\n                angle_sym = math.floor(math.degrees(point.angle))\n                angle = angle_sym if angle_sym &gt;= 0 else angle_sym + 360\n                if 0 &lt;= angle &lt; 360 and point.range &gt; 0.0:\n                    tmp_distances[angle].append(point.range)\n\n            # Compute mean of points list for each degree.\n            empty_angles = []\n            for angle, distances in enumerate(tmp_distances):\n                distance = self.properties.max_distance - self.properties.beacon_radius\n                if size := len(distances):\n                    distance = round(sum(distances) * 1000 / size)\n                else:\n                    empty_angles.append(angle)\n\n                result.append(distance + self.properties.beacon_radius)\n\n            # If a degree has no valid point and is isolated (no other empty angle before and after)\n            # it is probably a bad value, so set it to the mean of surrounding degrees.\n            for group in consecutive_groups(empty_angles):\n                g = list(group)\n                if len(g) == 1:\n                    isolated = g[0]\n                    before = result[(isolated - 1) % 360]\n                    after = result[(isolated + 1) % 360]\n                    result[isolated] = round((before + after) / 2)\n\n            self.update_lidar_data(result)\n        else:\n            print(\"Failed to get Lidar Data\")\n\n    def stop_lidar(self):\n        \"\"\"\n        Stop the Lidar.\n        \"\"\"\n        if self._laser:\n            self._laser.turnOff()\n            self._laser.disconnecting()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.robot_pose","title":"<code>robot_pose: models.Pose</code>  <code>property</code> <code>writable</code>","text":"<p>Last position of the robot.</p>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.__init__","title":"<code>__init__(server_url, lidar_port, min_distance, max_distance, beacon_radius, refresh_interval)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>lidar_port</code> <code>str | None</code> <p>Serial port connected to the Lidar</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance to detect an obstacle</p> required <code>max_distance</code> <code>int</code> <p>Maximum distance to detect an obstacle</p> required <code>beacon_radius</code> <code>int</code> <p>Radius of the opponent beacon support (a cylinder of 70mm diameter to a cube of 100mm width)</p> required <code>refresh_interval</code> <code>float</code> <p>Interval between each update of the obstacle list (in seconds)</p> required Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def __init__(\n    self,\n    server_url: str,\n    lidar_port: str | None,\n    min_distance: int,\n    max_distance: int,\n    beacon_radius: int,\n    refresh_interval: float,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        lidar_port: Serial port connected to the Lidar\n        min_distance: Minimum distance to detect an obstacle\n        max_distance: Maximum distance to detect an obstacle\n        beacon_radius: Radius of the opponent beacon support (a cylinder of 70mm diameter to a cube of 100mm width)\n        refresh_interval: Interval between each update of the obstacle list (in seconds)\n    \"\"\"\n    self._server_url = server_url\n    self._lidar_port = lidar_port\n    self._properties = Properties(\n        min_distance=min_distance,\n        max_distance=max_distance,\n        beacon_radius=beacon_radius,\n        refresh_interval=refresh_interval,\n    )\n    self._lidar_data: list[int] = list()\n    self._lidar_data_lock = threading.Lock()\n    self._robot_pose = models.Pose()\n    self._robot_pose_lock = threading.Lock()\n\n    self._obstacles_updater_loop = ThreadLoop(\n        \"Obstacles updater loop\",\n        refresh_interval,\n        self.process_lidar_data,\n        logger=True,\n    )\n\n    self._lidar_reader_loop = ThreadLoop(\n        \"Lidar reader loop\",\n        refresh_interval,\n        self.read_lidar,\n        logger=True,\n    )\n\n    self._laser: ydlidar.CYdLidar | None = None\n    self._scan: ydlidar.LaserScan | None = None\n    if ydlidar and not self._lidar_port:\n        for _, value in ydlidar.lidarPortList().items():\n            self._lidar_port = value\n    if self._lidar_port:\n        self._laser = ydlidar.CYdLidar()\n        self._laser.setlidaropt(ydlidar.LidarPropSerialPort, str(self._lidar_port))\n        self._laser.setlidaropt(ydlidar.LidarPropSerialBaudrate, 230400)\n        self._laser.setlidaropt(ydlidar.LidarPropLidarType, ydlidar.TYPE_TRIANGLE)\n        self._laser.setlidaropt(ydlidar.LidarPropDeviceType, ydlidar.YDLIDAR_TYPE_SERIAL)\n        self._laser.setlidaropt(ydlidar.LidarPropSingleChannel, False)\n        self._laser.setlidaropt(ydlidar.LidarPropSampleRate, 5)\n        self._laser.setlidaropt(ydlidar.LidarPropIntenstiy, True)\n        self._laser.setlidaropt(ydlidar.LidarPropScanFrequency, 5.0)\n        self._laser.setlidaropt(ydlidar.LidarPropMaxRange, (max_distance - beacon_radius) / 1000)\n        self._laser.setlidaropt(ydlidar.LidarPropMinRange, min_distance / 1000)\n        self._laser.setlidaropt(ydlidar.LidarPropInverted, False)\n\n        self._scan = ydlidar.LaserScan()\n\n    self._sio = socketio.Client(logger=False)\n    self._sio.register_namespace(SioEvents(self))\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.connect","title":"<code>connect()</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    threading.Thread(target=self.try_connect).start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.filter_distances","title":"<code>filter_distances()</code>","text":"<p>Find consecutive obstacles and keep the nearest obstacle at the middle.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def filter_distances(self) -&gt; list[int]:\n    \"\"\"\n    Find consecutive obstacles and keep the nearest obstacle at the middle.\n    \"\"\"\n    filtered_distances = [self.properties.max_distance - self.properties.beacon_radius] * 360\n\n    # Find an angle without obstacle\n    angles_without_obstacles = [\n        i\n        for i, d in enumerate(self._lidar_data)\n        if d &gt;= self.properties.max_distance - self.properties.beacon_radius\n    ]\n\n    # Exit if no obstacle detected\n    if len(angles_without_obstacles) == 0:\n        return filtered_distances\n\n    start = angles_without_obstacles[0]\n\n    # Iterate over all angles, starting by the first angle without obstacle\n    first = start\n    while first &lt; start + 360:\n        dist_min = self._lidar_data[first % 360]\n\n        # Find the next angle with obstacle\n        if dist_min &gt;= self.properties.max_distance - self.properties.beacon_radius:\n            first += 1\n            continue\n\n        # An angle (first) with obstacle is found, iterate until the next angle without obstacle\n        for last in range(first + 1, start + 360 + 1):\n            dist_current = self._lidar_data[last % 360]\n\n            # Keep the nearest distance of consecutive obstacles\n            if dist_current &lt; (self.properties.max_distance - self.properties.beacon_radius) or self._lidar_data[\n                (last + 1) % 360\n            ] &lt; (self.properties.max_distance - self.properties.beacon_radius):\n                dist_min = dist_current if dist_current &lt; dist_min else dist_min\n                continue\n\n            # Do not exit the loop only if NB_ANGLES_WITHOUT_OBSTACLE_TO_IGNORE consecutive\n            # angles have no obstacle.\n            continue_loop = False\n            for next in range(last + 1, last + self.NB_ANGLES_WITHOUT_OBSTACLE_TO_IGNORE):\n                if self._lidar_data[next % 360] &lt; self.properties.max_distance - self.properties.beacon_radius:\n                    continue_loop = True\n                    break\n\n            if continue_loop:\n                continue\n\n            # Only keep one angle at the middle of the consecutive angles with obstacles\n            # Set its distance to the minimum distance of the range\n            last = last - 1\n            middle = first + int((last - first) / 2 + 0.5)\n            filtered_distances[middle % 360] = dist_min\n            first = last + 1\n            break\n        first += 1\n\n    return filtered_distances\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.generate_obstacles","title":"<code>generate_obstacles(robot_pose, distances)</code>","text":"<p>Update obstacles list from lidar data.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def generate_obstacles(self, robot_pose: models.Pose, distances: list[int]) -&gt; list[models.Vertex]:\n    \"\"\"\n    Update obstacles list from lidar data.\n    \"\"\"\n    obstacles: list[models.Vertex] = []\n\n    for angle, distance in enumerate(distances):\n        if (\n            distance &lt; self.properties.min_distance\n            or distance &gt;= self.properties.max_distance - self.properties.beacon_radius\n        ):\n            continue\n\n        angle = (360 - angle) % 360\n\n        # Compute obstacle position\n        obstacle_angle = math.radians((int(robot_pose.O) + angle) % 360)\n        x = robot_pose.x + distance * math.cos(obstacle_angle)\n        y = robot_pose.y + distance * math.sin(obstacle_angle)\n\n        obstacles.append(models.Vertex(x=x, y=y))\n\n    return obstacles\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.process_lidar_data","title":"<code>process_lidar_data()</code>","text":"<p>Function executed in a thread loop to update and send dynamic obstacles.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def process_lidar_data(self):\n    \"\"\"\n    Function executed in a thread loop to update and send dynamic obstacles.\n    \"\"\"\n    with self._lidar_data_lock:\n        filtered_distances = self.filter_distances()\n    with self._robot_pose_lock:\n        robot_pose = self.robot_pose.model_copy()\n\n    obstacles = self.generate_obstacles(robot_pose, filtered_distances)\n    logger.debug(f\"Generated obstacles: {obstacles}\")\n    if self._sio.connected:\n        self._sio.emit(\"obstacles\", [o.model_dump(exclude_defaults=True) for o in obstacles], namespace=\"/detector\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.read_lidar","title":"<code>read_lidar()</code>","text":"<p>Function executed in a thread loop to read Lidar data.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def read_lidar(self):\n    \"\"\"\n    Function executed in a thread loop to read Lidar data.\n    \"\"\"\n    if not ydlidar.os_isOk():\n        return\n\n    ret = self._laser.doProcessSimple(self._scan)\n    if ret:\n        tmp_distances = [[] for _ in range(360)]\n        result = []\n\n        # Build a list of points for each integer degree\n        for point in self._scan.points:\n            angle_sym = math.floor(math.degrees(point.angle))\n            angle = angle_sym if angle_sym &gt;= 0 else angle_sym + 360\n            if 0 &lt;= angle &lt; 360 and point.range &gt; 0.0:\n                tmp_distances[angle].append(point.range)\n\n        # Compute mean of points list for each degree.\n        empty_angles = []\n        for angle, distances in enumerate(tmp_distances):\n            distance = self.properties.max_distance - self.properties.beacon_radius\n            if size := len(distances):\n                distance = round(sum(distances) * 1000 / size)\n            else:\n                empty_angles.append(angle)\n\n            result.append(distance + self.properties.beacon_radius)\n\n        # If a degree has no valid point and is isolated (no other empty angle before and after)\n        # it is probably a bad value, so set it to the mean of surrounding degrees.\n        for group in consecutive_groups(empty_angles):\n            g = list(group)\n            if len(g) == 1:\n                isolated = g[0]\n                before = result[(isolated - 1) % 360]\n                after = result[(isolated + 1) % 360]\n                result[isolated] = round((before + after) / 2)\n\n        self.update_lidar_data(result)\n    else:\n        print(\"Failed to get Lidar Data\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start","title":"<code>start()</code>","text":"<p>Start updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start updating obstacles list.\n    \"\"\"\n    self._obstacles_updater_loop.start()\n    if self._laser:\n        self._lidar_reader_loop.start()\n        self.start_lidar()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.start_lidar","title":"<code>start_lidar()</code>","text":"<p>Start the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def start_lidar(self):\n    \"\"\"\n    Start the Lidar.\n    \"\"\"\n    if self._laser:\n        self._laser.initialize()\n        self._laser.turnOn()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop","title":"<code>stop()</code>","text":"<p>Stop updating obstacles list.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop updating obstacles list.\n    \"\"\"\n    self._obstacles_updater_loop.stop()\n    if self._laser:\n        self._lidar_reader_loop.stop()\n        self.stop_lidar()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.stop_lidar","title":"<code>stop_lidar()</code>","text":"<p>Stop the Lidar.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def stop_lidar(self):\n    \"\"\"\n    Stop the Lidar.\n    \"\"\"\n    if self._laser:\n        self._laser.turnOff()\n        self._laser.disconnecting()\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.try_connect","title":"<code>try_connect()</code>","text":"<p>Poll to wait for the first cogip-server connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def try_connect(self):\n    \"\"\"\n    Poll to wait for the first cogip-server connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while True:\n        try:\n            self._sio.connect(\n                self._server_url,\n                namespaces=[\"/detector\"],\n            )\n            self._sio.wait()\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/detector/detector/#cogip.tools.detector.detector.Detector.update_lidar_data","title":"<code>update_lidar_data(lidar_data)</code>","text":"<p>Receive Lidar data.</p> Source code in <code>cogip/tools/detector/detector.py</code> <pre><code>def update_lidar_data(self, lidar_data: list[int]):\n    \"\"\"\n    Receive Lidar data.\n    \"\"\"\n    with self._lidar_data_lock:\n        self._lidar_data[:] = lidar_data[:]\n</code></pre>"},{"location":"reference/cogip/tools/detector/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/detector/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/detector/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>ClientNamespace</code></p> <p>Handle all SocketIO events received by Detector.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>class SioEvents(socketio.ClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Detector.\n    \"\"\"\n\n    def __init__(self, detector: \"detector.Detector\"):\n        super().__init__(\"/detector\")\n        self._detector = detector\n\n    def on_connect(self):\n        \"\"\"\n        On connection to cogip-server, start detector threads.\n        \"\"\"\n        polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Connected to cogip-server\")\n        self.emit(\"connected\")\n        self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n        self._detector.start()\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server, stop detector threads.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self._detector.stop()\n\n    def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Detector is already connected and exit,\n        or retry connection.\n        \"\"\"\n        logger.error(f\"Connect to cogip-server error: {data = }\")\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A detector is already connected\"\n        ):\n            logger.error(message)\n            self._detector.retry_connection = False\n            return\n\n    def on_command(self, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema = self._detector.properties.model_json_schema()\n            # Add namespace in JSON Schema\n            schema[\"namespace\"] = \"/detector\"\n            # Add current values in JSON Schema\n            for prop, value in self._detector.properties.model_dump().items():\n                schema[\"properties\"][prop][\"value\"] = value\n            # Send config\n            self.emit(\"config\", schema)\n        else:\n            logger.warning(f\"Unknown command: {cmd}\")\n\n    def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        self._detector.properties.__setattr__(name := config[\"name\"], config[\"value\"])\n        if name == \"refresh_interval\":\n            self._detector.update_refresh_interval()\n\n    def on_pose_current(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot pose message.\n        \"\"\"\n        self._detector.robot_pose = models.Pose.model_validate(data)\n\n    def on_sensors_data(self, data: list[int]) -&gt; None:\n        \"\"\"\n        Callback on Lidar data.\n        \"\"\"\n        logger.debug(\"Received lidar data\")\n        self._detector.properties.beacon_radius\n        self._detector.update_lidar_data([d + self._detector.properties.beacon_radius for d in data])\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_command","title":"<code>on_command(cmd)</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_command(self, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema = self._detector.properties.model_json_schema()\n        # Add namespace in JSON Schema\n        schema[\"namespace\"] = \"/detector\"\n        # Add current values in JSON Schema\n        for prop, value in self._detector.properties.model_dump().items():\n            schema[\"properties\"][prop][\"value\"] = value\n        # Send config\n        self.emit(\"config\", schema)\n    else:\n        logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>","text":"<p>On connection to cogip-server, start detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect(self):\n    \"\"\"\n    On connection to cogip-server, start detector threads.\n    \"\"\"\n    polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n    logger.info(\"Connected to cogip-server\")\n    self.emit(\"connected\")\n    self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n    self._detector.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>","text":"<p>On connection error, check if a Detector is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Detector is already connected and exit,\n    or retry connection.\n    \"\"\"\n    logger.error(f\"Connect to cogip-server error: {data = }\")\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A detector is already connected\"\n    ):\n        logger.error(message)\n        self._detector.retry_connection = False\n        return\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server, stop detector threads.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server, stop detector threads.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self._detector.stop()\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_pose_current","title":"<code>on_pose_current(data)</code>","text":"<p>Callback on robot pose message.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_pose_current(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on robot pose message.\n    \"\"\"\n    self._detector.robot_pose = models.Pose.model_validate(data)\n</code></pre>"},{"location":"reference/cogip/tools/detector/sio_events/#cogip.tools.detector.sio_events.SioEvents.on_sensors_data","title":"<code>on_sensors_data(data)</code>","text":"<p>Callback on Lidar data.</p> Source code in <code>cogip/tools/detector/sio_events.py</code> <pre><code>def on_sensors_data(self, data: list[int]) -&gt; None:\n    \"\"\"\n    Callback on Lidar data.\n    \"\"\"\n    logger.debug(\"Received lidar data\")\n    self._detector.properties.beacon_radius\n    self._detector.update_lidar_data([d + self._detector.properties.beacon_radius for d in data])\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/detector_pami/__main__/#cogip.tools.detector_pami.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP PAMI Obstacle Detector.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-detector-pami</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/detector_pami/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP PAMI Obstacle Detector.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-detector-pami` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector","title":"<code>Detector</code>","text":"<p>Main detector class.</p> <p>Read data from the ToF in monitoring mode or fake data provided by <code>Monitor</code> in emulation Mode.</p> <p>Build obstacles and send the list to the server.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>class Detector:\n    \"\"\"\n    Main detector class.\n\n    Read data from the ToF in monitoring mode\n    or fake data provided by `Monitor` in emulation Mode.\n\n    Build obstacles and send the list to the server.\n    \"\"\"\n\n    def __init__(\n        self,\n        server_url: str,\n        tof_bus: int | None,\n        tof_address: int | None,\n        min_distance: int,\n        max_distance: int,\n        refresh_interval: float,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            server_url: server URL\n            tof_bus: ToF i2c bus\n            tof_address: ToF i2c address\n            min_distance: Minimum distance to detect an obstacle\n            max_distance: Maximum distance to detect an obstacle\n            refresh_interval: Interval between each update of the obstacle list (in seconds)\n        \"\"\"\n        self.server_url = server_url\n        self.tof_bus = tof_bus\n        self.tof_address = tof_address\n        self.properties = Properties(\n            min_distance=min_distance,\n            max_distance=max_distance,\n            refresh_interval=refresh_interval,\n        )\n        self.sensor: VL53L1X | None = None\n        self.sensors_data: list[int] = list()\n        self.sensors_data_lock = threading.Lock()\n        self._robot_pose = models.Pose()\n        self.robot_pose_lock = threading.Lock()\n\n        self.obstacles_updater_loop = ThreadLoop(\n            \"Obstacles updater loop\",\n            refresh_interval,\n            self.process_sensor_data,\n            logger=True,\n        )\n\n        self.sensor_reader_loop = ThreadLoop(\n            \"Sensor reader loop\",\n            refresh_interval,\n            self.read_sensors,\n            logger=True,\n        )\n\n        self.init_sensor()\n\n        self.sio = socketio.Client(logger=False)\n        self.sio.register_namespace(SioEvents(self))\n\n    def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        threading.Thread(target=self.try_connect).start()\n\n    def init_sensor(self):\n        if self.tof_bus and self.tof_address:\n            self.sensor = VL53L1X(i2c_bus=self.tof_bus, i2c_address=self.tof_address)\n            self.sensor.open(reset=True)\n\n    def start(self):\n        \"\"\"\n        Start updating obstacles list.\n        \"\"\"\n        self.obstacles_updater_loop.start()\n        if self.sensor:\n            self.sensor_reader_loop.start()\n            self.start_sensors()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop updating obstacles list.\n        \"\"\"\n        self.obstacles_updater_loop.stop()\n        if self.sensor:\n            self.sensor_reader_loop.stop()\n            self.stop_sensors()\n\n    def try_connect(self):\n        \"\"\"\n        Poll to wait for the first cogip-server connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while True:\n            try:\n                self.sio.connect(\n                    self.server_url,\n                    namespaces=[\"/detector\"],\n                )\n                self.sio.wait()\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    @property\n    def robot_pose(self) -&gt; models.Pose:\n        \"\"\"\n        Last position of the robot.\n        \"\"\"\n        return self._robot_pose\n\n    @robot_pose.setter\n    def robot_pose(self, new_pose: models.Pose) -&gt; None:\n        with self.robot_pose_lock:\n            self._robot_pose = new_pose\n\n    def update_refresh_interval(self) -&gt; None:\n        self.obstacles_updater_loop.interval = self.properties.refresh_interval\n        self.sensor_reader_loop.interval = self.properties.refresh_interval\n\n    def update_sensors_data(self, sensors_data: list[int]):\n        \"\"\"\n        Receive sensors data.\n        \"\"\"\n        with self.sensors_data_lock:\n            self.sensors_data[:] = sensors_data[:]\n\n    def filter_distances(self) -&gt; list[int]:\n        \"\"\"\n        Nothing to do with ToF sensors of PAMI.\n        Just keep the function for API compatibility.\n        \"\"\"\n        return self.sensors_data\n\n    def generate_obstacles(self, robot_pose: models.Pose, distances: list[int]) -&gt; list[models.Vertex]:\n        \"\"\"\n        Update obstacles list from sensors data.\n        \"\"\"\n        if len(distances) == 0:\n            return []\n\n        distance = distances[0]\n        if distance &lt; self.properties.min_distance or distance &gt;= self.properties.max_distance:\n            return []\n\n        # Compute obstacle position\n        angle = math.radians(robot_pose.O)\n        x = robot_pose.x + distance * math.cos(angle)\n        y = robot_pose.y + distance * math.sin(angle)\n\n        return [models.Vertex(x=x, y=y)]\n\n    def process_sensor_data(self):\n        \"\"\"\n        Function executed in a thread loop to update and send dynamic obstacles.\n        \"\"\"\n        with self.sensors_data_lock:\n            filtered_distances = self.filter_distances()\n        with self.robot_pose_lock:\n            robot_pose = self.robot_pose.model_copy()\n\n        obstacles = self.generate_obstacles(robot_pose, filtered_distances)\n        logger.debug(f\"Generated obstacles: {obstacles}\")\n        if self.sio.connected:\n            self.sio.emit(\"obstacles\", [o.model_dump(exclude_defaults=True) for o in obstacles], namespace=\"/detector\")\n\n    def start_sensors(self):\n        \"\"\"\n        Start sensors.\n        \"\"\"\n        if self.sensor:\n            self.sensor.start_ranging(mode=VL53L1xDistanceMode.LONG)\n            self.sensor.set_timing(150, 200)\n\n    def read_sensors(self):\n        \"\"\"\n        Function executed in a thread loop to read sensors data.\n        \"\"\"\n        if not self.sensor:\n            return\n\n        self.update_sensors_data([self.sensor.get_distance()])\n\n    def stop_sensors(self):\n        \"\"\"\n        Stop sensors.\n        \"\"\"\n        if self.sensor:\n            self.sensor.stop_ranging()\n            self.sensor.close()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.robot_pose","title":"<code>robot_pose: models.Pose</code>  <code>property</code> <code>writable</code>","text":"<p>Last position of the robot.</p>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.__init__","title":"<code>__init__(server_url, tof_bus, tof_address, min_distance, max_distance, refresh_interval)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>server_url</code> <code>str</code> <p>server URL</p> required <code>tof_bus</code> <code>int | None</code> <p>ToF i2c bus</p> required <code>tof_address</code> <code>int | None</code> <p>ToF i2c address</p> required <code>min_distance</code> <code>int</code> <p>Minimum distance to detect an obstacle</p> required <code>max_distance</code> <code>int</code> <p>Maximum distance to detect an obstacle</p> required <code>refresh_interval</code> <code>float</code> <p>Interval between each update of the obstacle list (in seconds)</p> required Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def __init__(\n    self,\n    server_url: str,\n    tof_bus: int | None,\n    tof_address: int | None,\n    min_distance: int,\n    max_distance: int,\n    refresh_interval: float,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        server_url: server URL\n        tof_bus: ToF i2c bus\n        tof_address: ToF i2c address\n        min_distance: Minimum distance to detect an obstacle\n        max_distance: Maximum distance to detect an obstacle\n        refresh_interval: Interval between each update of the obstacle list (in seconds)\n    \"\"\"\n    self.server_url = server_url\n    self.tof_bus = tof_bus\n    self.tof_address = tof_address\n    self.properties = Properties(\n        min_distance=min_distance,\n        max_distance=max_distance,\n        refresh_interval=refresh_interval,\n    )\n    self.sensor: VL53L1X | None = None\n    self.sensors_data: list[int] = list()\n    self.sensors_data_lock = threading.Lock()\n    self._robot_pose = models.Pose()\n    self.robot_pose_lock = threading.Lock()\n\n    self.obstacles_updater_loop = ThreadLoop(\n        \"Obstacles updater loop\",\n        refresh_interval,\n        self.process_sensor_data,\n        logger=True,\n    )\n\n    self.sensor_reader_loop = ThreadLoop(\n        \"Sensor reader loop\",\n        refresh_interval,\n        self.read_sensors,\n        logger=True,\n    )\n\n    self.init_sensor()\n\n    self.sio = socketio.Client(logger=False)\n    self.sio.register_namespace(SioEvents(self))\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.connect","title":"<code>connect()</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    threading.Thread(target=self.try_connect).start()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.filter_distances","title":"<code>filter_distances()</code>","text":"<p>Nothing to do with ToF sensors of PAMI. Just keep the function for API compatibility.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def filter_distances(self) -&gt; list[int]:\n    \"\"\"\n    Nothing to do with ToF sensors of PAMI.\n    Just keep the function for API compatibility.\n    \"\"\"\n    return self.sensors_data\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.generate_obstacles","title":"<code>generate_obstacles(robot_pose, distances)</code>","text":"<p>Update obstacles list from sensors data.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def generate_obstacles(self, robot_pose: models.Pose, distances: list[int]) -&gt; list[models.Vertex]:\n    \"\"\"\n    Update obstacles list from sensors data.\n    \"\"\"\n    if len(distances) == 0:\n        return []\n\n    distance = distances[0]\n    if distance &lt; self.properties.min_distance or distance &gt;= self.properties.max_distance:\n        return []\n\n    # Compute obstacle position\n    angle = math.radians(robot_pose.O)\n    x = robot_pose.x + distance * math.cos(angle)\n    y = robot_pose.y + distance * math.sin(angle)\n\n    return [models.Vertex(x=x, y=y)]\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.process_sensor_data","title":"<code>process_sensor_data()</code>","text":"<p>Function executed in a thread loop to update and send dynamic obstacles.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def process_sensor_data(self):\n    \"\"\"\n    Function executed in a thread loop to update and send dynamic obstacles.\n    \"\"\"\n    with self.sensors_data_lock:\n        filtered_distances = self.filter_distances()\n    with self.robot_pose_lock:\n        robot_pose = self.robot_pose.model_copy()\n\n    obstacles = self.generate_obstacles(robot_pose, filtered_distances)\n    logger.debug(f\"Generated obstacles: {obstacles}\")\n    if self.sio.connected:\n        self.sio.emit(\"obstacles\", [o.model_dump(exclude_defaults=True) for o in obstacles], namespace=\"/detector\")\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.read_sensors","title":"<code>read_sensors()</code>","text":"<p>Function executed in a thread loop to read sensors data.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def read_sensors(self):\n    \"\"\"\n    Function executed in a thread loop to read sensors data.\n    \"\"\"\n    if not self.sensor:\n        return\n\n    self.update_sensors_data([self.sensor.get_distance()])\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.start","title":"<code>start()</code>","text":"<p>Start updating obstacles list.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def start(self):\n    \"\"\"\n    Start updating obstacles list.\n    \"\"\"\n    self.obstacles_updater_loop.start()\n    if self.sensor:\n        self.sensor_reader_loop.start()\n        self.start_sensors()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.start_sensors","title":"<code>start_sensors()</code>","text":"<p>Start sensors.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def start_sensors(self):\n    \"\"\"\n    Start sensors.\n    \"\"\"\n    if self.sensor:\n        self.sensor.start_ranging(mode=VL53L1xDistanceMode.LONG)\n        self.sensor.set_timing(150, 200)\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.stop","title":"<code>stop()</code>","text":"<p>Stop updating obstacles list.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop updating obstacles list.\n    \"\"\"\n    self.obstacles_updater_loop.stop()\n    if self.sensor:\n        self.sensor_reader_loop.stop()\n        self.stop_sensors()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.stop_sensors","title":"<code>stop_sensors()</code>","text":"<p>Stop sensors.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def stop_sensors(self):\n    \"\"\"\n    Stop sensors.\n    \"\"\"\n    if self.sensor:\n        self.sensor.stop_ranging()\n        self.sensor.close()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.try_connect","title":"<code>try_connect()</code>","text":"<p>Poll to wait for the first cogip-server connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def try_connect(self):\n    \"\"\"\n    Poll to wait for the first cogip-server connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while True:\n        try:\n            self.sio.connect(\n                self.server_url,\n                namespaces=[\"/detector\"],\n            )\n            self.sio.wait()\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/detector/#cogip.tools.detector_pami.detector.Detector.update_sensors_data","title":"<code>update_sensors_data(sensors_data)</code>","text":"<p>Receive sensors data.</p> Source code in <code>cogip/tools/detector_pami/detector.py</code> <pre><code>def update_sensors_data(self, sensors_data: list[int]):\n    \"\"\"\n    Receive sensors data.\n    \"\"\"\n    with self.sensors_data_lock:\n        self.sensors_data[:] = sensors_data[:]\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/detector_pami/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/detector_pami/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>ClientNamespace</code></p> <p>Handle all SocketIO events received by Detector.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>class SioEvents(socketio.ClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Detector.\n    \"\"\"\n\n    def __init__(self, detector: \"detector.Detector\"):\n        super().__init__(\"/detector\")\n        self._detector = detector\n\n    def on_connect(self):\n        \"\"\"\n        On connection to cogip-server, start detector threads.\n        \"\"\"\n        polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Connected to cogip-server\")\n        self.emit(\"connected\")\n        self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n        self._detector.start()\n\n    def on_disconnect(self) -&gt; None:\n        \"\"\"\n        On disconnection from cogip-server, stop detector threads.\n        \"\"\"\n        logger.info(\"Disconnected from cogip-server\")\n        self._detector.stop()\n\n    def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        On connection error, check if a Detector is already connected and exit,\n        or retry connection.\n        \"\"\"\n        logger.error(f\"Connect to cogip-server error: {data = }\")\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A detector is already connected\"\n        ):\n            logger.error(message)\n            self._detector.retry_connection = False\n            return\n\n    def on_command(self, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema = self._detector.properties.model_json_schema()\n            # Add namespace in JSON Schema\n            schema[\"namespace\"] = \"/detector\"\n            # Add current values in JSON Schema\n            for prop, value in self._detector.properties.model_dump().items():\n                schema[\"properties\"][prop][\"value\"] = value\n            # Send config\n            self.emit(\"config\", schema)\n        else:\n            logger.warning(f\"Unknown command: {cmd}\")\n\n    def on_config_updated(self, config: dict[str, Any]) -&gt; None:\n        self._detector.properties.__setattr__(name := config[\"name\"], config[\"value\"])\n        if name == \"refresh_interval\":\n            self._detector.update_refresh_interval()\n\n    def on_pose_current(self, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot pose message.\n        \"\"\"\n        self._detector.robot_pose = models.Pose.model_validate(data)\n\n    def on_sensors_data(self, data: list[int]) -&gt; None:\n        \"\"\"\n        Callback on sensors data.\n        \"\"\"\n        logger.debug(\"Received sensors data\")\n        self._detector.update_sensors_data(data)\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_command","title":"<code>on_command(cmd)</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_command(self, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema = self._detector.properties.model_json_schema()\n        # Add namespace in JSON Schema\n        schema[\"namespace\"] = \"/detector\"\n        # Add current values in JSON Schema\n        for prop, value in self._detector.properties.model_dump().items():\n            schema[\"properties\"][prop][\"value\"] = value\n        # Send config\n        self.emit(\"config\", schema)\n    else:\n        logger.warning(f\"Unknown command: {cmd}\")\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>","text":"<p>On connection to cogip-server, start detector threads.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_connect(self):\n    \"\"\"\n    On connection to cogip-server, start detector threads.\n    \"\"\"\n    polling2.poll(lambda: self.client.connected is True, step=0.2, poll_forever=True)\n    logger.info(\"Connected to cogip-server\")\n    self.emit(\"connected\")\n    self.emit(\"register_menu\", {\"name\": \"detector\", \"menu\": menu.model_dump()})\n    self._detector.start()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>","text":"<p>On connection error, check if a Detector is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_connect_error(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    On connection error, check if a Detector is already connected and exit,\n    or retry connection.\n    \"\"\"\n    logger.error(f\"Connect to cogip-server error: {data = }\")\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A detector is already connected\"\n    ):\n        logger.error(message)\n        self._detector.retry_connection = False\n        return\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>","text":"<p>On disconnection from cogip-server, stop detector threads.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_disconnect(self) -&gt; None:\n    \"\"\"\n    On disconnection from cogip-server, stop detector threads.\n    \"\"\"\n    logger.info(\"Disconnected from cogip-server\")\n    self._detector.stop()\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_pose_current","title":"<code>on_pose_current(data)</code>","text":"<p>Callback on robot pose message.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_pose_current(self, data: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Callback on robot pose message.\n    \"\"\"\n    self._detector.robot_pose = models.Pose.model_validate(data)\n</code></pre>"},{"location":"reference/cogip/tools/detector_pami/sio_events/#cogip.tools.detector_pami.sio_events.SioEvents.on_sensors_data","title":"<code>on_sensors_data(data)</code>","text":"<p>Callback on sensors data.</p> Source code in <code>cogip/tools/detector_pami/sio_events.py</code> <pre><code>def on_sensors_data(self, data: list[int]) -&gt; None:\n    \"\"\"\n    Callback on sensors data.\n    \"\"\"\n    logger.debug(\"Received sensors data\")\n    self._detector.update_sensors_data(data)\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/lidarusb/dataproxy/","title":"dataproxy","text":""},{"location":"reference/cogip/tools/lidarusb/dataproxy/#cogip.tools.lidarusb.dataproxy.DataProxy","title":"<code>DataProxy</code>","text":"<p>               Bases: <code>QObject</code></p> <p>DataProxy class</p> <p>Receive points from the Lidar, store them et send them to the data model.</p> <p>Attributes:</p> Name Type Description <code>update_data</code> <code>Signal</code> <p>Qt signal emitted when new points are available</p> Source code in <code>cogip/tools/lidarusb/dataproxy.py</code> <pre><code>class DataProxy(QtCore.QObject):\n    \"\"\"DataProxy class\n\n    Receive points from the Lidar, store them et send them to the data model.\n\n    Attributes:\n        update_data: Qt signal emitted when new points are available\n    \"\"\"\n\n    update_data: qtSignal = qtSignal()\n\n    def __init__(\n        self,\n        angle_values: list[int],\n        distance_values: list[int],\n        intensity_values: list[int],\n    ):\n        \"\"\"Class constructor\n\n        Arguments:\n            angle_values: angle list to update\n            distance_values: distance list to update\n            intensity_values: intensity list to update\n        \"\"\"\n        super().__init__()\n        self.angle_values = angle_values\n        self.distance_values = distance_values\n        self.intensity_values = intensity_values\n        self.filter = 0\n\n    def set_filter(self, filter: int):\n        \"\"\"\n        Qt Slot\n\n        Set filter.\n\n        Arguments:\n            filter: new filter\n        \"\"\"\n        self.filter = filter\n\n    def filter_distance(self, distance: int, intensity: int) -&gt; int:\n        \"\"\"\n        Compute the filtered distance based on current raw distance, intensity and filter.\n\n        Arguments:\n            distance: current raw distance\n            intensity: current intensity\n        \"\"\"\n        if self.filter == 0:\n            return distance\n        if intensity == 0:\n            return self.filter\n        if 0 &lt; distance &lt;= self.filter:\n            return distance\n        return self.filter\n\n    def new_data(self, points: list[tuple[float, int, int]]) -&gt; None:\n        \"\"\"\n        Get new list of points.\n\n        Arguments:\n            points: new points\n        \"\"\"\n        for i, (angle, distance, intensity) in enumerate(points):\n            self.angle_values[i] = angle\n            self.distance_values[i] = self.filter_distance(distance, intensity)\n            self.intensity_values[i] = intensity\n            self.update_data.emit()\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/dataproxy/#cogip.tools.lidarusb.dataproxy.DataProxy.__init__","title":"<code>__init__(angle_values, distance_values, intensity_values)</code>","text":"<p>Class constructor</p> <p>Parameters:</p> Name Type Description Default <code>angle_values</code> <code>list[int]</code> <p>angle list to update</p> required <code>distance_values</code> <code>list[int]</code> <p>distance list to update</p> required <code>intensity_values</code> <code>list[int]</code> <p>intensity list to update</p> required Source code in <code>cogip/tools/lidarusb/dataproxy.py</code> <pre><code>def __init__(\n    self,\n    angle_values: list[int],\n    distance_values: list[int],\n    intensity_values: list[int],\n):\n    \"\"\"Class constructor\n\n    Arguments:\n        angle_values: angle list to update\n        distance_values: distance list to update\n        intensity_values: intensity list to update\n    \"\"\"\n    super().__init__()\n    self.angle_values = angle_values\n    self.distance_values = distance_values\n    self.intensity_values = intensity_values\n    self.filter = 0\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/dataproxy/#cogip.tools.lidarusb.dataproxy.DataProxy.filter_distance","title":"<code>filter_distance(distance, intensity)</code>","text":"<p>Compute the filtered distance based on current raw distance, intensity and filter.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>int</code> <p>current raw distance</p> required <code>intensity</code> <code>int</code> <p>current intensity</p> required Source code in <code>cogip/tools/lidarusb/dataproxy.py</code> <pre><code>def filter_distance(self, distance: int, intensity: int) -&gt; int:\n    \"\"\"\n    Compute the filtered distance based on current raw distance, intensity and filter.\n\n    Arguments:\n        distance: current raw distance\n        intensity: current intensity\n    \"\"\"\n    if self.filter == 0:\n        return distance\n    if intensity == 0:\n        return self.filter\n    if 0 &lt; distance &lt;= self.filter:\n        return distance\n    return self.filter\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/dataproxy/#cogip.tools.lidarusb.dataproxy.DataProxy.new_data","title":"<code>new_data(points)</code>","text":"<p>Get new list of points.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple[float, int, int]]</code> <p>new points</p> required Source code in <code>cogip/tools/lidarusb/dataproxy.py</code> <pre><code>def new_data(self, points: list[tuple[float, int, int]]) -&gt; None:\n    \"\"\"\n    Get new list of points.\n\n    Arguments:\n        points: new points\n    \"\"\"\n    for i, (angle, distance, intensity) in enumerate(points):\n        self.angle_values[i] = angle\n        self.distance_values[i] = self.filter_distance(distance, intensity)\n        self.intensity_values[i] = intensity\n        self.update_data.emit()\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/dataproxy/#cogip.tools.lidarusb.dataproxy.DataProxy.set_filter","title":"<code>set_filter(filter)</code>","text":"<p>Qt Slot</p> <p>Set filter.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>int</code> <p>new filter</p> required Source code in <code>cogip/tools/lidarusb/dataproxy.py</code> <pre><code>def set_filter(self, filter: int):\n    \"\"\"\n    Qt Slot\n\n    Set filter.\n\n    Arguments:\n        filter: new filter\n    \"\"\"\n    self.filter = filter\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/lidar/","title":"lidar","text":""},{"location":"reference/cogip/tools/lidarusb/lidar/#cogip.tools.lidarusb.lidar.Lidar","title":"<code>Lidar</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Handle the Lidar device (YDLidar G2), start and stop the Lidar, read, filter and send data. It runs in its own thread.</p> <p>Attributes:</p> Name Type Description <code>signal_new_data</code> <code>Signal</code> <p>Qt signal emitted when a new frame is available</p> Source code in <code>cogip/tools/lidarusb/lidar.py</code> <pre><code>class Lidar(QtCore.QObject):\n    \"\"\"\n    Handle the Lidar device (YDLidar G2), start and stop the Lidar,\n    read, filter and send data.\n    It runs in its own thread.\n\n    Attributes:\n        signal_new_data:\n            Qt signal emitted when a new frame is available\n    \"\"\"\n\n    signal_new_data: qtSignal = qtSignal(bytes)\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Discover Lidar serial port, set Lidar options.\n        \"\"\"\n        super().__init__()\n        self._exiting = False\n        self._intensity_threshold = 0\n        ydlidar.os_init()\n        for _, value in ydlidar.lidarPortList().items():\n            port = value\n        self._laser = ydlidar.CYdLidar()\n        self._laser.setlidaropt(ydlidar.LidarPropSerialPort, port)\n        self._laser.setlidaropt(ydlidar.LidarPropSerialBaudrate, 230400)\n        self._laser.setlidaropt(ydlidar.LidarPropLidarType, ydlidar.TYPE_TRIANGLE)\n        self._laser.setlidaropt(ydlidar.LidarPropDeviceType, ydlidar.YDLIDAR_TYPE_SERIAL)\n        self._laser.setlidaropt(ydlidar.LidarPropSingleChannel, False)\n        self._laser.setlidaropt(ydlidar.LidarPropSampleRate, 5)\n        self._laser.setlidaropt(ydlidar.LidarPropIntenstiy, True)\n        self._laser.setlidaropt(ydlidar.LidarPropScanFrequency, 5.0)\n        self._laser.setlidaropt(ydlidar.LidarPropMaxRange, 16)\n        self._laser.setlidaropt(ydlidar.LidarPropMinRange, 0.12)\n        self._laser.setlidaropt(ydlidar.LidarPropInverted, False)  # clockwise (default)\n        self._laser.setlidaropt(ydlidar.LidarPropFixedResolution, False)\n\n    def quit(self):\n        \"\"\"\n        Request to exit the thread as soon as possible.\n        \"\"\"\n        self._exiting = True\n\n    def set_intensity_threshold(self, threshold: int):\n        \"\"\"\n        Set new intensity threshold.\n        \"\"\"\n        self._intensity_threshold = threshold\n\n    def process_points(self):\n        \"\"\"\n        Read Lidar data, filter and send them to display.\n        This is the thread loop.\n        \"\"\"\n        self._laser.initialize()\n        self._laser.turnOn()\n\n        scan = ydlidar.LaserScan()\n        while not self._exiting and ydlidar.os_isOk():\n            ret = self._laser.doProcessSimple(scan)\n            if ret:\n                tmp_distances = [[] for _ in range(360)]\n                tmp_intensities = [[] for _ in range(360)]\n                result = []\n\n                # Build a list of points for each integer degree\n                for point in scan.points:\n                    angle = round(math.degrees(point.angle))\n                    if -180 &lt;= angle &lt; 180 and point.range &gt; 0.0:\n                        tmp_distances[angle + 180].append(point.range)\n                        tmp_intensities[angle + 180].append(point.intensity)\n\n                # Compute mean of points list for each degree.\n                empty_angles = []\n                for angle, (distances, intensities) in enumerate(zip(tmp_distances, tmp_intensities)):\n                    distance = 4500\n                    intensity = 1024\n                    if size := len(distances):\n                        distance = round(sum(distances) * 1000 / size)\n                        intensity = int(sum(intensities) / size)\n                    else:\n                        empty_angles.append(angle)\n\n                    result.append((angle - 180, distance, intensity))\n\n                # If a degree has no valid point and is isolated (no other empty angle before and after)\n                # it is probably a bad value, so set it to the mean of surrounding degrees.\n                for group in consecutive_groups(empty_angles):\n                    g = list(group)\n                    if len(g) == 1:\n                        index = g[0]\n                        isolated = result[index]\n                        before = result[(index - 1) % 360]\n                        after = result[(index + 1) % 360]\n                        result[index] = (\n                            isolated[0],\n                            round((before[1] + after[1]) / 2),\n                            round((before[2] + after[2]) / 2),\n                        )\n\n                self.signal_new_data.emit(result)\n            else:\n                print(\"Failed to get Lidar Data\")\n\n            time.sleep(0.5)\n\n        self._laser.turnOff()\n        self._laser.disconnecting()\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/lidar/#cogip.tools.lidarusb.lidar.Lidar.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Discover Lidar serial port, set Lidar options.</p> Source code in <code>cogip/tools/lidarusb/lidar.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Discover Lidar serial port, set Lidar options.\n    \"\"\"\n    super().__init__()\n    self._exiting = False\n    self._intensity_threshold = 0\n    ydlidar.os_init()\n    for _, value in ydlidar.lidarPortList().items():\n        port = value\n    self._laser = ydlidar.CYdLidar()\n    self._laser.setlidaropt(ydlidar.LidarPropSerialPort, port)\n    self._laser.setlidaropt(ydlidar.LidarPropSerialBaudrate, 230400)\n    self._laser.setlidaropt(ydlidar.LidarPropLidarType, ydlidar.TYPE_TRIANGLE)\n    self._laser.setlidaropt(ydlidar.LidarPropDeviceType, ydlidar.YDLIDAR_TYPE_SERIAL)\n    self._laser.setlidaropt(ydlidar.LidarPropSingleChannel, False)\n    self._laser.setlidaropt(ydlidar.LidarPropSampleRate, 5)\n    self._laser.setlidaropt(ydlidar.LidarPropIntenstiy, True)\n    self._laser.setlidaropt(ydlidar.LidarPropScanFrequency, 5.0)\n    self._laser.setlidaropt(ydlidar.LidarPropMaxRange, 16)\n    self._laser.setlidaropt(ydlidar.LidarPropMinRange, 0.12)\n    self._laser.setlidaropt(ydlidar.LidarPropInverted, False)  # clockwise (default)\n    self._laser.setlidaropt(ydlidar.LidarPropFixedResolution, False)\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/lidar/#cogip.tools.lidarusb.lidar.Lidar.process_points","title":"<code>process_points()</code>","text":"<p>Read Lidar data, filter and send them to display. This is the thread loop.</p> Source code in <code>cogip/tools/lidarusb/lidar.py</code> <pre><code>def process_points(self):\n    \"\"\"\n    Read Lidar data, filter and send them to display.\n    This is the thread loop.\n    \"\"\"\n    self._laser.initialize()\n    self._laser.turnOn()\n\n    scan = ydlidar.LaserScan()\n    while not self._exiting and ydlidar.os_isOk():\n        ret = self._laser.doProcessSimple(scan)\n        if ret:\n            tmp_distances = [[] for _ in range(360)]\n            tmp_intensities = [[] for _ in range(360)]\n            result = []\n\n            # Build a list of points for each integer degree\n            for point in scan.points:\n                angle = round(math.degrees(point.angle))\n                if -180 &lt;= angle &lt; 180 and point.range &gt; 0.0:\n                    tmp_distances[angle + 180].append(point.range)\n                    tmp_intensities[angle + 180].append(point.intensity)\n\n            # Compute mean of points list for each degree.\n            empty_angles = []\n            for angle, (distances, intensities) in enumerate(zip(tmp_distances, tmp_intensities)):\n                distance = 4500\n                intensity = 1024\n                if size := len(distances):\n                    distance = round(sum(distances) * 1000 / size)\n                    intensity = int(sum(intensities) / size)\n                else:\n                    empty_angles.append(angle)\n\n                result.append((angle - 180, distance, intensity))\n\n            # If a degree has no valid point and is isolated (no other empty angle before and after)\n            # it is probably a bad value, so set it to the mean of surrounding degrees.\n            for group in consecutive_groups(empty_angles):\n                g = list(group)\n                if len(g) == 1:\n                    index = g[0]\n                    isolated = result[index]\n                    before = result[(index - 1) % 360]\n                    after = result[(index + 1) % 360]\n                    result[index] = (\n                        isolated[0],\n                        round((before[1] + after[1]) / 2),\n                        round((before[2] + after[2]) / 2),\n                    )\n\n            self.signal_new_data.emit(result)\n        else:\n            print(\"Failed to get Lidar Data\")\n\n        time.sleep(0.5)\n\n    self._laser.turnOff()\n    self._laser.disconnecting()\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/lidar/#cogip.tools.lidarusb.lidar.Lidar.quit","title":"<code>quit()</code>","text":"<p>Request to exit the thread as soon as possible.</p> Source code in <code>cogip/tools/lidarusb/lidar.py</code> <pre><code>def quit(self):\n    \"\"\"\n    Request to exit the thread as soon as possible.\n    \"\"\"\n    self._exiting = True\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/lidar/#cogip.tools.lidarusb.lidar.Lidar.set_intensity_threshold","title":"<code>set_intensity_threshold(threshold)</code>","text":"<p>Set new intensity threshold.</p> Source code in <code>cogip/tools/lidarusb/lidar.py</code> <pre><code>def set_intensity_threshold(self, threshold: int):\n    \"\"\"\n    Set new intensity threshold.\n    \"\"\"\n    self._intensity_threshold = threshold\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/main/","title":"main","text":""},{"location":"reference/cogip/tools/lidarusb/main/#cogip.tools.lidarusb.main.main","title":"<code>main()</code>","text":"<p>Starts the Lidar USB View tool.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>lidarusb</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/lidarusb/main.py</code> <pre><code>def main():\n    \"\"\"\n    Starts the Lidar USB View tool.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `lidarusb` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/lidarusb/mainwindow/","title":"mainwindow","text":""},{"location":"reference/cogip/tools/monitor/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/monitor/main/","title":"main","text":""},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main","title":"<code>main()</code>","text":"<p>Starts the copilot.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>copilot</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main():\n    \"\"\"\n    Starts the copilot.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `copilot` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/main/#cogip.tools.monitor.main.main_opt","title":"<code>main_opt(url=typer.Argument('http://localhost:8091', envvar='COGIP_SOCKETIO_SERVER_URL', help='Socket.IO Server URL'))</code>","text":"<p>Launch COGIP Monitor.</p> Source code in <code>cogip/tools/monitor/main.py</code> <pre><code>def main_opt(\n    url: str = typer.Argument(\n        \"http://localhost:8091\",\n        envvar=\"COGIP_SOCKETIO_SERVER_URL\",\n        help=\"Socket.IO Server URL\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Launch COGIP Monitor.\n    \"\"\"\n    faulthandler.enable()\n\n    # Create socketio controller\n    controller = SocketioController(url)\n\n    # Create QApplication\n    app = QtWidgets.QApplication(sys.argv)\n\n    # Create UI\n    win = MainWindow(url)\n    win.setWindowIcon(QtGui.QIcon(\"assets/cogip-logo.png\"))\n\n    # Create table entity\n    table_entity = TableEntity()\n    win.game_view.add_asset(table_entity)\n\n    # Create robot entity\n    robot_manager = RobotManager(win.game_view)\n\n    # Connect UI signals to Controller slots\n    win.signal_send_command.connect(controller.new_command)\n    win.signal_config_updated.connect(controller.config_updated)\n    win.signal_wizard_response.connect(controller.wizard_response)\n    win.signal_actuators_opened.connect(controller.actuators_started)\n    win.signal_actuators_closed.connect(controller.actuators_closed)\n    win.signal_new_actuator_command.connect(controller.new_actuator_command)\n    win.signal_starter_changed.connect(controller.starter_changed)\n\n    # Connect UI signals to GameView slots\n    win.signal_add_obstacle.connect(win.game_view.add_obstacle)\n    win.signal_load_obstacles.connect(win.game_view.load_obstacles)\n    win.signal_save_obstacles.connect(win.game_view.save_obstacles)\n\n    # Connect Controller signals to robot manager\n    controller.signal_new_robot_pose_current.connect(robot_manager.new_robot_pose_current)\n    controller.signal_new_robot_pose_order.connect(robot_manager.new_robot_pose_order)\n    controller.signal_new_dyn_obstacles.connect(robot_manager.set_dyn_obstacles)\n    controller.signal_add_robot.connect(robot_manager.add_robot)\n    controller.signal_del_robot.connect(robot_manager.del_robot)\n    controller.signal_start_sensors_emulation.connect(robot_manager.start_sensors_emulation)\n    controller.signal_stop_sensors_emulation.connect(robot_manager.stop_sensors_emulation)\n    robot_manager.sensors_emit_data_signal.connect(controller.emit_sensors_data)\n\n    # Connect Controller signals to UI slots\n    controller.signal_new_console_text.connect(win.log_text.append)\n    controller.signal_new_menu.connect(win.load_menu)\n    controller.signal_add_robot.connect(win.add_robot)\n    controller.signal_del_robot.connect(win.del_robot)\n    controller.signal_starter_changed.connect(win.starter_changed)\n    controller.signal_new_robot_pose_current.connect(win.new_robot_pose)\n    controller.signal_new_robot_state.connect(win.new_robot_state)\n    controller.signal_connected.connect(win.connected)\n    controller.signal_exit.connect(win.close)\n    controller.signal_config_request.connect(win.config_request)\n    controller.signal_wizard_request.connect(win.wizard_request)\n    controller.signal_close_wizard.connect(win.close_wizard)\n    controller.signal_actuator_state.connect(win.actuator_state)\n    controller.signal_planner_reset.connect(win.planner_reset)\n\n    # Connect Controller signals to GameView slots\n    controller.signal_new_robot_path.connect(win.game_view.new_robot_path)\n\n    # Show UI\n    win.show()\n    # win.showFullScreen()\n    win.raise_()\n\n    controller.start()\n\n    ret = app.exec()\n\n    controller.stop()\n\n    sys.exit(ret)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/","title":"mainwindow","text":""},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>MainWindow class</p> <p>Build the main window of the monitor.</p> <p>It contains:</p> <ul> <li>a menu bar,</li> <li>a tool bar with buttons to add/load/save obstacles,</li> <li>a status bar with robot position,</li> <li>a menu with commands available in the current firmware shell menu,</li> <li>a console recording the firmware output.</li> </ul> <p>Attributes:</p> Name Type Description <code>signal_config_updated</code> <code>Signal</code> <p>Qt signal to update config</p> <code>signal_wizard_response</code> <code>Signal</code> <p>Qt signal to emit wizard response</p> <code>signal_send_command</code> <code>Signal</code> <p>Qt signal to send a command to the firmware</p> <code>signal_add_obstacle</code> <code>Signal</code> <p>Qt signal to add an obstacle</p> <code>signal_load_obstacles</code> <code>Signal</code> <p>Qt signal to load obstacles</p> <code>signal_save_obstacles</code> <code>Signal</code> <p>Qt signal to save obstacles</p> <code>signal_new_actuator_command</code> <code>Signal</code> <p>Qt signal to send actuator command to server</p> <code>signal_actuators_opened</code> <code>Signal</code> <p>Qt signal to start actuators state request</p> <code>signal_actuators_closed</code> <code>Signal</code> <p>Qt signal to stop actuators state request</p> <code>signal_starter_changed</code> <code>Signal</code> <p>Qt signal emitted the starter state has changed</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>class MainWindow(QtWidgets.QMainWindow):\n    \"\"\"MainWindow class\n\n    Build the main window of the monitor.\n\n    It contains:\n\n      - a menu bar,\n      - a tool bar with buttons to add/load/save obstacles,\n      - a status bar with robot position,\n      - a menu with commands available in the current firmware shell menu,\n      - a console recording the firmware output.\n\n    Attributes:\n        signal_config_updated: Qt signal to update config\n        signal_wizard_response: Qt signal to emit wizard response\n        signal_send_command: Qt signal to send a command to the firmware\n        signal_add_obstacle: Qt signal to add an obstacle\n        signal_load_obstacles: Qt signal to load obstacles\n        signal_save_obstacles: Qt signal to save obstacles\n        signal_new_actuator_command: Qt signal to send actuator command to server\n        signal_actuators_opened: Qt signal to start actuators state request\n        signal_actuators_closed: Qt signal to stop actuators state request\n        signal_starter_changed: Qt signal emitted the starter state has changed\n    \"\"\"\n\n    signal_config_updated: qtSignal = qtSignal(dict)\n    signal_wizard_response: qtSignal = qtSignal(dict)\n    signal_send_command: qtSignal = qtSignal(str, str)\n    signal_add_obstacle: qtSignal = qtSignal()\n    signal_load_obstacles: qtSignal = qtSignal(Path)\n    signal_save_obstacles: qtSignal = qtSignal(Path)\n    signal_actuators_opened: qtSignal = qtSignal()\n    signal_actuators_closed: qtSignal = qtSignal()\n    signal_new_actuator_command: qtSignal = qtSignal(object)\n    signal_starter_changed: qtSignal = qtSignal(int, bool)\n\n    def __init__(self, url: str, *args, **kwargs):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            url: URL of the copilot web server\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.robot_status_row: dict[int, int] = {}\n        self.robot_starters: dict[int, QtWidgets.QCheckBox] = {}\n        self.charts_view: dict[int, ChartsView] = {}\n        self.available_chart_views: list[ChartsView] = []\n        self.menu_widgets: dict[str, dict[str, QtWidgets.QWidget]] = {}\n        self.wizard: WizardDialog | None = None\n\n        self.setWindowTitle(\"COGIP Monitor\")\n\n        self.central_widget = QtWidgets.QWidget()\n        self.central_layout = QtWidgets.QHBoxLayout()\n        self.central_widget.setLayout(self.central_layout)\n        self.setCentralWidget(self.central_widget)\n\n        # Menu bar\n        menubar = self.menuBar()\n        file_menu = menubar.addMenu(\"&amp;File\")\n        obstacles_menu = menubar.addMenu(\"&amp;Obstacles\")\n        self.view_menu = menubar.addMenu(\"&amp;View\")\n        help_menu = menubar.addMenu(\"&amp;Help\")\n\n        # Toolbars\n        file_toolbar = self.addToolBar(\"File\")\n        file_toolbar.setObjectName(\"File Toolbar\")\n        obstacles_toolbar = self.addToolBar(\"Obstacles\")\n        obstacles_toolbar.setObjectName(\"Obstacles Toolbar\")\n        actuators_toolbar = self.addToolBar(\"Obstacles\")\n        actuators_toolbar.setObjectName(\"Actuators Toolbar\")\n\n        # Status bar\n        status_bar = self.statusBar()\n\n        self.connected_label = QtWidgets.QLabel(\"Disconnected\")\n        status_bar.addPermanentWidget(self.connected_label, 1)\n\n        status_widget = QtWidgets.QWidget()\n        status_bar.addPermanentWidget(status_widget)\n\n        self.status_layout = QtWidgets.QGridLayout()\n        status_widget.setLayout(self.status_layout)\n\n        cycle_label = QtWidgets.QLabel(\"Cycle\")\n        self.status_layout.addWidget(cycle_label, 0, 1)\n\n        pos_x_label = QtWidgets.QLabel(\"X\")\n        self.status_layout.addWidget(pos_x_label, 0, 2)\n\n        pos_y_label = QtWidgets.QLabel(\"Y\")\n        self.status_layout.addWidget(pos_y_label, 0, 3)\n\n        pos_angle_label = QtWidgets.QLabel(\"Angle\")\n        self.status_layout.addWidget(pos_angle_label, 0, 4)\n\n        starter_label = QtWidgets.QLabel(\"Starter\")\n        self.status_layout.addWidget(starter_label, 0, 5)\n\n        # Actions\n        # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n        # Exit action\n        self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n        self.exit_action.setShortcut(\"Ctrl+Q\")\n        self.exit_action.setStatusTip(\"Exit application\")\n        self.exit_action.triggered.connect(self.close)\n        file_menu.addAction(self.exit_action)\n        file_toolbar.addAction(self.exit_action)\n\n        # Add obstacle action\n        self.add_obstacle_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"list-add\"), \"Add obstacle\", self)\n        self.add_obstacle_action.setShortcut(\"Ctrl+A\")\n        self.add_obstacle_action.setStatusTip(\"Add obstacle\")\n        self.add_obstacle_action.triggered.connect(self.add_obstacle)\n        obstacles_menu.addAction(self.add_obstacle_action)\n        obstacles_toolbar.addAction(self.add_obstacle_action)\n\n        # Open obstacles action\n        self.load_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Load obstacles\", self)\n        self.load_obstacles_action.setShortcut(\"Ctrl+O\")\n        self.load_obstacles_action.setStatusTip(\"Load obstacles\")\n        self.load_obstacles_action.triggered.connect(self.load_obstacles)\n        obstacles_menu.addAction(self.load_obstacles_action)\n        obstacles_toolbar.addAction(self.load_obstacles_action)\n\n        # Save obstacles action\n        self.save_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-save\"), \"Save obstacles\", self)\n        self.save_obstacles_action.setShortcut(\"Ctrl+S\")\n        self.save_obstacles_action.setStatusTip(\"Save obstacles\")\n        self.save_obstacles_action.triggered.connect(self.save_obstacles)\n        obstacles_menu.addAction(self.save_obstacles_action)\n        obstacles_toolbar.addAction(self.save_obstacles_action)\n\n        # Actuators control action\n        self.actuators_control_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"emblem-system\"), \"Actuators control\", self)\n        self.actuators_control_action.setStatusTip(\"Actuators control\")\n        self.actuators_control_action.triggered.connect(self.open_actuators_control)\n        actuators_toolbar.addAction(self.actuators_control_action)\n\n        # Console\n        dock = QtWidgets.QDockWidget(\"Console\")\n        dock.setObjectName(\"Console\")\n        dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea)\n        self.log_text = QtWidgets.QTextEdit()\n        self.log_text.setReadOnly(True)\n        dock.setWidget(self.log_text)\n        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)\n        file_menu.addAction(dock.toggleViewAction())\n        obstacles_menu.addAction(dock.toggleViewAction())\n\n        self.menu_tab_widget = QtWidgets.QTabWidget()\n        self.central_layout.insertWidget(0, self.menu_tab_widget, 1)\n\n        self.menu_staked_widgets: dict[str, QtWidgets.QStackedWidget] = {}\n\n        # GameView widget\n        self.game_view = GameView()\n        self.central_layout.insertWidget(1, self.game_view, 10)\n\n        # Help controls widget\n        self.help_camera_control = HelpCameraControlDialog(self)\n\n        # Properties windows\n        self.properties = {}\n\n        # Actuators control windows\n        self.actuators_dialog = ActuatorsDialog()\n        self.actuators_dialog.new_actuator_command.connect(self.new_actuator_command)\n        self.actuators_dialog.closed.connect(self.actuators_closed)\n\n        # Add help action\n        self.help_camera_control_action = QtGui.QAction(\"Camera control\", self)\n        self.help_camera_control_action.setStatusTip(\"Display camera control help\")\n        self.help_camera_control_action.triggered.connect(self.display_help_camera_control)\n        help_menu.addAction(self.help_camera_control_action)\n\n        self.readSettings()\n\n    @qtSlot(bool)\n    def charts_toggled(self, robot_id: int, checked: bool):\n        \"\"\"\n        Qt Slot\n\n        Show/hide the calibration charts.\n\n        Arguments:\n            robot_id: ID of the robot corresponding to the chart view\n            checked: Show action has checked or unchecked\n        \"\"\"\n        view = self.charts_view.get(robot_id)\n        if view is None:\n            return\n\n        if checked:\n            view.show()\n            view.raise_()\n            view.activateWindow()\n        else:\n            view.close()\n\n    def update_view_menu(self):\n        \"\"\"\n        Rebuild all the view menu to update the calibration charts sub-menu.\n        \"\"\"\n        self.view_menu.clear()\n        if len(self.charts_view):\n            calibration_menu = self.view_menu.addMenu(\"Calibration Charts\")\n            for robot_id, view in self.charts_view.items():\n                action = calibration_menu.addAction(f\"Robot {robot_id}\")\n                action.setCheckable(True)\n                action.toggled.connect(partial(self.charts_toggled, robot_id))\n                if view.isVisible():\n                    action.setChecked(True)\n                view.closed.connect(partial(action.setChecked, False))\n\n    def add_robot(self, robot_id: int, virtual: bool) -&gt; None:\n        \"\"\"\n        Add a new robot status bar.\n\n        Parameters:\n            robot_id: ID of the new robot\n            virtual: whether the robot is virtual or not\n        \"\"\"\n        self.game_view.add_robot(robot_id)\n\n        # Status bar\n        if robot_id in self.robot_status_row:\n            return\n\n        row = self.status_layout.rowCount()\n        self.robot_status_row[robot_id] = row\n\n        title_text = QtWidgets.QLabel(f\"Robot {robot_id}\")\n        self.status_layout.addWidget(title_text, row, 0)\n\n        cycle_text = QtWidgets.QLabel()\n        cycle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(cycle_text, row, 1)\n\n        pos_x_text = QtWidgets.QLabel()\n        pos_x_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_x_text, row, 2)\n\n        pos_y_text = QtWidgets.QLabel()\n        pos_y_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_y_text, row, 3)\n\n        pos_angle_text = QtWidgets.QLabel()\n        pos_angle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n        pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        self.status_layout.addWidget(pos_angle_text, row, 4)\n\n        self.robot_starters[robot_id] = (starter_checkbox := QtWidgets.QCheckBox())\n        self.status_layout.addWidget(starter_checkbox, row, 5)\n        starter_checkbox.setEnabled(virtual)\n        starter_checkbox.toggled.connect(partial(self.starter_toggled, robot_id))\n\n        # Chart view\n        view = self.charts_view.get(robot_id)\n        if view is None:\n            if len(self.available_chart_views) == 0:\n                view = ChartsView(self)\n                self.available_chart_views.append(view)\n\n            view = self.available_chart_views.pop(0)\n            self.charts_view[robot_id] = view\n            view.set_robot_id(robot_id)\n            settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n            if settings.value(f\"charts_checked/{robot_id}\") == \"true\":\n                self.charts_toggled(robot_id, True)\n\n        self.update_view_menu()\n\n    def del_robot(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n\n        Parameters:\n            robot_id: ID of the robot to remove\n        \"\"\"\n        self.game_view.del_robot(robot_id)\n\n        # Status bar\n        row = self.robot_status_row.pop(robot_id)\n        if not row:\n            return\n\n        for i in range(7):\n            if not (item := self.status_layout.itemAtPosition(row, i)):\n                continue\n            widget = item.widget()\n            widget.setParent(None)\n            self.status_layout.removeWidget(widget)\n\n        # Chart view\n        self.charts_toggled(robot_id, False)\n        view = self.charts_view.pop(robot_id, None)\n        if view is None:\n            return\n        self.available_chart_views.append(view)\n        view.closed.disconnect()\n        self.update_view_menu()\n\n    @qtSlot(Pose)\n    def new_robot_pose(self, robot_id: int, pose: Pose):\n        \"\"\"\n        Qt Slot\n\n        Update robot position information in the status bar.\n\n        Arguments:\n            robot_id: ID of the robot\n            pose: Robot pose\n        \"\"\"\n        row = self.robot_status_row.get(robot_id)\n        if not row:\n            return\n        self.status_layout.itemAtPosition(row, 2).widget().setText(f\"{int(pose.x):&gt; #6d}\")\n        self.status_layout.itemAtPosition(row, 3).widget().setText(f\"{int(pose.y):&gt; #6d}\")\n        self.status_layout.itemAtPosition(row, 4).widget().setText(f\"{int(pose.O):&gt; #4d}\")\n\n    @qtSlot(RobotState)\n    def new_robot_state(self, robot_id: int, state: RobotState):\n        \"\"\"\n        Qt Slot\n\n        Update robot state information in the status bar.\n\n        Arguments:\n            robot_id: ID of the robot\n            state: Robot state\n        \"\"\"\n        row = self.robot_status_row.get(robot_id)\n        if not row:\n            return\n        self.status_layout.itemAtPosition(row, 1).widget().setText(f\"{state.cycle or 0:&gt;#6d}\")\n\n        charts_view = self.charts_view.get(robot_id)\n        if charts_view:\n            charts_view.new_robot_state(state)\n\n    @qtSlot(ShellMenu)\n    def load_menu(self, menu_name: str, new_menu: ShellMenu):\n        \"\"\"\n        Qt Slot\n\n        Display the new menu sent by [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n        Once a menu has been build once, it is cached and reused.\n\n        Arguments:\n            menu_name: menu to update (\"shell\", \"tool\", ...)\n            new_menu: The new menu information sent by the firmware\n        \"\"\"\n        if menu_name not in self.menu_staked_widgets:\n            self.menu_staked_widgets[menu_name] = QtWidgets.QStackedWidget()\n            empty_menu_widget = QtWidgets.QStackedWidget()\n            empty_menu_layout = QtWidgets.QVBoxLayout()\n            empty_menu_widget.setLayout(empty_menu_layout)\n            empty_menu_title = QtWidgets.QLabel(\"No menu loaded\")\n            empty_menu_title.setTextFormat(QtCore.Qt.RichText)\n            empty_menu_title.setAlignment(QtCore.Qt.AlignHCenter)\n            empty_menu_title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n            empty_menu_title.setStyleSheet(\"font-weight: bold; color: blue\")\n            empty_menu_layout.addWidget(empty_menu_title)\n            empty_menu_layout.addStretch()\n            self.menu_staked_widgets[menu_name].addWidget(empty_menu_widget)\n            self.menu_tab_widget.addTab(self.menu_staked_widgets[menu_name], menu_name)\n\n        if menu_name not in self.menu_widgets:\n            self.menu_widgets[menu_name] = {}\n\n        widget = self.menu_widgets[menu_name].get(new_menu.name)\n        if not widget:\n            # Create a new menu\n            widget = QtWidgets.QWidget()\n            layout = QtWidgets.QVBoxLayout()\n            widget.setLayout(layout)\n            self.menu_widgets[menu_name][new_menu.name] = widget\n            self.menu_staked_widgets[menu_name].addWidget(widget)\n\n        # Clear menu to rebuild it in case it has changed\n        layout = widget.layout()\n        while layout.count():\n            child = layout.takeAt(0)\n            if child.widget():\n                child.widget().deleteLater()\n\n        title = QtWidgets.QLabel(new_menu.name)\n        title.setTextFormat(QtCore.Qt.RichText)\n        title.setAlignment(QtCore.Qt.AlignHCenter)\n        title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        title.setStyleSheet(\"font-weight: bold; color: blue\")\n        layout.addWidget(title)\n\n        for entry in new_menu.entries:\n            if entry.cmd[0] == \"_\":\n                continue\n            cmd_widget = QtWidgets.QWidget()\n            cmd_layout = QtWidgets.QHBoxLayout()\n            cmd_layout.setContentsMargins(0, 0, 0, 0)\n            cmd_widget.setLayout(cmd_layout)\n            layout.addWidget(cmd_widget)\n\n            desc, args = split_command(entry.desc)\n            button = QtWidgets.QPushButton(desc)\n            cmd_layout.addWidget(button)\n\n            for arg in args:\n                edit = QtWidgets.QLineEdit()\n                edit.setPlaceholderText(arg)\n                edit.setToolTip(arg)\n                cmd_layout.addWidget(edit)\n                edit.returnPressed.connect(\n                    lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout)\n                )\n            button.clicked.connect(lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout))\n\n        layout.addStretch()\n\n        self.menu_staked_widgets[menu_name].setCurrentWidget(widget)\n\n    def build_command(self, menu_name: str, cmd: str, layout: QtWidgets.QHBoxLayout):\n        \"\"\"\n        Build command to send to [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n        It is built based on the command name given in arguments,\n        and arguments strings fetched from the command button in the menu.\n\n        Emit the `signal_send_command` signal with the full command string as argument.\n\n        Arguments:\n            menu_name: menu to update (\"shell\", \"tool\", ...)\n            cmd: The command name\n            layout: The command button containing the command arguments\n        \"\"\"\n        i = 1\n        while i &lt; layout.count():\n            edit = layout.itemAt(i).widget()\n            text = edit.text()\n            if text == \"\":\n                return\n            cmd += f\" {text}\"\n            i += 1\n        self.signal_send_command.emit(menu_name, cmd)\n\n    @qtSlot()\n    def add_obstacle(self):\n        \"\"\"\n        Qt Slot\n\n        Receive signals from \"Add obstacle\" action.\n\n        Emit the `signal_add_obstacle` signal.\n        \"\"\"\n        self.signal_add_obstacle.emit()\n\n    @qtSlot()\n    def load_obstacles(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and load obstacles from it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n            parent=self,\n            caption=\"Select file to load obstacles\",\n            dir=\"\",\n            filter=\"JSON Files (*.json)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            self.signal_load_obstacles.emit(Path(filename))\n\n    @qtSlot()\n    def save_obstacles(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and save obstacles in it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n            parent=self,\n            caption=\"Select file to save obstacles\",\n            dir=\"\",\n            filter=\"JSON Files (*.json)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            self.signal_save_obstacles.emit(Path(filename))\n\n    @qtSlot()\n    def open_actuators_control(self):\n        \"\"\"\n        Qt Slot\n\n        Open the actuators control dialog.\n        \"\"\"\n        self.signal_actuators_opened.emit()\n        self.actuators_dialog.show()\n        self.actuators_dialog.raise_()\n        self.actuators_dialog.activateWindow()\n\n    def display_help_camera_control(self):\n        \"\"\"\n        Qt Slot\n\n        Open camera control help dialog.\n        \"\"\"\n        self.help_camera_control.show()\n        self.help_camera_control.raise_()\n        self.help_camera_control.activateWindow()\n\n    @qtSlot()\n    def connected(self, state: bool):\n        \"\"\"\n        Qt Slot\n\n        Update the status bar with connected/disconnected state.\n\n        Arguments:\n            state: True if connected, False if disconnected\n        \"\"\"\n        self.connected_label.setText(\"Connected\" if state else \"Disconnected\")\n\n    @qtSlot(dict)\n    def config_request(self, config: dict[str, Any]):\n        properties = self.properties.get(f'{config[\"namespace\"]}/{config[\"title\"]}')\n        if not properties:\n            properties = PropertiesDialog(config, self)\n            self.properties[f'{config[\"namespace\"]}/{config[\"title\"]}'] = properties\n            properties.property_updated.connect(self.config_updated)\n        else:\n            properties.update_values(config)\n        properties.show()\n        properties.raise_()\n        properties.activateWindow()\n\n    @qtSlot(dict)\n    def config_updated(self, config: dict[str, Any]):\n        self.signal_config_updated.emit(config)\n\n    @qtSlot(dict)\n    def wizard_request(self, message: dict[str, Any]):\n        self.wizard = WizardDialog(message, self)\n        self.wizard.response.connect(self.wizard_response)\n        self.wizard.show()\n        self.wizard.raise_()\n        self.wizard.activateWindow()\n\n    @qtSlot()\n    def close_wizard(self):\n        if self.wizard:\n            self.wizard.response.disconnect(self.wizard_response)\n            self.wizard.close()\n            self.wizard = None\n\n    @qtSlot(dict)\n    def wizard_response(self, response: dict[str, Any]):\n        self.signal_wizard_response.emit(response)\n        self.wizard = None\n\n    def actuator_state(self, actuator_state: ActuatorState):\n        \"\"\"\n        Receive current state of an actuator.\n\n        Arguments:\n            actuator_state: current actuator state\n        \"\"\"\n        self.actuators_dialog.update_actuator(actuator_state)\n\n    def new_actuator_command(self, command: ActuatorCommand):\n        \"\"\"\n        Function called when an actuator control is modified in the actuators dialog.\n        Forward the command to server.\n\n        Arguments:\n            command: actuator command to send\n        \"\"\"\n        self.signal_new_actuator_command.emit(command)\n\n    def actuators_closed(self):\n        \"\"\"\n        Function called when the actuators dialog is closed.\n        Forward information to server, to stop emitting actuators state from the robot.\n        \"\"\"\n        self.signal_actuators_closed.emit()\n\n    def planner_reset(self):\n        \"\"\"\n        Reset all charts on Planner reset.\n        \"\"\"\n        for chart_view in self.charts_view.values():\n            chart_view.reset()\n\n    def starter_toggled(self, robot_id: int, checked: bool):\n        self.signal_starter_changed.emit(robot_id, checked)\n\n    def starter_changed(self, robot_id: int, checked: bool):\n        if starter_checkbox := self.robot_starters.get(robot_id):\n            starter_checkbox.setChecked(checked)\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"geometry\", self.saveGeometry())\n        settings.setValue(\"windowState\", self.saveState())\n        for robot_id, view in self.charts_view.items():\n            settings.setValue(f\"charts_checked/{robot_id}\", view.isVisible())\n        settings.setValue(\"camera_params\", json.dumps(self.game_view.get_camera_params()))\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"geometry\"))\n        self.restoreState(settings.value(\"windowState\"))\n        try:\n            camera_params = json.loads(settings.value(\"camera_params\"))\n            self.game_view.set_camera_params(camera_params)\n        except Exception:\n            pass\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.__init__","title":"<code>__init__(url, *args, **kwargs)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the copilot web server</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def __init__(self, url: str, *args, **kwargs):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        url: URL of the copilot web server\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.robot_status_row: dict[int, int] = {}\n    self.robot_starters: dict[int, QtWidgets.QCheckBox] = {}\n    self.charts_view: dict[int, ChartsView] = {}\n    self.available_chart_views: list[ChartsView] = []\n    self.menu_widgets: dict[str, dict[str, QtWidgets.QWidget]] = {}\n    self.wizard: WizardDialog | None = None\n\n    self.setWindowTitle(\"COGIP Monitor\")\n\n    self.central_widget = QtWidgets.QWidget()\n    self.central_layout = QtWidgets.QHBoxLayout()\n    self.central_widget.setLayout(self.central_layout)\n    self.setCentralWidget(self.central_widget)\n\n    # Menu bar\n    menubar = self.menuBar()\n    file_menu = menubar.addMenu(\"&amp;File\")\n    obstacles_menu = menubar.addMenu(\"&amp;Obstacles\")\n    self.view_menu = menubar.addMenu(\"&amp;View\")\n    help_menu = menubar.addMenu(\"&amp;Help\")\n\n    # Toolbars\n    file_toolbar = self.addToolBar(\"File\")\n    file_toolbar.setObjectName(\"File Toolbar\")\n    obstacles_toolbar = self.addToolBar(\"Obstacles\")\n    obstacles_toolbar.setObjectName(\"Obstacles Toolbar\")\n    actuators_toolbar = self.addToolBar(\"Obstacles\")\n    actuators_toolbar.setObjectName(\"Actuators Toolbar\")\n\n    # Status bar\n    status_bar = self.statusBar()\n\n    self.connected_label = QtWidgets.QLabel(\"Disconnected\")\n    status_bar.addPermanentWidget(self.connected_label, 1)\n\n    status_widget = QtWidgets.QWidget()\n    status_bar.addPermanentWidget(status_widget)\n\n    self.status_layout = QtWidgets.QGridLayout()\n    status_widget.setLayout(self.status_layout)\n\n    cycle_label = QtWidgets.QLabel(\"Cycle\")\n    self.status_layout.addWidget(cycle_label, 0, 1)\n\n    pos_x_label = QtWidgets.QLabel(\"X\")\n    self.status_layout.addWidget(pos_x_label, 0, 2)\n\n    pos_y_label = QtWidgets.QLabel(\"Y\")\n    self.status_layout.addWidget(pos_y_label, 0, 3)\n\n    pos_angle_label = QtWidgets.QLabel(\"Angle\")\n    self.status_layout.addWidget(pos_angle_label, 0, 4)\n\n    starter_label = QtWidgets.QLabel(\"Starter\")\n    self.status_layout.addWidget(starter_label, 0, 5)\n\n    # Actions\n    # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n    # Exit action\n    self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n    self.exit_action.setShortcut(\"Ctrl+Q\")\n    self.exit_action.setStatusTip(\"Exit application\")\n    self.exit_action.triggered.connect(self.close)\n    file_menu.addAction(self.exit_action)\n    file_toolbar.addAction(self.exit_action)\n\n    # Add obstacle action\n    self.add_obstacle_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"list-add\"), \"Add obstacle\", self)\n    self.add_obstacle_action.setShortcut(\"Ctrl+A\")\n    self.add_obstacle_action.setStatusTip(\"Add obstacle\")\n    self.add_obstacle_action.triggered.connect(self.add_obstacle)\n    obstacles_menu.addAction(self.add_obstacle_action)\n    obstacles_toolbar.addAction(self.add_obstacle_action)\n\n    # Open obstacles action\n    self.load_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Load obstacles\", self)\n    self.load_obstacles_action.setShortcut(\"Ctrl+O\")\n    self.load_obstacles_action.setStatusTip(\"Load obstacles\")\n    self.load_obstacles_action.triggered.connect(self.load_obstacles)\n    obstacles_menu.addAction(self.load_obstacles_action)\n    obstacles_toolbar.addAction(self.load_obstacles_action)\n\n    # Save obstacles action\n    self.save_obstacles_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-save\"), \"Save obstacles\", self)\n    self.save_obstacles_action.setShortcut(\"Ctrl+S\")\n    self.save_obstacles_action.setStatusTip(\"Save obstacles\")\n    self.save_obstacles_action.triggered.connect(self.save_obstacles)\n    obstacles_menu.addAction(self.save_obstacles_action)\n    obstacles_toolbar.addAction(self.save_obstacles_action)\n\n    # Actuators control action\n    self.actuators_control_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"emblem-system\"), \"Actuators control\", self)\n    self.actuators_control_action.setStatusTip(\"Actuators control\")\n    self.actuators_control_action.triggered.connect(self.open_actuators_control)\n    actuators_toolbar.addAction(self.actuators_control_action)\n\n    # Console\n    dock = QtWidgets.QDockWidget(\"Console\")\n    dock.setObjectName(\"Console\")\n    dock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea)\n    self.log_text = QtWidgets.QTextEdit()\n    self.log_text.setReadOnly(True)\n    dock.setWidget(self.log_text)\n    self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)\n    file_menu.addAction(dock.toggleViewAction())\n    obstacles_menu.addAction(dock.toggleViewAction())\n\n    self.menu_tab_widget = QtWidgets.QTabWidget()\n    self.central_layout.insertWidget(0, self.menu_tab_widget, 1)\n\n    self.menu_staked_widgets: dict[str, QtWidgets.QStackedWidget] = {}\n\n    # GameView widget\n    self.game_view = GameView()\n    self.central_layout.insertWidget(1, self.game_view, 10)\n\n    # Help controls widget\n    self.help_camera_control = HelpCameraControlDialog(self)\n\n    # Properties windows\n    self.properties = {}\n\n    # Actuators control windows\n    self.actuators_dialog = ActuatorsDialog()\n    self.actuators_dialog.new_actuator_command.connect(self.new_actuator_command)\n    self.actuators_dialog.closed.connect(self.actuators_closed)\n\n    # Add help action\n    self.help_camera_control_action = QtGui.QAction(\"Camera control\", self)\n    self.help_camera_control_action.setStatusTip(\"Display camera control help\")\n    self.help_camera_control_action.triggered.connect(self.display_help_camera_control)\n    help_menu.addAction(self.help_camera_control_action)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.actuator_state","title":"<code>actuator_state(actuator_state)</code>","text":"<p>Receive current state of an actuator.</p> <p>Parameters:</p> Name Type Description Default <code>actuator_state</code> <code>ActuatorState</code> <p>current actuator state</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def actuator_state(self, actuator_state: ActuatorState):\n    \"\"\"\n    Receive current state of an actuator.\n\n    Arguments:\n        actuator_state: current actuator state\n    \"\"\"\n    self.actuators_dialog.update_actuator(actuator_state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.actuators_closed","title":"<code>actuators_closed()</code>","text":"<p>Function called when the actuators dialog is closed. Forward information to server, to stop emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def actuators_closed(self):\n    \"\"\"\n    Function called when the actuators dialog is closed.\n    Forward information to server, to stop emitting actuators state from the robot.\n    \"\"\"\n    self.signal_actuators_closed.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.add_obstacle","title":"<code>add_obstacle()</code>","text":"<p>Qt Slot</p> <p>Receive signals from \"Add obstacle\" action.</p> <p>Emit the <code>signal_add_obstacle</code> signal.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef add_obstacle(self):\n    \"\"\"\n    Qt Slot\n\n    Receive signals from \"Add obstacle\" action.\n\n    Emit the `signal_add_obstacle` signal.\n    \"\"\"\n    self.signal_add_obstacle.emit()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.add_robot","title":"<code>add_robot(robot_id, virtual)</code>","text":"<p>Add a new robot status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the new robot</p> required <code>virtual</code> <code>bool</code> <p>whether the robot is virtual or not</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def add_robot(self, robot_id: int, virtual: bool) -&gt; None:\n    \"\"\"\n    Add a new robot status bar.\n\n    Parameters:\n        robot_id: ID of the new robot\n        virtual: whether the robot is virtual or not\n    \"\"\"\n    self.game_view.add_robot(robot_id)\n\n    # Status bar\n    if robot_id in self.robot_status_row:\n        return\n\n    row = self.status_layout.rowCount()\n    self.robot_status_row[robot_id] = row\n\n    title_text = QtWidgets.QLabel(f\"Robot {robot_id}\")\n    self.status_layout.addWidget(title_text, row, 0)\n\n    cycle_text = QtWidgets.QLabel()\n    cycle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(cycle_text, row, 1)\n\n    pos_x_text = QtWidgets.QLabel()\n    pos_x_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_x_text, row, 2)\n\n    pos_y_text = QtWidgets.QLabel()\n    pos_y_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_y_text, row, 3)\n\n    pos_angle_text = QtWidgets.QLabel()\n    pos_angle_text.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)\n    pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    self.status_layout.addWidget(pos_angle_text, row, 4)\n\n    self.robot_starters[robot_id] = (starter_checkbox := QtWidgets.QCheckBox())\n    self.status_layout.addWidget(starter_checkbox, row, 5)\n    starter_checkbox.setEnabled(virtual)\n    starter_checkbox.toggled.connect(partial(self.starter_toggled, robot_id))\n\n    # Chart view\n    view = self.charts_view.get(robot_id)\n    if view is None:\n        if len(self.available_chart_views) == 0:\n            view = ChartsView(self)\n            self.available_chart_views.append(view)\n\n        view = self.available_chart_views.pop(0)\n        self.charts_view[robot_id] = view\n        view.set_robot_id(robot_id)\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        if settings.value(f\"charts_checked/{robot_id}\") == \"true\":\n            self.charts_toggled(robot_id, True)\n\n    self.update_view_menu()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.build_command","title":"<code>build_command(menu_name, cmd, layout)</code>","text":"<p>Build command to send to SocketioController.</p> <p>It is built based on the command name given in arguments, and arguments strings fetched from the command button in the menu.</p> <p>Emit the <code>signal_send_command</code> signal with the full command string as argument.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"shell\", \"tool\", ...)</p> required <code>cmd</code> <code>str</code> <p>The command name</p> required <code>layout</code> <code>QHBoxLayout</code> <p>The command button containing the command arguments</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def build_command(self, menu_name: str, cmd: str, layout: QtWidgets.QHBoxLayout):\n    \"\"\"\n    Build command to send to [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n    It is built based on the command name given in arguments,\n    and arguments strings fetched from the command button in the menu.\n\n    Emit the `signal_send_command` signal with the full command string as argument.\n\n    Arguments:\n        menu_name: menu to update (\"shell\", \"tool\", ...)\n        cmd: The command name\n        layout: The command button containing the command arguments\n    \"\"\"\n    i = 1\n    while i &lt; layout.count():\n        edit = layout.itemAt(i).widget()\n        text = edit.text()\n        if text == \"\":\n            return\n        cmd += f\" {text}\"\n        i += 1\n    self.signal_send_command.emit(menu_name, cmd)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.charts_toggled","title":"<code>charts_toggled(robot_id, checked)</code>","text":"<p>Qt Slot</p> <p>Show/hide the calibration charts.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot corresponding to the chart view</p> required <code>checked</code> <code>bool</code> <p>Show action has checked or unchecked</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(bool)\ndef charts_toggled(self, robot_id: int, checked: bool):\n    \"\"\"\n    Qt Slot\n\n    Show/hide the calibration charts.\n\n    Arguments:\n        robot_id: ID of the robot corresponding to the chart view\n        checked: Show action has checked or unchecked\n    \"\"\"\n    view = self.charts_view.get(robot_id)\n    if view is None:\n        return\n\n    if checked:\n        view.show()\n        view.raise_()\n        view.activateWindow()\n    else:\n        view.close()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.connected","title":"<code>connected(state)</code>","text":"<p>Qt Slot</p> <p>Update the status bar with connected/disconnected state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>bool</code> <p>True if connected, False if disconnected</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef connected(self, state: bool):\n    \"\"\"\n    Qt Slot\n\n    Update the status bar with connected/disconnected state.\n\n    Arguments:\n        state: True if connected, False if disconnected\n    \"\"\"\n    self.connected_label.setText(\"Connected\" if state else \"Disconnected\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.del_robot","title":"<code>del_robot(robot_id)</code>","text":"<p>Remove a robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot to remove</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def del_robot(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Remove a robot.\n\n    Parameters:\n        robot_id: ID of the robot to remove\n    \"\"\"\n    self.game_view.del_robot(robot_id)\n\n    # Status bar\n    row = self.robot_status_row.pop(robot_id)\n    if not row:\n        return\n\n    for i in range(7):\n        if not (item := self.status_layout.itemAtPosition(row, i)):\n            continue\n        widget = item.widget()\n        widget.setParent(None)\n        self.status_layout.removeWidget(widget)\n\n    # Chart view\n    self.charts_toggled(robot_id, False)\n    view = self.charts_view.pop(robot_id, None)\n    if view is None:\n        return\n    self.available_chart_views.append(view)\n    view.closed.disconnect()\n    self.update_view_menu()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.display_help_camera_control","title":"<code>display_help_camera_control()</code>","text":"<p>Qt Slot</p> <p>Open camera control help dialog.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def display_help_camera_control(self):\n    \"\"\"\n    Qt Slot\n\n    Open camera control help dialog.\n    \"\"\"\n    self.help_camera_control.show()\n    self.help_camera_control.raise_()\n    self.help_camera_control.activateWindow()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.load_menu","title":"<code>load_menu(menu_name, new_menu)</code>","text":"<p>Qt Slot</p> <p>Display the new menu sent by SocketioController.</p> <p>Once a menu has been build once, it is cached and reused.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"shell\", \"tool\", ...)</p> required <code>new_menu</code> <code>ShellMenu</code> <p>The new menu information sent by the firmware</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(ShellMenu)\ndef load_menu(self, menu_name: str, new_menu: ShellMenu):\n    \"\"\"\n    Qt Slot\n\n    Display the new menu sent by [SocketioController][cogip.tools.monitor.socketiocontroller.SocketioController].\n\n    Once a menu has been build once, it is cached and reused.\n\n    Arguments:\n        menu_name: menu to update (\"shell\", \"tool\", ...)\n        new_menu: The new menu information sent by the firmware\n    \"\"\"\n    if menu_name not in self.menu_staked_widgets:\n        self.menu_staked_widgets[menu_name] = QtWidgets.QStackedWidget()\n        empty_menu_widget = QtWidgets.QStackedWidget()\n        empty_menu_layout = QtWidgets.QVBoxLayout()\n        empty_menu_widget.setLayout(empty_menu_layout)\n        empty_menu_title = QtWidgets.QLabel(\"No menu loaded\")\n        empty_menu_title.setTextFormat(QtCore.Qt.RichText)\n        empty_menu_title.setAlignment(QtCore.Qt.AlignHCenter)\n        empty_menu_title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        empty_menu_title.setStyleSheet(\"font-weight: bold; color: blue\")\n        empty_menu_layout.addWidget(empty_menu_title)\n        empty_menu_layout.addStretch()\n        self.menu_staked_widgets[menu_name].addWidget(empty_menu_widget)\n        self.menu_tab_widget.addTab(self.menu_staked_widgets[menu_name], menu_name)\n\n    if menu_name not in self.menu_widgets:\n        self.menu_widgets[menu_name] = {}\n\n    widget = self.menu_widgets[menu_name].get(new_menu.name)\n    if not widget:\n        # Create a new menu\n        widget = QtWidgets.QWidget()\n        layout = QtWidgets.QVBoxLayout()\n        widget.setLayout(layout)\n        self.menu_widgets[menu_name][new_menu.name] = widget\n        self.menu_staked_widgets[menu_name].addWidget(widget)\n\n    # Clear menu to rebuild it in case it has changed\n    layout = widget.layout()\n    while layout.count():\n        child = layout.takeAt(0)\n        if child.widget():\n            child.widget().deleteLater()\n\n    title = QtWidgets.QLabel(new_menu.name)\n    title.setTextFormat(QtCore.Qt.RichText)\n    title.setAlignment(QtCore.Qt.AlignHCenter)\n    title.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    title.setStyleSheet(\"font-weight: bold; color: blue\")\n    layout.addWidget(title)\n\n    for entry in new_menu.entries:\n        if entry.cmd[0] == \"_\":\n            continue\n        cmd_widget = QtWidgets.QWidget()\n        cmd_layout = QtWidgets.QHBoxLayout()\n        cmd_layout.setContentsMargins(0, 0, 0, 0)\n        cmd_widget.setLayout(cmd_layout)\n        layout.addWidget(cmd_widget)\n\n        desc, args = split_command(entry.desc)\n        button = QtWidgets.QPushButton(desc)\n        cmd_layout.addWidget(button)\n\n        for arg in args:\n            edit = QtWidgets.QLineEdit()\n            edit.setPlaceholderText(arg)\n            edit.setToolTip(arg)\n            cmd_layout.addWidget(edit)\n            edit.returnPressed.connect(\n                lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout)\n            )\n        button.clicked.connect(lambda cmd=entry.cmd, layout=cmd_layout: self.build_command(menu_name, cmd, layout))\n\n    layout.addStretch()\n\n    self.menu_staked_widgets[menu_name].setCurrentWidget(widget)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.load_obstacles","title":"<code>load_obstacles()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and load obstacles from it.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef load_obstacles(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and load obstacles from it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n        parent=self,\n        caption=\"Select file to load obstacles\",\n        dir=\"\",\n        filter=\"JSON Files (*.json)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        self.signal_load_obstacles.emit(Path(filename))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_actuator_command","title":"<code>new_actuator_command(command)</code>","text":"<p>Function called when an actuator control is modified in the actuators dialog. Forward the command to server.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ActuatorCommand</code> <p>actuator command to send</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def new_actuator_command(self, command: ActuatorCommand):\n    \"\"\"\n    Function called when an actuator control is modified in the actuators dialog.\n    Forward the command to server.\n\n    Arguments:\n        command: actuator command to send\n    \"\"\"\n    self.signal_new_actuator_command.emit(command)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_robot_pose","title":"<code>new_robot_pose(robot_id, pose)</code>","text":"<p>Qt Slot</p> <p>Update robot position information in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>pose</code> <code>Pose</code> <p>Robot pose</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(Pose)\ndef new_robot_pose(self, robot_id: int, pose: Pose):\n    \"\"\"\n    Qt Slot\n\n    Update robot position information in the status bar.\n\n    Arguments:\n        robot_id: ID of the robot\n        pose: Robot pose\n    \"\"\"\n    row = self.robot_status_row.get(robot_id)\n    if not row:\n        return\n    self.status_layout.itemAtPosition(row, 2).widget().setText(f\"{int(pose.x):&gt; #6d}\")\n    self.status_layout.itemAtPosition(row, 3).widget().setText(f\"{int(pose.y):&gt; #6d}\")\n    self.status_layout.itemAtPosition(row, 4).widget().setText(f\"{int(pose.O):&gt; #4d}\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.new_robot_state","title":"<code>new_robot_state(robot_id, state)</code>","text":"<p>Qt Slot</p> <p>Update robot state information in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>state</code> <code>RobotState</code> <p>Robot state</p> required Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot(RobotState)\ndef new_robot_state(self, robot_id: int, state: RobotState):\n    \"\"\"\n    Qt Slot\n\n    Update robot state information in the status bar.\n\n    Arguments:\n        robot_id: ID of the robot\n        state: Robot state\n    \"\"\"\n    row = self.robot_status_row.get(robot_id)\n    if not row:\n        return\n    self.status_layout.itemAtPosition(row, 1).widget().setText(f\"{state.cycle or 0:&gt;#6d}\")\n\n    charts_view = self.charts_view.get(robot_id)\n    if charts_view:\n        charts_view.new_robot_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.open_actuators_control","title":"<code>open_actuators_control()</code>","text":"<p>Qt Slot</p> <p>Open the actuators control dialog.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef open_actuators_control(self):\n    \"\"\"\n    Qt Slot\n\n    Open the actuators control dialog.\n    \"\"\"\n    self.signal_actuators_opened.emit()\n    self.actuators_dialog.show()\n    self.actuators_dialog.raise_()\n    self.actuators_dialog.activateWindow()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.planner_reset","title":"<code>planner_reset()</code>","text":"<p>Reset all charts on Planner reset.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def planner_reset(self):\n    \"\"\"\n    Reset all charts on Planner reset.\n    \"\"\"\n    for chart_view in self.charts_view.values():\n        chart_view.reset()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.save_obstacles","title":"<code>save_obstacles()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and save obstacles in it.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>@qtSlot()\ndef save_obstacles(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and save obstacles in it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n        parent=self,\n        caption=\"Select file to save obstacles\",\n        dir=\"\",\n        filter=\"JSON Files (*.json)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        self.signal_save_obstacles.emit(Path(filename))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.MainWindow.update_view_menu","title":"<code>update_view_menu()</code>","text":"<p>Rebuild all the view menu to update the calibration charts sub-menu.</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def update_view_menu(self):\n    \"\"\"\n    Rebuild all the view menu to update the calibration charts sub-menu.\n    \"\"\"\n    self.view_menu.clear()\n    if len(self.charts_view):\n        calibration_menu = self.view_menu.addMenu(\"Calibration Charts\")\n        for robot_id, view in self.charts_view.items():\n            action = calibration_menu.addAction(f\"Robot {robot_id}\")\n            action.setCheckable(True)\n            action.toggled.connect(partial(self.charts_toggled, robot_id))\n            if view.isVisible():\n                action.setChecked(True)\n            view.closed.connect(partial(action.setChecked, False))\n</code></pre>"},{"location":"reference/cogip/tools/monitor/mainwindow/#cogip.tools.monitor.mainwindow.split_command","title":"<code>split_command(command)</code>","text":"<p>Split the full command string to separate the name of the command and its arguments.</p> <p>The command is in the following format:</p> <pre><code>\"command name &lt;arg1&gt; &lt;arg2&gt; ...\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command string to split</p> required Return <p>A tuple of the command name and a list of arguments</p> Source code in <code>cogip/tools/monitor/mainwindow.py</code> <pre><code>def split_command(command: str) -&gt; tuple[str, list[str]]:\n    \"\"\"\n    Split the full command string to separate the name of the command\n    and its arguments.\n\n    The command is in the following format:\n    ```\n    \"command name &lt;arg1&gt; &lt;arg2&gt; ...\"\n    ```\n\n    Arguments:\n        command: The command string to split\n\n    Return:\n        A tuple of the command name and a list of arguments\n    \"\"\"\n    result: list[str] = list()\n    arg_match = re.findall(r\"(&lt;[\\d\\w]+&gt;)\", command)\n    for arg in arg_match:\n        result.append(arg[1:-1])\n        command = command.replace(arg, \"\")\n    command = command.strip()\n    return (command, result)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/","title":"robots","text":""},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager","title":"<code>RobotManager</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Attributes:</p> Name Type Description <code>sensors_emit_data_signal</code> <code>Signal</code> <p>Qt Signal emitting sensors data</p> Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>class RobotManager(QtCore.QObject):\n    \"\"\"\n\n    Attributes:\n        sensors_emit_data_signal: Qt Signal emitting sensors data\n    \"\"\"\n\n    sensors_emit_data_signal: qtSignal = qtSignal(int, list)\n\n    def __init__(self, game_view: GameView):\n        \"\"\"\n        Class constructor.\n\n        Parameters:\n            game_view: parent of the robots\n        \"\"\"\n        super().__init__()\n        self._game_view = game_view\n        self._robots: dict[int, RobotEntity] = dict()\n        self._available_robots: dict[int, RobotEntity] = dict()\n        self._rect_obstacles_pool: list[DynRectObstacleEntity] = []\n        self._round_obstacles_pool: list[DynCircleObstacleEntity] = []\n        self._sensors_emulation: dict[int, bool] = {}\n\n    def add_robot(self, robot_id: int, virtual: bool = False) -&gt; None:\n        \"\"\"\n        Add a new robot.\n\n        Parameters:\n            robot_id: ID of the new robot\n            virtual: whether the robot is virtual or not\n        \"\"\"\n        if robot_id in self._robots:\n            return\n\n        if self._available_robots.get(robot_id) is None:\n            robot = RobotEntity(robot_id, self._game_view.scene_entity)\n            self._game_view.add_asset(robot)\n            robot.sensors_emit_data_signal.connect(self.emit_sensors_data)\n            robot.setEnabled(False)\n            self._available_robots[robot_id] = robot\n\n        robot = self._available_robots.pop(robot_id)\n        robot.setEnabled(True)\n        self._robots[robot_id] = robot\n        if self._sensors_emulation.get(robot_id, False):\n            robot.start_sensors_emulation()\n\n    def del_robot(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n\n        Parameters:\n            robot_id: ID of the robot to remove\n        \"\"\"\n        robot = self._robots.pop(robot_id)\n        robot.stop_sensors_emulation()\n        robot.setEnabled(False)\n        self._available_robots[robot_id] = robot\n\n    def new_robot_pose_current(self, robot_id: int, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Set the robot's new pose current.\n\n        Arguments:\n            robot_id: ID of the robot\n            new_pose: new robot pose\n        \"\"\"\n        robot = self._robots.get(robot_id)\n        if robot:\n            robot.new_robot_pose_current(new_pose)\n\n    def new_robot_pose_order(self, robot_id: int, new_pose: Pose) -&gt; None:\n        \"\"\"\n        Set the robot's new pose order.\n\n        Arguments:\n            robot_id: ID of the robot\n            new_pose: new robot pose\n        \"\"\"\n        robot = self._robots.get(robot_id)\n        if robot:\n            robot.new_robot_pose_order(new_pose)\n\n    def start_sensors_emulation(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Start timers triggering sensors update and sensors data emission.\n\n        Arguments:\n            robot_id: ID of the robot\n        \"\"\"\n        self._sensors_emulation[robot_id] = True\n        robot = self._robots.get(robot_id)\n        if robot:\n            robot.start_sensors_emulation()\n\n    def stop_sensors_emulation(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Stop timers triggering sensors update and sensors data emission.\n\n        Arguments:\n            robot_id: ID of the robot\n        \"\"\"\n        self._sensors_emulation[robot_id] = False\n        robot = self._robots.get(robot_id)\n        if robot:\n            robot.start_sensors_emulation()\n\n    def emit_sensors_data(self, robot_id: int, data: list[int]) -&gt; None:\n        \"\"\"\n        Send sensors data to server.\n\n        Arguments:\n            robot_id: ID of the robot\n            data: List of distances for each angle\n        \"\"\"\n        self.sensors_emit_data_signal.emit(robot_id, data)\n\n    def set_dyn_obstacles(self, dyn_obstacles: DynObstacleList) -&gt; None:\n        \"\"\"\n        Qt Slot\n\n        Display the dynamic obstacles detected by the robot.\n\n        Reuse already created dynamic obstacles to optimize performance\n        and memory consumption.\n\n        Arguments:\n            dyn_obstacles: List of obstacles sent by the firmware through the serial port\n        \"\"\"\n        # Store new and already existing dyn obstacles\n        current_rect_obstacles = []\n        current_round_obstacles = []\n\n        for dyn_obstacle in dyn_obstacles:\n            if isinstance(dyn_obstacle, DynObstacleRect):\n                if len(self._rect_obstacles_pool):\n                    obstacle = self._rect_obstacles_pool.pop(0)\n                    obstacle.setEnabled(True)\n                else:\n                    obstacle = DynRectObstacleEntity(self._game_view.scene_entity)\n\n                obstacle.set_position(x=dyn_obstacle.x, y=dyn_obstacle.y, rotation=dyn_obstacle.angle)\n                obstacle.set_size(length=dyn_obstacle.length_y, width=dyn_obstacle.length_x)\n                obstacle.set_bounding_box(dyn_obstacle.bb)\n\n                current_rect_obstacles.append(obstacle)\n            else:\n                # Round obstacle\n                if len(self._round_obstacles_pool):\n                    obstacle = self._round_obstacles_pool.pop(0)\n                    obstacle.setEnabled(True)\n                else:\n                    obstacle = DynCircleObstacleEntity(self._game_view.scene_entity)\n\n                obstacle.set_position(x=dyn_obstacle.x, y=dyn_obstacle.y, radius=dyn_obstacle.radius)\n                obstacle.set_bounding_box(dyn_obstacle.bb)\n\n                current_round_obstacles.append(obstacle)\n\n        # Disable remaining dyn obstacles\n        while len(self._rect_obstacles_pool):\n            dyn_obstacle = self._rect_obstacles_pool.pop(0)\n            dyn_obstacle.setEnabled(False)\n            current_rect_obstacles.append(dyn_obstacle)\n\n        while len(self._round_obstacles_pool):\n            dyn_obstacle = self._round_obstacles_pool.pop(0)\n            dyn_obstacle.setEnabled(False)\n            current_round_obstacles.append(dyn_obstacle)\n\n        self._rect_obstacles_pool = current_rect_obstacles\n        self._round_obstacles_pool = current_round_obstacles\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.__init__","title":"<code>__init__(game_view)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>game_view</code> <code>GameView</code> <p>parent of the robots</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def __init__(self, game_view: GameView):\n    \"\"\"\n    Class constructor.\n\n    Parameters:\n        game_view: parent of the robots\n    \"\"\"\n    super().__init__()\n    self._game_view = game_view\n    self._robots: dict[int, RobotEntity] = dict()\n    self._available_robots: dict[int, RobotEntity] = dict()\n    self._rect_obstacles_pool: list[DynRectObstacleEntity] = []\n    self._round_obstacles_pool: list[DynCircleObstacleEntity] = []\n    self._sensors_emulation: dict[int, bool] = {}\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.add_robot","title":"<code>add_robot(robot_id, virtual=False)</code>","text":"<p>Add a new robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the new robot</p> required <code>virtual</code> <code>bool</code> <p>whether the robot is virtual or not</p> <code>False</code> Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def add_robot(self, robot_id: int, virtual: bool = False) -&gt; None:\n    \"\"\"\n    Add a new robot.\n\n    Parameters:\n        robot_id: ID of the new robot\n        virtual: whether the robot is virtual or not\n    \"\"\"\n    if robot_id in self._robots:\n        return\n\n    if self._available_robots.get(robot_id) is None:\n        robot = RobotEntity(robot_id, self._game_view.scene_entity)\n        self._game_view.add_asset(robot)\n        robot.sensors_emit_data_signal.connect(self.emit_sensors_data)\n        robot.setEnabled(False)\n        self._available_robots[robot_id] = robot\n\n    robot = self._available_robots.pop(robot_id)\n    robot.setEnabled(True)\n    self._robots[robot_id] = robot\n    if self._sensors_emulation.get(robot_id, False):\n        robot.start_sensors_emulation()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.del_robot","title":"<code>del_robot(robot_id)</code>","text":"<p>Remove a robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot to remove</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def del_robot(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Remove a robot.\n\n    Parameters:\n        robot_id: ID of the robot to remove\n    \"\"\"\n    robot = self._robots.pop(robot_id)\n    robot.stop_sensors_emulation()\n    robot.setEnabled(False)\n    self._available_robots[robot_id] = robot\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.emit_sensors_data","title":"<code>emit_sensors_data(robot_id, data)</code>","text":"<p>Send sensors data to server.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>data</code> <code>list[int]</code> <p>List of distances for each angle</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def emit_sensors_data(self, robot_id: int, data: list[int]) -&gt; None:\n    \"\"\"\n    Send sensors data to server.\n\n    Arguments:\n        robot_id: ID of the robot\n        data: List of distances for each angle\n    \"\"\"\n    self.sensors_emit_data_signal.emit(robot_id, data)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.new_robot_pose_current","title":"<code>new_robot_pose_current(robot_id, new_pose)</code>","text":"<p>Set the robot's new pose current.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def new_robot_pose_current(self, robot_id: int, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Set the robot's new pose current.\n\n    Arguments:\n        robot_id: ID of the robot\n        new_pose: new robot pose\n    \"\"\"\n    robot = self._robots.get(robot_id)\n    if robot:\n        robot.new_robot_pose_current(new_pose)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.new_robot_pose_order","title":"<code>new_robot_pose_order(robot_id, new_pose)</code>","text":"<p>Set the robot's new pose order.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>new_pose</code> <code>Pose</code> <p>new robot pose</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def new_robot_pose_order(self, robot_id: int, new_pose: Pose) -&gt; None:\n    \"\"\"\n    Set the robot's new pose order.\n\n    Arguments:\n        robot_id: ID of the robot\n        new_pose: new robot pose\n    \"\"\"\n    robot = self._robots.get(robot_id)\n    if robot:\n        robot.new_robot_pose_order(new_pose)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.set_dyn_obstacles","title":"<code>set_dyn_obstacles(dyn_obstacles)</code>","text":"<p>Qt Slot</p> <p>Display the dynamic obstacles detected by the robot.</p> <p>Reuse already created dynamic obstacles to optimize performance and memory consumption.</p> <p>Parameters:</p> Name Type Description Default <code>dyn_obstacles</code> <code>DynObstacleList</code> <p>List of obstacles sent by the firmware through the serial port</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def set_dyn_obstacles(self, dyn_obstacles: DynObstacleList) -&gt; None:\n    \"\"\"\n    Qt Slot\n\n    Display the dynamic obstacles detected by the robot.\n\n    Reuse already created dynamic obstacles to optimize performance\n    and memory consumption.\n\n    Arguments:\n        dyn_obstacles: List of obstacles sent by the firmware through the serial port\n    \"\"\"\n    # Store new and already existing dyn obstacles\n    current_rect_obstacles = []\n    current_round_obstacles = []\n\n    for dyn_obstacle in dyn_obstacles:\n        if isinstance(dyn_obstacle, DynObstacleRect):\n            if len(self._rect_obstacles_pool):\n                obstacle = self._rect_obstacles_pool.pop(0)\n                obstacle.setEnabled(True)\n            else:\n                obstacle = DynRectObstacleEntity(self._game_view.scene_entity)\n\n            obstacle.set_position(x=dyn_obstacle.x, y=dyn_obstacle.y, rotation=dyn_obstacle.angle)\n            obstacle.set_size(length=dyn_obstacle.length_y, width=dyn_obstacle.length_x)\n            obstacle.set_bounding_box(dyn_obstacle.bb)\n\n            current_rect_obstacles.append(obstacle)\n        else:\n            # Round obstacle\n            if len(self._round_obstacles_pool):\n                obstacle = self._round_obstacles_pool.pop(0)\n                obstacle.setEnabled(True)\n            else:\n                obstacle = DynCircleObstacleEntity(self._game_view.scene_entity)\n\n            obstacle.set_position(x=dyn_obstacle.x, y=dyn_obstacle.y, radius=dyn_obstacle.radius)\n            obstacle.set_bounding_box(dyn_obstacle.bb)\n\n            current_round_obstacles.append(obstacle)\n\n    # Disable remaining dyn obstacles\n    while len(self._rect_obstacles_pool):\n        dyn_obstacle = self._rect_obstacles_pool.pop(0)\n        dyn_obstacle.setEnabled(False)\n        current_rect_obstacles.append(dyn_obstacle)\n\n    while len(self._round_obstacles_pool):\n        dyn_obstacle = self._round_obstacles_pool.pop(0)\n        dyn_obstacle.setEnabled(False)\n        current_round_obstacles.append(dyn_obstacle)\n\n    self._rect_obstacles_pool = current_rect_obstacles\n    self._round_obstacles_pool = current_round_obstacles\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.start_sensors_emulation","title":"<code>start_sensors_emulation(robot_id)</code>","text":"<p>Start timers triggering sensors update and sensors data emission.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def start_sensors_emulation(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Start timers triggering sensors update and sensors data emission.\n\n    Arguments:\n        robot_id: ID of the robot\n    \"\"\"\n    self._sensors_emulation[robot_id] = True\n    robot = self._robots.get(robot_id)\n    if robot:\n        robot.start_sensors_emulation()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/robots/#cogip.tools.monitor.robots.RobotManager.stop_sensors_emulation","title":"<code>stop_sensors_emulation(robot_id)</code>","text":"<p>Stop timers triggering sensors update and sensors data emission.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required Source code in <code>cogip/tools/monitor/robots.py</code> <pre><code>def stop_sensors_emulation(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Stop timers triggering sensors update and sensors data emission.\n\n    Arguments:\n        robot_id: ID of the robot\n    \"\"\"\n    self._sensors_emulation[robot_id] = False\n    robot = self._robots.get(robot_id)\n    if robot:\n        robot.start_sensors_emulation()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/","title":"socketiocontroller","text":""},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController","title":"<code>SocketioController</code>","text":"<p>               Bases: <code>QObject</code></p> <p>This class controls the socket.io port used to communicate with the server. Its main purpose is to get the shell and tool menus to update the interface, get the robot position to update its position, and send the commands to the robot and to the tools.</p> <p>Attributes:</p> Name Type Description <code>signal_new_console_text</code> <code>Signal</code> <p>Qt signal emitted to log messages in UI console</p> <code>signal_new_menu</code> <code>Signal</code> <p>Qt signal emitted to load a new shell/tool menu</p> <code>signal_new_robot_pose_current</code> <code>Signal</code> <p>Qt signal emitted on robot pose current update</p> <code>signal_new_robot_pose_order</code> <code>Signal</code> <p>Qt signal emitted on robot pose order update</p> <code>signal_new_robot_state</code> <code>Signal</code> <p>Qt signal emitted on robot state update</p> <code>signal_new_robot_path</code> <code>Signal</code> <p>Qt signal emitted on robot path update</p> <code>signal_new_dyn_obstacles</code> <code>Signal</code> <p>Qt signal emitted on dynamic obstacles update</p> <code>signal_connected</code> <code>Signal</code> <p>Qt signal emitted on server connection state changes</p> <code>signal_exit</code> <code>Signal</code> <p>Qt signal emitted to exit Monitor</p> <code>signal_add_robot</code> <code>Signal</code> <p>Qt signal emitted to add a new robot</p> <code>signal_del_robot</code> <code>Signal</code> <p>Qt signal emitted to remove a robot</p> <code>signal_wizard_request</code> <code>Signal</code> <p>Qt signal emitted to forward wizard requests</p> <code>signal_start_sensors_emulation</code> <code>Signal</code> <p>Qt signal emitted to start sensors emulation</p> <code>signal_stop_sensors_emulation</code> <code>Signal</code> <p>Qt signal emitted to stop sensors emulation</p> <code>signal_config_request</code> <code>Signal</code> <p>Qt signal emitted to load a new shell/tool menu</p> <code>signal_planner_reset</code> <code>Signal</code> <p>Qt signal emitted on Planner reset command</p> <code>signal_starter_changed</code> <code>Signal</code> <p>Qt signal emitted the starter state has changed</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>class SocketioController(QtCore.QObject):\n    \"\"\"\n    This class controls the socket.io port used to communicate with the server.\n    Its main purpose is to get the shell and tool menus to update the interface,\n    get the robot position to update its position, and send the commands\n    to the robot and to the tools.\n\n    Attributes:\n        signal_new_console_text:\n            Qt signal emitted to log messages in UI console\n        signal_new_menu:\n            Qt signal emitted to load a new shell/tool menu\n        signal_new_robot_pose_current:\n            Qt signal emitted on robot pose current update\n        signal_new_robot_pose_order:\n            Qt signal emitted on robot pose order update\n        signal_new_robot_state:\n            Qt signal emitted on robot state update\n        signal_new_robot_path:\n            Qt signal emitted on robot path update\n        signal_new_dyn_obstacles:\n            Qt signal emitted on dynamic obstacles update\n        signal_connected:\n            Qt signal emitted on server connection state changes\n        signal_exit:\n            Qt signal emitted to exit Monitor\n        signal_add_robot:\n            Qt signal emitted to add a new robot\n        signal_del_robot:\n            Qt signal emitted to remove a robot\n        signal_wizard_request:\n            Qt signal emitted to forward wizard requests\n        signal_start_sensors_emulation:\n            Qt signal emitted to start sensors emulation\n        signal_stop_sensors_emulation:\n            Qt signal emitted to stop sensors emulation\n        signal_config_request:\n            Qt signal emitted to load a new shell/tool menu\n        signal_planner_reset:\n            Qt signal emitted on Planner reset command\n        signal_starter_changed:\n            Qt signal emitted the starter state has changed\n    \"\"\"\n\n    signal_new_console_text: qtSignal = qtSignal(str)\n    signal_new_menu: qtSignal = qtSignal(str, models.ShellMenu)\n    signal_new_robot_pose_current: qtSignal = qtSignal(int, models.Pose)\n    signal_new_robot_pose_order: qtSignal = qtSignal(int, models.Pose)\n    signal_new_robot_state: qtSignal = qtSignal(int, models.RobotState)\n    signal_new_robot_path: qtSignal = qtSignal(int, list)\n    signal_new_dyn_obstacles: qtSignal = qtSignal(list)\n    signal_connected: qtSignal = qtSignal(bool)\n    signal_exit: qtSignal = qtSignal()\n    signal_add_robot: qtSignal = qtSignal(int, bool)\n    signal_del_robot: qtSignal = qtSignal(int)\n    signal_wizard_request: qtSignal = qtSignal(dict)\n    signal_close_wizard: qtSignal = qtSignal()\n    signal_start_sensors_emulation: qtSignal = qtSignal(int)\n    signal_stop_sensors_emulation: qtSignal = qtSignal(int)\n    signal_config_request: qtSignal = qtSignal(dict)\n    signal_actuator_state: qtSignal = qtSignal(object)\n    signal_planner_reset: qtSignal = qtSignal()\n    signal_starter_changed: qtSignal = qtSignal(int, bool)\n\n    def __init__(self, url: str):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            url: URL to socket.io server\n        \"\"\"\n        super().__init__()\n\n        self.url = url\n        self.sio = socketio.Client()\n        self.register_handlers()\n\n        self.menus: dict[str, models.ShellMenu | None] = {}\n\n    def start(self):\n        \"\"\"\n        Connect to socket.io server.\n        \"\"\"\n        # Poll in background to wait for the first connection.\n        # Disconnections/reconnections are handle directly by the client.\n        self._retry_connection = True\n        Thread(target=self.try_connect).start()\n\n    def try_connect(self):\n        while self._retry_connection:\n            try:\n                self.sio.connect(self.url, namespaces=[\"/monitor\", \"/dashboard\"])\n            except socketio.exceptions.ConnectionError as ex:\n                print(ex)\n                time.sleep(2)\n                continue\n            break\n\n    def stop(self):\n        \"\"\"\n        Disconnect from socket.io server.\n        \"\"\"\n        self._retry_connection = False\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    @qtSlot(str)\n    def new_command(self, menu_name: str, command: str):\n        \"\"\"\n        Send a command to the robot.\n\n        Arguments:\n            menu_name: menu to update (\"shell\", \"tool\", ...)\n            command: Command to send\n        \"\"\"\n        name, _, robot_id = menu_name.partition(\" \")\n        if name == \"shell\":\n            self.sio.emit(\"shell_cmd\", command, namespace=\"/dashboard\")\n        else:\n            self.sio.emit(f\"{menu_name}_cmd\", command, namespace=\"/dashboard\")\n        self.signal_new_console_text.emit(f\"Send '{command}' to {menu_name}\")\n\n    @qtSlot(dict)\n    def config_updated(self, config: dict[str, Any]):\n        self.sio.emit(\"config_updated\", config, namespace=\"/dashboard\")\n\n    @qtSlot(dict)\n    def wizard_response(self, response: dict[str, Any]):\n        self.sio.emit(\"wizard\", response, namespace=\"/dashboard\")\n\n    def new_actuator_command(self, command: ActuatorCommand):\n        \"\"\"\n        Send an actuator command to the robot.\n\n        Arguments:\n            command: actuator command to send\n        \"\"\"\n        self.sio.emit(\"actuator_command\", command.model_dump(mode=\"json\"), namespace=\"/dashboard\")\n\n    def actuators_started(self):\n        \"\"\"\n        Request to start emitting actuators state from the robot.\n        \"\"\"\n        self.sio.emit(\"actuators_start\", namespace=\"/dashboard\")\n\n    def actuators_closed(self):\n        \"\"\"\n        Request to stop emitting actuators state from the robot.\n        \"\"\"\n        self.sio.emit(\"actuators_stop\", namespace=\"/dashboard\")\n\n    @qtSlot(int, bool)\n    def starter_changed(self, robot_id, pushed: bool):\n        self.sio.emit(\"starter_changed\", pushed, namespace=\"/monitor\")\n\n    def on_menu(self, menu_name: str, data):\n        menu = models.ShellMenu.model_validate(data)\n        if self.menus.get(menu_name) != menu:\n            self.menus[menu_name] = menu\n            self.signal_new_menu.emit(menu_name, menu)\n\n    def register_handlers(self):\n        \"\"\"\n        Define socket.io message handlers.\n        \"\"\"\n\n        @self.sio.on(\"connect\", namespace=\"/dashboard\")\n        def dashboard_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Dashboard connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n        @self.sio.on(\"connect\", namespace=\"/monitor\")\n        def monitor_connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Monitor connected to cogip-server\")\n            self.sio.emit(\"connected\", namespace=\"/monitor\")\n            self.signal_new_console_text.emit(\"Connected to server\")\n            self.signal_connected.emit(True)\n\n        @self.sio.event(namespace=\"/monitor\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            if (\n                data\n                and isinstance(data, dict)\n                and (message := data.get(\"message\"))\n                and message == \"A monitor is already connected\"\n            ):\n                logger.error(f\"Error: {message}.\")\n                self._retry_connection = False\n                self.signal_exit.emit()\n                return\n            logger.error(f\"Monitor connection error: {data}\")\n            self.signal_new_console_text.emit(\"Connection to server failed.\")\n            self.signal_connected.emit(False)\n\n        @self.sio.event(namespace=\"/dashboard\")\n        def dashboard_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Dashboard disconnected from cogip-server\")\n\n        @self.sio.event(namespace=\"/monitor\")\n        def monitor_disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            self.signal_new_console_text.emit(\"Disconnected from server.\")\n            self.signal_connected.emit(False)\n            logger.info(\"Monitor disconnected from cogip-server\")\n\n        @self.sio.on(\"shell_menu\", namespace=\"/dashboard\")\n        def on_shell_menu(robot_id: int, menu: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on shell menu message.\n            \"\"\"\n            self.on_menu(f\"shell {robot_id}\", menu)\n\n        @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n        def on_tool_menu(data):\n            \"\"\"\n            Callback on tool menu message.\n            \"\"\"\n            self.on_menu(\"tool\", data)\n\n        @self.sio.on(\"config\", namespace=\"/dashboard\")\n        def on_config(config):\n            \"\"\"\n            Callback on config request.\n            \"\"\"\n            self.signal_config_request.emit(config)\n\n        @self.sio.on(\"actuator_state\", namespace=\"/dashboard\")\n        def on_actuator_state(actuator_state):\n            \"\"\"\n            Callback on actuator_state message.\n            \"\"\"\n            try:\n                state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n                self.signal_actuator_state.emit(state)\n            except ValidationError as exc:\n                logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n\n        @self.sio.on(\"pose_current\", namespace=\"/dashboard\")\n        def on_pose_current(robot_id: int, data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on robot pose current message.\n            \"\"\"\n            pose = models.Pose.model_validate(data)\n            self.signal_new_robot_pose_current.emit(robot_id, pose)\n\n        @self.sio.on(\"pose_order\", namespace=\"/dashboard\")\n        def on_pose_order(robot_id: int, data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on robot pose order message.\n            \"\"\"\n            pose = models.Pose.model_validate(data)\n            self.signal_new_robot_pose_order.emit(robot_id, pose)\n\n        @self.sio.on(\"state\", namespace=\"/dashboard\")\n        def on_state(robot_id: int, data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Callback on robot state message.\n            \"\"\"\n            state = models.RobotState.model_validate(data)\n            self.signal_new_robot_state.emit(robot_id, state)\n\n        @self.sio.on(\"path\", namespace=\"/dashboard\")\n        def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n            \"\"\"\n            Callback on robot path message.\n            \"\"\"\n            path = TypeAdapter(list[models.Vertex]).validate_python(data)\n            self.signal_new_robot_path.emit(robot_id, path)\n\n        @self.sio.on(\"obstacles\", namespace=\"/dashboard\")\n        def on_obstacles(data):\n            \"\"\"\n            Callback on obstacles message.\n            \"\"\"\n            obstacles = TypeAdapter(models.DynObstacleList).validate_python(data)\n            self.signal_new_dyn_obstacles.emit(obstacles)\n\n        @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n        def on_add_robot(robot_id: int, virtual: bool) -&gt; None:\n            \"\"\"\n            Add a new robot.\n            \"\"\"\n            self.signal_add_robot.emit(int(robot_id), virtual)\n\n        @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n        def on_del_robot(robot_id: int) -&gt; None:\n            \"\"\"\n            Remove a robot.\n            \"\"\"\n            self.signal_del_robot.emit(robot_id)\n\n        @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n        def on_wizard_request(data: dict[str, Any]) -&gt; None:\n            \"\"\"\n            Wizard request.\n            \"\"\"\n            self.signal_wizard_request.emit(data)\n\n        @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n        def on_close_wizard() -&gt; None:\n            \"\"\"\n            Close wizard.\n            \"\"\"\n            self.signal_close_wizard.emit()\n\n        @self.sio.on(\"start_sensors_emulation\", namespace=\"/monitor\")\n        def on_start_sensors_emulation(robot_id: int) -&gt; None:\n            \"\"\"\n            Start sensors emulation.\n            \"\"\"\n            self.signal_start_sensors_emulation.emit(robot_id)\n\n        @self.sio.on(\"stop_sensors_emulation\", namespace=\"/monitor\")\n        def on_stop_sensors_emulation(robot_id: int) -&gt; None:\n            \"\"\"\n            Stop sensors emulation.\n            \"\"\"\n            self.signal_stop_sensors_emulation.emit(robot_id)\n\n        @self.sio.on(\"cmd_reset\", namespace=\"/monitor\")\n        def on_cmd_reset() -&gt; None:\n            \"\"\"\n            Reset command from Planner.\n            \"\"\"\n            self.signal_planner_reset.emit()\n\n        @self.sio.on(\"starter_changed\", namespace=\"/monitor\")\n        def on_starter_changed(robot_id: int, pushed: bool) -&gt; None:\n            \"\"\"\n            Change the state of a starter.\n            \"\"\"\n            self.signal_starter_changed.emit(robot_id, pushed)\n\n    def emit_sensors_data(self, robot_id: int, data: list[int]) -&gt; None:\n        \"\"\"\n        Send sensors data to server.\n\n        Arguments:\n            robot_id: ID of the robot\n            data: List of distances for each angle\n        \"\"\"\n        if self.sio.connected:\n            self.sio.emit(\"sensors_data\", data, namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.__init__","title":"<code>__init__(url)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to socket.io server</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def __init__(self, url: str):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        url: URL to socket.io server\n    \"\"\"\n    super().__init__()\n\n    self.url = url\n    self.sio = socketio.Client()\n    self.register_handlers()\n\n    self.menus: dict[str, models.ShellMenu | None] = {}\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.actuators_closed","title":"<code>actuators_closed()</code>","text":"<p>Request to stop emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def actuators_closed(self):\n    \"\"\"\n    Request to stop emitting actuators state from the robot.\n    \"\"\"\n    self.sio.emit(\"actuators_stop\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.actuators_started","title":"<code>actuators_started()</code>","text":"<p>Request to start emitting actuators state from the robot.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def actuators_started(self):\n    \"\"\"\n    Request to start emitting actuators state from the robot.\n    \"\"\"\n    self.sio.emit(\"actuators_start\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.emit_sensors_data","title":"<code>emit_sensors_data(robot_id, data)</code>","text":"<p>Send sensors data to server.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>data</code> <code>list[int]</code> <p>List of distances for each angle</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def emit_sensors_data(self, robot_id: int, data: list[int]) -&gt; None:\n    \"\"\"\n    Send sensors data to server.\n\n    Arguments:\n        robot_id: ID of the robot\n        data: List of distances for each angle\n    \"\"\"\n    if self.sio.connected:\n        self.sio.emit(\"sensors_data\", data, namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.new_actuator_command","title":"<code>new_actuator_command(command)</code>","text":"<p>Send an actuator command to the robot.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>ActuatorCommand</code> <p>actuator command to send</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def new_actuator_command(self, command: ActuatorCommand):\n    \"\"\"\n    Send an actuator command to the robot.\n\n    Arguments:\n        command: actuator command to send\n    \"\"\"\n    self.sio.emit(\"actuator_command\", command.model_dump(mode=\"json\"), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.new_command","title":"<code>new_command(menu_name, command)</code>","text":"<p>Send a command to the robot.</p> <p>Parameters:</p> Name Type Description Default <code>menu_name</code> <code>str</code> <p>menu to update (\"shell\", \"tool\", ...)</p> required <code>command</code> <code>str</code> <p>Command to send</p> required Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>@qtSlot(str)\ndef new_command(self, menu_name: str, command: str):\n    \"\"\"\n    Send a command to the robot.\n\n    Arguments:\n        menu_name: menu to update (\"shell\", \"tool\", ...)\n        command: Command to send\n    \"\"\"\n    name, _, robot_id = menu_name.partition(\" \")\n    if name == \"shell\":\n        self.sio.emit(\"shell_cmd\", command, namespace=\"/dashboard\")\n    else:\n        self.sio.emit(f\"{menu_name}_cmd\", command, namespace=\"/dashboard\")\n    self.signal_new_console_text.emit(f\"Send '{command}' to {menu_name}\")\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.register_handlers","title":"<code>register_handlers()</code>","text":"<p>Define socket.io message handlers.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def register_handlers(self):\n    \"\"\"\n    Define socket.io message handlers.\n    \"\"\"\n\n    @self.sio.on(\"connect\", namespace=\"/dashboard\")\n    def dashboard_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Dashboard connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/dashboard\")\n\n    @self.sio.on(\"connect\", namespace=\"/monitor\")\n    def monitor_connect():\n        \"\"\"\n        Callback on server connection.\n        \"\"\"\n        polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n        logger.info(\"Monitor connected to cogip-server\")\n        self.sio.emit(\"connected\", namespace=\"/monitor\")\n        self.signal_new_console_text.emit(\"Connected to server\")\n        self.signal_connected.emit(True)\n\n    @self.sio.event(namespace=\"/monitor\")\n    def connect_error(data):\n        \"\"\"\n        Callback on server connection error.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A monitor is already connected\"\n        ):\n            logger.error(f\"Error: {message}.\")\n            self._retry_connection = False\n            self.signal_exit.emit()\n            return\n        logger.error(f\"Monitor connection error: {data}\")\n        self.signal_new_console_text.emit(\"Connection to server failed.\")\n        self.signal_connected.emit(False)\n\n    @self.sio.event(namespace=\"/dashboard\")\n    def dashboard_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        logger.info(\"Dashboard disconnected from cogip-server\")\n\n    @self.sio.event(namespace=\"/monitor\")\n    def monitor_disconnect():\n        \"\"\"\n        Callback on server disconnection.\n        \"\"\"\n        self.signal_new_console_text.emit(\"Disconnected from server.\")\n        self.signal_connected.emit(False)\n        logger.info(\"Monitor disconnected from cogip-server\")\n\n    @self.sio.on(\"shell_menu\", namespace=\"/dashboard\")\n    def on_shell_menu(robot_id: int, menu: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on shell menu message.\n        \"\"\"\n        self.on_menu(f\"shell {robot_id}\", menu)\n\n    @self.sio.on(\"tool_menu\", namespace=\"/dashboard\")\n    def on_tool_menu(data):\n        \"\"\"\n        Callback on tool menu message.\n        \"\"\"\n        self.on_menu(\"tool\", data)\n\n    @self.sio.on(\"config\", namespace=\"/dashboard\")\n    def on_config(config):\n        \"\"\"\n        Callback on config request.\n        \"\"\"\n        self.signal_config_request.emit(config)\n\n    @self.sio.on(\"actuator_state\", namespace=\"/dashboard\")\n    def on_actuator_state(actuator_state):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        try:\n            state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n            self.signal_actuator_state.emit(state)\n        except ValidationError as exc:\n            logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n\n    @self.sio.on(\"pose_current\", namespace=\"/dashboard\")\n    def on_pose_current(robot_id: int, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot pose current message.\n        \"\"\"\n        pose = models.Pose.model_validate(data)\n        self.signal_new_robot_pose_current.emit(robot_id, pose)\n\n    @self.sio.on(\"pose_order\", namespace=\"/dashboard\")\n    def on_pose_order(robot_id: int, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot pose order message.\n        \"\"\"\n        pose = models.Pose.model_validate(data)\n        self.signal_new_robot_pose_order.emit(robot_id, pose)\n\n    @self.sio.on(\"state\", namespace=\"/dashboard\")\n    def on_state(robot_id: int, data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Callback on robot state message.\n        \"\"\"\n        state = models.RobotState.model_validate(data)\n        self.signal_new_robot_state.emit(robot_id, state)\n\n    @self.sio.on(\"path\", namespace=\"/dashboard\")\n    def on_path(robot_id: int, data: list[dict[str, float]]) -&gt; None:\n        \"\"\"\n        Callback on robot path message.\n        \"\"\"\n        path = TypeAdapter(list[models.Vertex]).validate_python(data)\n        self.signal_new_robot_path.emit(robot_id, path)\n\n    @self.sio.on(\"obstacles\", namespace=\"/dashboard\")\n    def on_obstacles(data):\n        \"\"\"\n        Callback on obstacles message.\n        \"\"\"\n        obstacles = TypeAdapter(models.DynObstacleList).validate_python(data)\n        self.signal_new_dyn_obstacles.emit(obstacles)\n\n    @self.sio.on(\"add_robot\", namespace=\"/monitor\")\n    def on_add_robot(robot_id: int, virtual: bool) -&gt; None:\n        \"\"\"\n        Add a new robot.\n        \"\"\"\n        self.signal_add_robot.emit(int(robot_id), virtual)\n\n    @self.sio.on(\"del_robot\", namespace=\"/monitor\")\n    def on_del_robot(robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n        \"\"\"\n        self.signal_del_robot.emit(robot_id)\n\n    @self.sio.on(\"wizard\", namespace=\"/dashboard\")\n    def on_wizard_request(data: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Wizard request.\n        \"\"\"\n        self.signal_wizard_request.emit(data)\n\n    @self.sio.on(\"close_wizard\", namespace=\"/dashboard\")\n    def on_close_wizard() -&gt; None:\n        \"\"\"\n        Close wizard.\n        \"\"\"\n        self.signal_close_wizard.emit()\n\n    @self.sio.on(\"start_sensors_emulation\", namespace=\"/monitor\")\n    def on_start_sensors_emulation(robot_id: int) -&gt; None:\n        \"\"\"\n        Start sensors emulation.\n        \"\"\"\n        self.signal_start_sensors_emulation.emit(robot_id)\n\n    @self.sio.on(\"stop_sensors_emulation\", namespace=\"/monitor\")\n    def on_stop_sensors_emulation(robot_id: int) -&gt; None:\n        \"\"\"\n        Stop sensors emulation.\n        \"\"\"\n        self.signal_stop_sensors_emulation.emit(robot_id)\n\n    @self.sio.on(\"cmd_reset\", namespace=\"/monitor\")\n    def on_cmd_reset() -&gt; None:\n        \"\"\"\n        Reset command from Planner.\n        \"\"\"\n        self.signal_planner_reset.emit()\n\n    @self.sio.on(\"starter_changed\", namespace=\"/monitor\")\n    def on_starter_changed(robot_id: int, pushed: bool) -&gt; None:\n        \"\"\"\n        Change the state of a starter.\n        \"\"\"\n        self.signal_starter_changed.emit(robot_id, pushed)\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.start","title":"<code>start()</code>","text":"<p>Connect to socket.io server.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def start(self):\n    \"\"\"\n    Connect to socket.io server.\n    \"\"\"\n    # Poll in background to wait for the first connection.\n    # Disconnections/reconnections are handle directly by the client.\n    self._retry_connection = True\n    Thread(target=self.try_connect).start()\n</code></pre>"},{"location":"reference/cogip/tools/monitor/socketiocontroller/#cogip.tools.monitor.socketiocontroller.SocketioController.stop","title":"<code>stop()</code>","text":"<p>Disconnect from socket.io server.</p> Source code in <code>cogip/tools/monitor/socketiocontroller.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Disconnect from socket.io server.\n    \"\"\"\n    self._retry_connection = False\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/planner/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/planner/__main__/#cogip.tools.planner.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP Game Planner.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-planner</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/planner/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP Game Planner.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-planner` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actuators/","title":"actuators","text":""},{"location":"reference/cogip/tools/planner/cameras/","title":"cameras","text":""},{"location":"reference/cogip/tools/planner/camp/","title":"camp","text":""},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp","title":"<code>Camp</code>","text":"<p>Class representing the camp selected before the game starts.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>class Camp(metaclass=Singleton):\n    \"\"\"\n    Class representing the camp selected before the game starts.\n    \"\"\"\n\n    class Colors(IntEnum):\n        blue = 0\n        yellow = 1\n\n    def __init__(self, color: Colors = Colors.yellow):\n        self.color = color\n\n    def adapt_y(self, dist: float) -&gt; float:\n        \"\"\"\n        Adapt Y distance depending on the selected camp.\n        Given the current table orientation and axes,\n        only Y has to be adapted when the camp changes.\n        \"\"\"\n        return dist if self.color == Camp.Colors.yellow else -dist\n\n    def adapt_angle(self, angle: float | None) -&gt; float | None:\n        \"\"\"\n        Adapt an angle depending on the actual camp.\n        \"\"\"\n        if angle is None:\n            return None\n        return angle if self.color == Camp.Colors.yellow else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_angle","title":"<code>adapt_angle(angle)</code>","text":"<p>Adapt an angle depending on the actual camp.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_angle(self, angle: float | None) -&gt; float | None:\n    \"\"\"\n    Adapt an angle depending on the actual camp.\n    \"\"\"\n    if angle is None:\n        return None\n    return angle if self.color == Camp.Colors.yellow else -angle\n</code></pre>"},{"location":"reference/cogip/tools/planner/camp/#cogip.tools.planner.camp.Camp.adapt_y","title":"<code>adapt_y(dist)</code>","text":"<p>Adapt Y distance depending on the selected camp. Given the current table orientation and axes, only Y has to be adapted when the camp changes.</p> Source code in <code>cogip/tools/planner/camp.py</code> <pre><code>def adapt_y(self, dist: float) -&gt; float:\n    \"\"\"\n    Adapt Y distance depending on the selected camp.\n    Given the current table orientation and axes,\n    only Y has to be adapted when the camp changes.\n    \"\"\"\n    return dist if self.color == Camp.Colors.yellow else -dist\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/","title":"context","text":""},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext","title":"<code>GameContext</code>","text":"<p>A class recording the current game context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>class GameContext(metaclass=Singleton):\n    \"\"\"\n    A class recording the current game context.\n    \"\"\"\n\n    def __init__(self):\n        self.properties = Properties()\n        self.game_duration: int = 90 if self.properties.robot_id == 1 else 100\n        self.minimum_score: int = 0\n        self.camp = Camp()\n        self.strategy = actions.Strategy.GameSolarFirst\n        self._table = TableEnum.Game\n        self.avoidance_strategy = AvoidanceStrategy.VisibilityRoadMapQuadPid\n        self.reset()\n\n    @property\n    def table(self) -&gt; Table:\n        \"\"\"\n        Selected table.\n        \"\"\"\n        return tables[self._table]\n\n    @table.setter\n    def table(self, new_table: TableEnum):\n        self._table = new_table\n\n    def reset(self):\n        \"\"\"\n        Reset the context.\n        \"\"\"\n        self.playing = False\n        self.score = self.minimum_score\n        self.countdown = self.game_duration\n        self.create_artifacts()\n        self.create_fixed_obstacles()\n        self.create_actuators_states()\n\n    @property\n    def default_controller(self) -&gt; ControllerEnum:\n        match self.strategy:\n            case actions.Strategy.AngularSpeedTest:\n                return ControllerEnum.ANGULAR_SPEED_TEST\n            case actions.Strategy.LinearSpeedTest:\n                return ControllerEnum.LINEAR_SPEED_TEST\n            case _:\n                return ControllerEnum.QUADPID\n\n    def get_start_pose(self, n: StartPosition) -&gt; Pose:\n        \"\"\"\n        Define the possible start positions.\n        Default positions for yellow camp.\n        \"\"\"\n        match n:\n            case StartPosition.Top:\n                return AdaptedPose(\n                    x=1000 - 450 + self.properties.robot_width / 2,\n                    y=-(1500 - 450 + self.properties.robot_length / 2),\n                    O=90,\n                )\n            case StartPosition.Bottom:\n                pose = AdaptedPose(\n                    x=-785,\n                    y=-1285,\n                    O=90,\n                )\n                if self.camp.color == Camp.Colors.blue and self.strategy == actions.Strategy.GameSolarFirst:\n                    pose.O = 90\n                return pose\n            case StartPosition.Opposite:\n                return AdaptedPose(\n                    x=-450 / 2 + self.properties.robot_width / 2,\n                    y=1500 - 450 + self.properties.robot_width / 2,\n                    O=-90,\n                )\n            case StartPosition.PAMI2:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_length / 2,\n                    y=-self.properties.robot_width / 2,\n                    O=180,\n                )\n            case StartPosition.PAMI3:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_width / 2,\n                    y=-33,\n                    O=-90,\n                )\n            case StartPosition.PAMI4:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_width / 2,\n                    y=-(450 - self.properties.robot_length / 2),\n                    O=-90,\n                )\n            case StartPosition.PAMI2_TRAINING:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_length / 2 - 1000,\n                    y=-self.properties.robot_width / 2,\n                    O=180,\n                )\n            case StartPosition.PAMI3_TRAINING:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_length / 2 - 1000,\n                    y=-450 / 2,\n                    O=180,\n                )\n            case StartPosition.PAMI4_TRAINING:\n                return AdaptedPose(\n                    x=1000 - 150 + self.properties.robot_width / 2 - 1000,\n                    y=-(450 - self.properties.robot_length / 2),\n                    O=-90,\n                )\n            case _:\n                return AdaptedPose()\n\n    def get_available_start_poses(self) -&gt; list[StartPosition]:\n        \"\"\"\n        Get start poses available depending on camp and table.\n        \"\"\"\n        start_pose_indices = []\n        for p in StartPosition:\n            pose = self.get_start_pose(p)\n            if self.table.contains(pose):\n                start_pose_indices.append(p)\n        return start_pose_indices\n\n    def create_artifacts(self):\n        # Positions are related to the default camp yellow.\n        self.plant_supplies: dict[PlantSupplyID, PlantSupply] = {}\n        self.pot_supplies: dict[PotSupplyID, PotSupply] = {}\n        self.dropoff_zones: dict[DropoffZoneID, DropoffZone] = {}\n        self.planters: dict[PlanterID, Planter] = {}\n        self.solar_panels: dict[SolarPanelsID, SolarPanels] = {}\n\n        bb_radius = 125 + self.properties.robot_width / 2\n\n        # Plant supplies\n        plant_supply_positions = {\n            PlantSupplyID.CenterTop: AdaptedPose(x=500, y=0),\n            PlantSupplyID.CenterBottom: AdaptedPose(x=-500, y=0),\n            PlantSupplyID.LocalTop: AdaptedPose(x=300, y=-500),\n            PlantSupplyID.LocalBottom: AdaptedPose(x=-300, y=-500),\n            PlantSupplyID.OppositeTop: AdaptedPose(x=300, y=500),\n            PlantSupplyID.OppositeBottom: AdaptedPose(x=-300, y=500),\n        }\n        for id, pose in plant_supply_positions.items():\n            plant_supply = PlantSupply(id=id, x=pose.x, y=pose.y, radius=125)\n            self.plant_supplies[id] = plant_supply\n\n        # Disable unused plant supplies\n        self.plant_supplies[PlantSupplyID.OppositeTop].enabled = False\n        self.plant_supplies[PlantSupplyID.OppositeBottom].enabled = False\n        self.plant_supplies[PlantSupplyID.CenterTop].enabled = False\n\n        for plant_supply in self.plant_supplies.values():\n            plant_supply.create_bounding_box(bb_radius, self.properties.obstacle_bb_vertices)\n\n        # Pot supplies\n        pot_supply_positions = {\n            PotSupplyID.LocalTop: AdaptedPose(x=450 / 2 + 325 / 2, y=-1500 + 35, O=-90),\n            PotSupplyID.LocalMiddle: AdaptedPose(x=-450 / 2 - 325 / 2, y=-1500 + 35, O=-90),\n            PotSupplyID.LocalBottom: AdaptedPose(x=-1000 + 35, y=-500, O=180),\n            PotSupplyID.OppositeTop: AdaptedPose(x=450 / 2 + 325 / 2, y=1500 - 35, O=90),\n            PotSupplyID.OppositeMiddle: AdaptedPose(x=-450 / 2 - 325 / 2, y=1500 - 35, O=90),\n            PotSupplyID.OppositeBottom: AdaptedPose(x=-1000 + 35, y=500, O=180),\n        }\n        for id, pose in pot_supply_positions.items():\n            pot_supply = PotSupply(id=id, x=pose.x, y=pose.y, radius=125, angle=pose.O)\n            self.pot_supplies[id] = pot_supply\n\n        # Disable unused pot supplies\n        self.pot_supplies[PotSupplyID.OppositeTop].enabled = False\n        self.pot_supplies[PotSupplyID.OppositeMiddle].enabled = False\n        self.pot_supplies[PotSupplyID.OppositeBottom].enabled = False\n\n        for pot_supply in self.pot_supplies.values():\n            pot_supply.create_bounding_box(bb_radius, self.properties.obstacle_bb_vertices)\n\n        # Drop-off zones\n        dropoff_zone_positions = {\n            DropoffZoneID.Top: AdaptedPose(x=1000 - 450 / 2, y=-1500 + 450 / 2),\n            DropoffZoneID.Bottom: AdaptedPose(x=-1000 + 450 / 2, y=-1500 + 450 / 2),\n            DropoffZoneID.Opposite: AdaptedPose(x=0, y=1500 - 450 / 2),\n        }\n        for id, pose in dropoff_zone_positions.items():\n            self.dropoff_zones[id] = DropoffZone(id=id, x=pose.x, y=pose.y)\n\n        # Planters\n        planter_positions = {\n            PlanterID.Top: AdaptedPose(x=1000, y=-1500 + 600 + 325 / 2, O=0),\n            PlanterID.LocalSide: AdaptedPose(x=450 / 2 + 325 / 2, y=-1500, O=-90),\n            PlanterID.OppositeSide: AdaptedPose(x=-450 / 2 - 325 / 2, y=1500, O=90),\n            PlanterID.Test: AdaptedPose(x=-450 / 2 - 325 / 2, y=-1500, O=-90),\n        }\n        for id, pose in planter_positions.items():\n            self.planters[id] = Planter(id=id, x=pose.x, y=pose.y, O=pose.O)\n\n        # Solar panels\n        solar_panels_positions = {\n            SolarPanelsID.Local: AdaptedPose(x=-1000, y=-1000),\n            SolarPanelsID.Shared: AdaptedPose(x=-1000, y=0),\n        }\n        for id, pose in solar_panels_positions.items():\n            self.solar_panels[id] = SolarPanels(id=id, x=pose.x, y=pose.y)\n\n    def create_fixed_obstacles(self):\n        # Positions are related to the default camp yellow.\n        self.fixed_obstacles: list[DynObstacleRect] = []\n\n        pose = AdaptedPose(x=1000 - 225, y=1500 - 225)\n        self.fixed_obstacles += [DynObstacleRect(x=pose.x, y=pose.y, angle=0, length_x=450, length_y=450)]\n\n        pose = AdaptedPose(x=1000 - 75, y=225)\n        self.fixed_obstacles += [DynObstacleRect(x=pose.x, y=pose.y, angle=0, length_x=150, length_y=450)]\n\n        for obstacle in self.fixed_obstacles:\n            obstacle.create_bounding_box(self.properties.robot_width / 2)\n\n    def create_actuators_states(self):\n        self.servo_states: dict[ServoEnum, Servo] = {}\n        self.positional_actuator_states: dict[PositionalActuatorEnum, PositionalActuator] = {}\n        self.bool_sensor_states: dict[BoolSensorEnum, BoolSensor] = {id: BoolSensor(id=id) for id in BoolSensorEnum}\n        self.emulated_actuator_states: set[ServoEnum | PositionalActuatorEnum] = {\n            ServoEnum.LXSERVO_LEFT_CART,\n            ServoEnum.LXSERVO_RIGHT_CART,\n            ServoEnum.LXSERVO_ARM_PANEL,\n            PositionalActuatorEnum.MOTOR_BOTTOM_LIFT,\n            PositionalActuatorEnum.MOTOR_TOP_LIFT,\n            PositionalActuatorEnum.ANALOGSERVO_BOTTOM_GRIP_LEFT,\n            PositionalActuatorEnum.ANALOGSERVO_BOTTOM_GRIP_RIGHT,\n            PositionalActuatorEnum.ANALOGSERVO_TOP_GRIP_LEFT,\n            PositionalActuatorEnum.ANALOGSERVO_TOP_GRIP_RIGHT,\n            PositionalActuatorEnum.CART_MAGNET_LEFT,\n            PositionalActuatorEnum.CART_MAGNET_RIGHT,\n            PositionalActuatorEnum.ANALOGSERVO_PAMI,\n            BoolSensorEnum.BOTTOM_GRIP_LEFT,\n            BoolSensorEnum.BOTTOM_GRIP_RIGHT,\n            BoolSensorEnum.TOP_GRIP_LEFT,\n            BoolSensorEnum.TOP_GRIP_RIGHT,\n            BoolSensorEnum.MAGNET_LEFT,\n            BoolSensorEnum.MAGNET_RIGHT,\n        }\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.table","title":"<code>table: Table</code>  <code>property</code> <code>writable</code>","text":"<p>Selected table.</p>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.get_available_start_poses","title":"<code>get_available_start_poses()</code>","text":"<p>Get start poses available depending on camp and table.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def get_available_start_poses(self) -&gt; list[StartPosition]:\n    \"\"\"\n    Get start poses available depending on camp and table.\n    \"\"\"\n    start_pose_indices = []\n    for p in StartPosition:\n        pose = self.get_start_pose(p)\n        if self.table.contains(pose):\n            start_pose_indices.append(p)\n    return start_pose_indices\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.get_start_pose","title":"<code>get_start_pose(n)</code>","text":"<p>Define the possible start positions. Default positions for yellow camp.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def get_start_pose(self, n: StartPosition) -&gt; Pose:\n    \"\"\"\n    Define the possible start positions.\n    Default positions for yellow camp.\n    \"\"\"\n    match n:\n        case StartPosition.Top:\n            return AdaptedPose(\n                x=1000 - 450 + self.properties.robot_width / 2,\n                y=-(1500 - 450 + self.properties.robot_length / 2),\n                O=90,\n            )\n        case StartPosition.Bottom:\n            pose = AdaptedPose(\n                x=-785,\n                y=-1285,\n                O=90,\n            )\n            if self.camp.color == Camp.Colors.blue and self.strategy == actions.Strategy.GameSolarFirst:\n                pose.O = 90\n            return pose\n        case StartPosition.Opposite:\n            return AdaptedPose(\n                x=-450 / 2 + self.properties.robot_width / 2,\n                y=1500 - 450 + self.properties.robot_width / 2,\n                O=-90,\n            )\n        case StartPosition.PAMI2:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_length / 2,\n                y=-self.properties.robot_width / 2,\n                O=180,\n            )\n        case StartPosition.PAMI3:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_width / 2,\n                y=-33,\n                O=-90,\n            )\n        case StartPosition.PAMI4:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_width / 2,\n                y=-(450 - self.properties.robot_length / 2),\n                O=-90,\n            )\n        case StartPosition.PAMI2_TRAINING:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_length / 2 - 1000,\n                y=-self.properties.robot_width / 2,\n                O=180,\n            )\n        case StartPosition.PAMI3_TRAINING:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_length / 2 - 1000,\n                y=-450 / 2,\n                O=180,\n            )\n        case StartPosition.PAMI4_TRAINING:\n            return AdaptedPose(\n                x=1000 - 150 + self.properties.robot_width / 2 - 1000,\n                y=-(450 - self.properties.robot_length / 2),\n                O=-90,\n            )\n        case _:\n            return AdaptedPose()\n</code></pre>"},{"location":"reference/cogip/tools/planner/context/#cogip.tools.planner.context.GameContext.reset","title":"<code>reset()</code>","text":"<p>Reset the context.</p> Source code in <code>cogip/tools/planner/context.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the context.\n    \"\"\"\n    self.playing = False\n    self.score = self.minimum_score\n    self.countdown = self.game_duration\n    self.create_artifacts()\n    self.create_fixed_obstacles()\n    self.create_actuators_states()\n</code></pre>"},{"location":"reference/cogip/tools/planner/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/planner/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner","title":"<code>Planner</code>","text":"<p>Main planner class.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>class Planner:\n    \"\"\"\n    Main planner class.\n    \"\"\"\n\n    def __init__(\n        self,\n        robot_id: int,\n        server_url: str,\n        robot_width: int,\n        robot_length: int,\n        obstacle_radius: int,\n        obstacle_bb_margin: float,\n        obstacle_bb_vertices: int,\n        max_distance: int,\n        obstacle_sender_interval: float,\n        path_refresh_interval: float,\n        plot: bool,\n        starter_pin: int | None,\n        oled_bus: int | None,\n        oled_address: int | None,\n        debug: bool,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            robot_id: Robot ID\n            server_url: Socket.IO Server URL\n            robot_width: Width of the robot (in mm)\n            robot_length: Length of the robot (in mm)\n            obstacle_radius: Radius of a dynamic obstacle (in mm)\n            obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n            obstacle_bb_vertices: Number of obstacle bounding box vertices\n            max_distance: Maximum distance to take avoidance points into account (mm)\n            obstacle_sender_interval: Interval between each send of obstacles to dashboards (in seconds)\n            path_refresh_interval: Interval between each update of robot paths (in seconds)\n            plot: Display avoidance graph in realtime\n            starter_pin: GPIO pin connected to the starter\n            oled_bus: PAMI OLED display i2c bus\n            oled_address: PAMI OLED display i2c address\n            debug: enable debug messages\n        \"\"\"\n        self.robot_id = robot_id\n        self.server_url = server_url\n        self.oled_bus = oled_bus\n        self.oled_address = oled_address\n        self.debug = debug\n\n        # We have to make sure the Planner is the first object calling the constructor\n        # of the Properties singleton\n        if Properties in Singleton._instance:\n            raise RuntimeError(\"Properties class must not be initialized before this point.\")\n        self.properties = Properties(\n            robot_id=robot_id,\n            robot_width=robot_width,\n            robot_length=robot_length,\n            obstacle_radius=obstacle_radius,\n            obstacle_bb_margin=obstacle_bb_margin,\n            obstacle_bb_vertices=obstacle_bb_vertices,\n            max_distance=max_distance,\n            obstacle_sender_interval=obstacle_sender_interval,\n            path_refresh_interval=path_refresh_interval,\n            plot=plot,\n        )\n        self.virtual = platform.machine() != \"aarch64\"\n        self.retry_connection = True\n        self.sio = socketio.AsyncClient(logger=False)\n        self.sio_ns = sio_events.SioEvents(self)\n        self.sio.register_namespace(self.sio_ns)\n        self.game_context = GameContext()\n        self.process_manager = Manager()\n        self.sio_receiver_queue = asyncio.Queue()\n        self.sio_emitter_queue = self.process_manager.Queue()\n        self.action: actions.Action | None = None\n        self.actions = action_classes.get(self.game_context.strategy, actions.Actions)(self)\n        self.obstacles: models.DynObstacleList = []\n        self.obstacles_sender_loop = AsyncLoop(\n            \"Obstacles sender loop\",\n            obstacle_sender_interval,\n            self.send_obstacles,\n            logger=self.debug,\n        )\n        self._pose_current: models.Pose | None = None\n        self._pose_order: pose.Pose | None = None\n        self.pose_reached: bool = True\n        self.avoidance_path: list[pose.Pose] = []\n        self.blocked_counter: int = 0\n        self.controller = self.game_context.default_controller\n        self.game_wizard = GameWizard(self)\n        self.start_position: StartPosition | None = None\n        available_start_poses = self.game_context.get_available_start_poses()\n        if available_start_poses:\n            self.start_position = available_start_poses[(self.robot_id - 1) % len(available_start_poses)]\n        self.sio_receiver_task: asyncio.Task | None = None\n        self.sio_emitter_task: asyncio.Task | None = None\n        self.countdown_task: asyncio.Task | None = None\n\n        self.shared_properties: DictProxy = self.process_manager.dict(\n            {\n                \"robot_id\": self.robot_id,\n                \"exiting\": False,\n                \"avoidance_strategy\": self.game_context.avoidance_strategy,\n                \"pose_current\": {},\n                \"pose_order\": {},\n                \"last_avoidance_pose_current\": {},\n                \"obstacles\": [],\n                \"path_refresh_interval\": path_refresh_interval,\n                \"robot_width\": robot_width,\n                \"obstacle_radius\": obstacle_radius,\n                \"obstacle_bb_vertices\": obstacle_bb_vertices,\n                \"obstacle_bb_margin\": obstacle_bb_margin,\n                \"max_distance\": max_distance,\n                \"plot\": plot,\n            }\n        )\n        self.avoidance_process: Process | None = None\n\n        if starter_pin:\n            self.starter = Button(\n                starter_pin,\n                pull_up=False,\n                bounce_time=None,\n            )\n        else:\n            self.starter = Button(\n                17,\n                pull_up=True,\n                pin_factory=MockFactory(),\n            )\n\n        self.starter.when_pressed = partial(self.sio_emitter_queue.put, (\"starter_changed\", True))\n        self.starter.when_released = partial(self.sio_emitter_queue.put, (\"starter_changed\", False))\n\n        if self.oled_bus and self.oled_address:\n            self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n            self.oled_device = sh1106(self.oled_serial)\n            self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n            self.oled_image = canvas(self.oled_device)\n            self.oled_update_loop = AsyncLoop(\n                \"OLED display update loop\",\n                0.5,\n                self.update_oled_display,\n                logger=self.debug,\n            )\n\n    async def connect(self):\n        \"\"\"\n        Connect to SocketIO server.\n        \"\"\"\n        self.retry_connection = True\n        try:\n            await self.try_connect()\n            await self.sio.wait()\n        except asyncio.CancelledError:\n            self.process_manager.shutdown()\n\n    async def try_connect(self):\n        \"\"\"\n        Poll to wait for the first connection.\n        Disconnections/reconnections are handle directly by the client.\n        \"\"\"\n        while self.retry_connection:\n            try:\n                await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n            except socketio.exceptions.ConnectionError:\n                time.sleep(2)\n                continue\n            break\n\n    async def start(self):\n        \"\"\"\n        Start sending obstacles list.\n        \"\"\"\n        logger.info(\"Planner: start\")\n        self.shared_properties[\"exiting\"] = False\n        await self.soft_reset()\n        await self.set_pose_start(self.game_context.get_start_pose(self.start_position).pose)\n        await self.set_controller(self.game_context.default_controller, True)\n        self.sio_receiver_task = asyncio.create_task(\n            self.task_sio_receiver(),\n            name=\"Robot: Task SIO Receiver\",\n        )\n        self.sio_emitter_task = asyncio.create_task(\n            self.task_sio_emitter(),\n            name=\"Robot: Task SIO Emitter\",\n        )\n        await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n        await self.sio_ns.emit(\"game_reset\")\n        await self.countdown_start()\n        self.obstacles_sender_loop.start()\n        if self.oled_bus and self.oled_address:\n            self.oled_update_loop.start()\n\n        self.avoidance_process = Process(\n            target=avoidance_process,\n            args=(\n                self.game_context.strategy,\n                self.game_context.table,\n                self.shared_properties,\n                self.sio_emitter_queue,\n            ),\n        )\n        self.avoidance_process.start()\n\n    async def stop(self):\n        \"\"\"\n        Stop running tasks.\n        \"\"\"\n        logger.info(\"Planner: stop\")\n\n        self.shared_properties[\"exiting\"] = True\n\n        await self.sio_ns.emit(\"stop_video_record\")\n\n        await self.countdown_stop()\n\n        await self.obstacles_sender_loop.stop()\n        if self.oled_bus and self.oled_address:\n            await self.oled_update_loop.stop()\n\n        if self.sio_emitter_task:\n            self.sio_emitter_task.cancel()\n            try:\n                await self.sio_emitter_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task SIO Emitter stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n        self.sio_emitter_task = None\n\n        if self.sio_receiver_task:\n            self.sio_receiver_task.cancel()\n            try:\n                await self.sio_receiver_task\n            except asyncio.CancelledError:\n                logger.info(\"Planner: Task SIO Receiver stopped\")\n            except Exception as exc:\n                logger.warning(f\"Planner: Unexpected exception {exc}\")\n        self.sio_receiver_task = None\n\n        if self.avoidance_process and self.avoidance_process.is_alive():\n            self.avoidance_process.join()\n            self.avoidance_process = None\n\n    async def reset(self):\n        \"\"\"\n        Reset planner, context, robots and actions.\n        \"\"\"\n        await self.stop()\n        await self.start()\n\n    async def soft_reset(self):\n        \"\"\"\n        Only reset context and actions.\n        \"\"\"\n        self.game_context.reset()\n        self.actions = action_classes.get(self.game_context.strategy, actions.Actions)(self)\n        await self.set_pose_start(self.game_context.get_start_pose(self.start_position).pose)\n\n    async def task_sio_emitter(self):\n        logger.info(\"Planner: Task SIO Emitter started\")\n        try:\n            while True:\n                name, value = await asyncio.to_thread(self.sio_emitter_queue.get)\n                match name:\n                    case \"avoidance_path\":\n                        self.avoidance_path = [pose.Pose.model_validate(m) for m in value]\n                    case \"blocked\":\n                        if self.sio.connected:\n                            await self.sio_ns.emit(\"brake\")\n                        self.blocked_counter += 1\n                        if self.blocked_counter &gt; 10:\n                            self.blocked_counter = 0\n                            await self.blocked()\n                    case \"path\":\n                        if self.pose_order:\n                            await self.pose_order.act_intermediate_pose()\n                        if len(value) == 1:\n                            # Final pose\n                            new_controller = ControllerEnum.QUADPID\n                        else:\n                            # Intermediate pose\n                            match self.game_context.avoidance_strategy:\n                                case AvoidanceStrategy.Disabled | AvoidanceStrategy.VisibilityRoadMapQuadPid:\n                                    new_controller = ControllerEnum.QUADPID\n                                case AvoidanceStrategy.VisibilityRoadMapLinearPoseDisabled:\n                                    new_controller = ControllerEnum.LINEAR_POSE_DISABLED\n                        await self.set_controller(new_controller)\n                        if self.sio.connected:\n                            await self.sio_ns.emit(name, value)\n                    case \"pose_order\":\n                        self.blocked_counter = 0\n                        if self.sio.connected:\n                            await self.sio_ns.emit(name, value)\n                    case \"starter_changed\":\n                        await self.starter_changed(value)\n                    case _:\n                        if self.sio.connected:\n                            await self.sio_ns.emit(name, value)\n                self.sio_emitter_queue.task_done()\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task SIO Emitter cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task SIO Emitter: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def task_sio_receiver(self):\n        logger.info(\"Planner: Task SIO Receiver started\")\n        try:\n            while True:\n                func = await self.sio_receiver_queue.get()\n                await func\n                self.sio_receiver_queue.task_done()\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task SIO Receiver cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Task SIO Receiver: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    async def countdown_loop(self):\n        logger.info(\"Planner: Task Countdown started\")\n        try:\n            last_now = time.time()\n            last_countdown = self.game_context.countdown\n            while True:\n                await asyncio.sleep(0.5)\n                now = time.time()\n                self.game_context.countdown -= now - last_now\n                logger.debug(f\"Planner: countdown = {self.game_context.countdown}\")\n                if self.game_context.playing and self.game_context.countdown &lt; 15 and last_countdown &gt; 15:\n                    logger.debug(\"Planner: countdown==15: force blocked\")\n                    await self.sio_receiver_queue.put(self.blocked())\n                if self.game_context.playing and self.game_context.countdown &lt; 0 and last_countdown &gt; 0:\n                    logger.debug(\"Planner: countdown==0: final action\")\n                    await self.final_action()\n                if self.game_context.countdown &lt; -5 and last_countdown &gt; -5:\n                    await self.sio_ns.emit(\"stop_video_record\")\n                last_now = now\n                last_countdown = self.game_context.countdown\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown cancelled\")\n            raise\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            raise\n\n    async def countdown_start(self):\n        await self.countdown_stop()\n        self.countdown_task = asyncio.create_task(self.countdown_loop())\n\n    async def countdown_stop(self):\n        if self.countdown_task is None:\n            return\n\n        self.countdown_task.cancel()\n        try:\n            await self.countdown_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task Countdown stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n\n        self.countdown_task = None\n\n    async def final_action(self):\n        if not self.game_context.playing:\n            return\n        self.game_context.playing = False\n        await self.sio_ns.emit(\"game_end\")\n        await self.sio_ns.emit(\"score\", self.game_context.score)\n\n    async def starter_changed(self, pushed: bool):\n        if not self.virtual:\n            await self.sio_ns.emit(\"starter_changed\", pushed)\n\n    async def set_controller(self, new_controller: ControllerEnum, force: bool = False):\n        if self.controller == new_controller and not force:\n            return\n        self.controller = new_controller\n        await self.sio_ns.emit(\"set_controller\", self.controller.value)\n\n    async def set_pose_start(self, pose_start: models.Pose):\n        \"\"\"\n        Set the start position of the robot for the next game.\n        \"\"\"\n        self.action = None\n        self.pose_current = pose_start.model_copy()\n        self.pose_order = None\n        self.pose_reached = True\n        self.avoidance_path = []\n        await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n\n    def set_pose_current(self, pose: models.Pose) -&gt; None:\n        \"\"\"\n        Set current pose of a robot.\n        \"\"\"\n        self.pose_current = models.Pose.model_validate(pose)\n\n    @property\n    def pose_current(self) -&gt; models.Pose:\n        return self._pose_current\n\n    @pose_current.setter\n    def pose_current(self, new_pose: models.Pose):\n        self._pose_current = new_pose\n        self.shared_properties[\"pose_current\"] = new_pose.model_dump(exclude_unset=True)\n\n    @property\n    def pose_order(self) -&gt; pose.Pose | None:\n        return self._pose_order\n\n    @pose_order.setter\n    def pose_order(self, new_pose: pose.Pose | None):\n        self._pose_order = new_pose\n        if new_pose is None:\n            self.shared_properties[\"pose_order\"] = None\n        else:\n            self.shared_properties[\"pose_order\"] = new_pose.path_pose.model_dump(exclude_unset=True)\n            self.shared_properties[\"last_avoidance_pose_current\"] = None\n\n    async def set_pose_reached(self):\n        \"\"\"\n        Set pose reached for a robot.\n        \"\"\"\n        logger.debug(\"Planner: set_pose_reached()\")\n\n        self.shared_properties[\"last_avoidance_pose_current\"] = None\n\n        if len(self.avoidance_path) &gt; 1:\n            # The pose reached is intermediate, do nothing.\n            return\n\n        # Set pose reached\n        self.avoidance_path = []\n        if not self.pose_reached and (pose_order := self.pose_order):\n            self.pose_order = None\n            await pose_order.act_after_pose()\n        else:\n            self.pose_order = None\n\n        self.pose_reached = True\n        if (action := self.action) and len(self.action.poses) == 0:\n            self.action = None\n            await action.act_after_action()\n\n        if not self.game_context.playing:\n            return\n\n        await self.next_pose()\n\n    async def next_pose_in_action(self):\n        if self.action and len(self.action.poses) &gt; 0:\n            pose_order = self.action.poses.pop(0)\n            self.pose_order = None\n            await pose_order.act_before_pose()\n            self.blocked_counter = 0\n            self.pose_order = pose_order\n\n            if self.game_context.strategy in [Strategy.LinearSpeedTest, Strategy.AngularSpeedTest]:\n                await self.sio_ns.emit(\"pose_order\", self.pose_order.pose.model_dump())\n\n    async def next_pose(self):\n        \"\"\"\n        Select the next pose for a robot.\n        \"\"\"\n        logger.debug(\"Planner: next_pose()\")\n        try:\n            # Get and set new pose\n            self.pose_reached = False\n            await self.next_pose_in_action()\n\n            # If no pose left in current action, get and set new action\n            if not self.pose_order and (new_action := self.get_action()):\n                await self.set_action(new_action)\n                if not self.pose_order:\n                    await self.sio_receiver_queue.put(self.set_pose_reached())\n        except Exception as exc:  # noqa\n            logger.warning(f\"Planner: Unknown exception {exc}\")\n            traceback.print_exc()\n            raise\n\n    def get_action(self) -&gt; actions.Action | None:\n        \"\"\"\n        Get a new action for a robot.\n        Simply choose next action in the list for now.\n        \"\"\"\n        sorted_actions = sorted(\n            [action for action in self.actions if not action.recycled and action.weight() &gt; 0],\n            key=lambda action: action.weight(),\n        )\n\n        if len(sorted_actions) == 0:\n            return None\n\n        action = sorted_actions[-1]\n        self.actions.remove(action)\n        return action\n\n    async def set_action(self, action: \"actions.Action\"):\n        \"\"\"\n        Set current action.\n        \"\"\"\n        logger.debug(f\"Planner: set action '{action.name}'\")\n        self.pose_order = None\n        self.action = action\n        await self.action.act_before_action()\n        await self.next_pose_in_action()\n\n    async def blocked(self):\n        \"\"\"\n        Function called when a robot cannot find a path to go to the current pose of the current action\n        \"\"\"\n        if (current_action := self.action) and current_action.interruptable:\n            logger.debug(\"Planner: blocked\")\n            if new_action := self.get_action():\n                await self.set_action(new_action)\n            await current_action.recycle()\n            self.actions.append(current_action)\n            if not self.pose_order:\n                await self.sio_receiver_queue.put(self.set_pose_reached())\n\n    def create_dyn_obstacle(\n        self,\n        center: models.Vertex,\n        radius: float | None = None,\n        bb_radius: float | None = None,\n    ) -&gt; models.DynRoundObstacle:\n        \"\"\"\n        Create a dynamic obstacle.\n\n        Arguments:\n            center: center of the obstacle\n            radius: radius of the obstacle, use the value from global properties if not specified\n            bb_radius: radius of the bounding box\n        \"\"\"\n        if radius is None:\n            radius = self.properties.obstacle_radius\n\n        if bb_radius is None:\n            bb_radius = radius + self.properties.robot_width / 2\n\n        obstacle = models.DynRoundObstacle(\n            x=center.x,\n            y=center.y,\n            radius=radius,\n        )\n        obstacle.create_bounding_box(bb_radius, self.properties.obstacle_bb_vertices)\n\n        return obstacle\n\n    def set_obstacles(self, obstacles: list[models.Vertex]) -&gt; None:\n        \"\"\"\n        Store obstacles detected by a robot sent by Detector.\n        Add bounding box and radius.\n        \"\"\"\n        table = self.game_context.table\n        if self.robot_id == 1:\n            bb_radius = self.properties.obstacle_radius + self.properties.robot_length / 2\n\n            self.obstacles = [\n                self.create_dyn_obstacle(obstacle, bb_radius)\n                for obstacle in obstacles\n                if table.contains(obstacle, self.properties.obstacle_radius)\n            ]\n        else:\n            # In case of PAMI, the detected obstacle is at the front the real obstacle\n            # instead of at its center.\n            # Since we use a specific avoidance strategy that only needs to know the path\n            # is intersecting the obstacle, the radius can be reduced to the minimum to create\n            # a bounding box.\n            self.obstacles = [\n                self.create_dyn_obstacle(obstacle, radius=10, bb_radius=10)\n                for obstacle in obstacles\n                if table.contains(obstacle)\n            ]\n        self.obstacles += [p for p in self.game_context.plant_supplies.values() if p.enabled and table.contains(p)]\n        self.obstacles += [p for p in self.game_context.pot_supplies.values() if p.enabled and table.contains(p)]\n        self.obstacles += [p for p in self.game_context.fixed_obstacles if table.contains(p)]\n\n        self.shared_properties[\"obstacles\"] = [\n            obstacle.model_dump(exclude_defaults=True) for obstacle in self.obstacles\n        ]\n\n    async def send_obstacles(self):\n        await self.sio_ns.emit(\"obstacles\", [o.model_dump(exclude_defaults=True) for o in self.obstacles])\n\n    async def update_oled_display(self):\n        try:\n            text = (\n                f\"{'Connected' if self.sio.connected else 'Not connected': &lt;20}\"\n                f\"{'\u25b6' if self.game_context.playing else '\u25fc'}\\n\"\n                f\"Camp: {self.game_context.camp.color.name}\\n\"\n                f\"Strategy: {self.game_context.strategy.name}\\n\"\n                f\"Pose: {self.pose_current.x},{self.pose_current.y},{self.pose_current.O}\\n\"\n                f\"Countdown: {self.game_context.countdown:.2f}\"\n            )\n            with self.oled_image as draw:\n                draw.rectangle([(0, 0), (128, 64)], fill=\"black\", outline=\"black\")\n                draw.multiline_text(\n                    (1, 0),\n                    text,\n                    fill=\"white\",\n                    font=self.oled_font,\n                )\n        except Exception as exc:\n            logger.warning(f\"Planner: OLED display update loop: Unknown exception {exc}\")\n            traceback.print_exc()\n\n    async def command(self, cmd: str):\n        \"\"\"\n        Execute a command from the menu.\n        \"\"\"\n        if cmd.startswith(\"wizard_\"):\n            await self.cmd_wizard_test(cmd)\n            return\n\n        if cmd.startswith(\"act_\"):\n            await self.cmd_act(cmd)\n            return\n\n        if cmd.startswith(\"cam_\"):\n            await self.cmd_cam(cmd)\n            return\n\n        if cmd == \"config\":\n            # Get JSON Schema\n            schema = TypeAdapter(Properties).json_schema()\n            # Add namespace in JSON Schema\n            schema[\"namespace\"] = \"/planner\"\n            # Add current values in JSON Schema\n            for prop, value in RootModel[Properties](self.properties).model_dump().items():\n                schema[\"properties\"][prop][\"value\"] = value\n            # Send config\n            await self.sio_ns.emit(\"config\", schema)\n            return\n\n        if cmd == \"game_wizard\":\n            await self.game_wizard.start()\n            return\n\n        if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n            logger.warning(f\"Unknown command: {cmd}\")\n            return\n\n        await cmd_func()\n\n    def update_config(self, config: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Update a Planner property with the value sent by the dashboard.\n        \"\"\"\n        self.properties.__setattr__(name := config[\"name\"], value := config[\"value\"])\n        if name in self.shared_properties:\n            self.shared_properties[name] = value\n        match name:\n            case \"obstacle_sender_interval\":\n                self.obstacles_sender_loop.interval = self.properties.obstacle_sender_interval\n            case \"robot_width\" | \"obstacle_bb_vertices\":\n                self.game_context.create_artifacts()\n                self.game_context.create_fixed_obstacles()\n\n    async def cmd_play(self):\n        \"\"\"\n        Play command from the menu.\n        \"\"\"\n        if self.game_context.playing:\n            return\n\n        self.game_context.countdown = self.game_context.game_duration\n        self.game_context.playing = True\n        await self.sio_ns.emit(\"start_video_record\")\n        await self.sio_receiver_queue.put(self.set_pose_reached())\n\n    async def cmd_stop(self):\n        \"\"\"\n        Stop command from the menu.\n        \"\"\"\n        self.game_context.playing = False\n        await self.sio_ns.emit(\"stop_video_record\")\n\n    async def cmd_next(self):\n        \"\"\"\n        Next command from the menu.\n        Ignored if current pose is not reached for all robots.\n        \"\"\"\n        if self.game_context.playing:\n            return\n\n        # Check that pose_reached is set\n        if not self.pose_reached:\n            return\n\n        await self.sio_receiver_queue.put(self.next_pose())\n\n    async def cmd_reset(self):\n        \"\"\"\n        Reset command from the menu.\n        \"\"\"\n        await self.reset()\n        await self.sio_ns.emit(\"cmd_reset\")\n\n    async def cmd_choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.game_context.camp.color.name,\n            },\n        )\n\n    async def cmd_choose_strategy(self):\n        \"\"\"\n        Choose strategy command from the menu.\n        Send strategy wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Strategy\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in Strategy],\n                \"value\": self.game_context.strategy.name,\n            },\n        )\n\n    async def cmd_choose_avoidance(self):\n        \"\"\"\n        Choose avoidance strategy command from the menu.\n        Send avoidance strategy wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Avoidance\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in AvoidanceStrategy],\n                \"value\": self.game_context.avoidance_strategy.name,\n            },\n        )\n\n    async def cmd_choose_start_position(self):\n        \"\"\"\n        Choose start position command from the menu.\n        Send start position wizard message.\n        \"\"\"\n        if self.start_position is None:\n            await self.sio_ns.emit(\n                \"wizard\",\n                {\n                    \"name\": \"Error\",\n                    \"type\": \"message\",\n                    \"value\": \"No start position available with this Camp/Table\",\n                },\n            )\n        else:\n            await self.sio_ns.emit(\n                \"wizard\",\n                {\n                    \"name\": \"Choose Start Position\",\n                    \"type\": \"choice_integer\",\n                    \"choices\": [p.name for p in self.game_context.get_available_start_poses()],\n                    \"value\": self.start_position.name,\n                },\n            )\n\n    async def cmd_choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": self.game_context._table.name,\n            },\n        )\n\n    async def wizard_response(self, message: dict[str, Any]):\n        \"\"\"\n        Handle wizard response sent from the dashboard.\n        \"\"\"\n        if (value := message[\"value\"]) is None:\n            return\n\n        match name := message.get(\"name\"):\n            case \"Choose Camp\":\n                new_camp = Camp.Colors[value]\n                if self.game_context.camp.color == new_camp:\n                    return\n                if self.game_context._table == TableEnum.Training and new_camp == Camp.Colors.blue:\n                    logger.warning(\"Wizard: only yellow camp is authorized on training table\")\n                    return\n                self.game_context.camp.color = new_camp\n                await self.soft_reset()\n                logger.info(f\"Wizard: New camp: {self.game_context.camp.color.name}\")\n            case \"Choose Strategy\":\n                new_strategy = Strategy[value]\n                if self.game_context.strategy == new_strategy:\n                    return\n                self.game_context.strategy = new_strategy\n                await self.soft_reset()\n                logger.info(f\"Wizard: New strategy: {self.game_context.strategy.name}\")\n            case \"Choose Avoidance\":\n                new_strategy = AvoidanceStrategy[value]\n                if self.game_context.avoidance_strategy == new_strategy:\n                    return\n                self.game_context.avoidance_strategy = new_strategy\n                self.shared_properties[\"avoidance_strategy\"] = new_strategy\n                logger.info(f\"Wizard: New avoidance strategy: {self.game_context.avoidance_strategy.name}\")\n            case \"Choose Start Position\":\n                start_position = StartPosition[value]\n                self.start_position = start_position\n                await self.soft_reset()\n            case \"Choose Table\":\n                new_table = TableEnum[value]\n                if self.game_context.table == new_table:\n                    return\n                if self.game_context.camp.color == Camp.Colors.blue and new_table == TableEnum.Training:\n                    logger.warning(\"Wizard: training table is not supported with blue camp\")\n                    await self.sio_ns.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Error\",\n                            \"type\": \"message\",\n                            \"value\": \"Training table is not supported with blue camp\",\n                        },\n                    )\n                    return\n                self.game_context.table = new_table\n                self.shared_properties[\"table\"] = new_table\n                await self.soft_reset()\n                logger.info(f\"Wizard: New table: {self.game_context._table.name}\")\n            case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n                await self.game_wizard.response(message)\n            case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n                logger.info(f\"Wizard test response: {name} = {value}\")\n            case _:\n                logger.warning(f\"Wizard: Unknown type: {name}\")\n\n    async def cmd_wizard_test(self, cmd: str):\n        match cmd:\n            case \"wizard_boolean\":\n                message = {\n                    \"name\": \"Wizard Test Boolean\",\n                    \"type\": \"boolean\",\n                    \"value\": True,\n                }\n            case \"wizard_integer\":\n                message = {\n                    \"name\": \"Wizard Test Integer\",\n                    \"type\": \"integer\",\n                    \"value\": 42,\n                }\n            case \"wizard_floating\":\n                message = {\n                    \"name\": \"Wizard Test Float\",\n                    \"type\": \"floating\",\n                    \"value\": 66.6,\n                }\n            case \"wizard_str\":\n                message = {\n                    \"name\": \"Wizard Test String\",\n                    \"type\": \"str\",\n                    \"value\": \"cogip\",\n                }\n            case \"wizard_message\":\n                message = {\n                    \"name\": \"Wizard Test Message\",\n                    \"type\": \"message\",\n                    \"value\": \"Hello Robot!\",\n                }\n            case \"wizard_choice_integer\":\n                message = {\n                    \"name\": \"Wizard Test Choice Integer\",\n                    \"type\": \"choice_integer\",\n                    \"choices\": [1, 2, 3],\n                    \"value\": 2,\n                }\n            case \"wizard_choice_floating\":\n                message = {\n                    \"name\": \"Wizard Test Choice Float\",\n                    \"type\": \"choice_floating\",\n                    \"choices\": [1.1, 2.2, 3.3],\n                    \"value\": 2.2,\n                }\n            case \"wizard_choice_str\":\n                message = {\n                    \"name\": \"Wizard Test Choice String\",\n                    \"type\": \"choice_str\",\n                    \"choices\": [\"one\", \"two\", \"tree\"],\n                    \"value\": \"two\",\n                }\n            case \"wizard_select_integer\":\n                message = {\n                    \"name\": \"Wizard Test Select Integer\",\n                    \"type\": \"select_integer\",\n                    \"choices\": [1, 2, 3],\n                    \"value\": [1, 3],\n                }\n            case \"wizard_select_floating\":\n                message = {\n                    \"name\": \"Wizard Test Select Float\",\n                    \"type\": \"select_floating\",\n                    \"choices\": [1.1, 2.2, 3.3],\n                    \"value\": [1.1, 3.3],\n                }\n            case \"wizard_select_str\":\n                message = {\n                    \"name\": \"Wizard Test Select String\",\n                    \"type\": \"select_str\",\n                    \"choices\": [\"one\", \"two\", \"tree\"],\n                    \"value\": [\"one\", \"tree\"],\n                }\n            case \"wizard_camp\":\n                message = {\n                    \"name\": \"Wizard Test Camp\",\n                    \"type\": \"camp\",\n                    \"value\": \"yellow\",\n                }\n            case \"wizard_camera\":\n                message = {\n                    \"name\": \"Wizard Test Camera\",\n                    \"type\": \"camera\",\n                }\n            case \"wizard_score\":\n                await self.sio_ns.emit(\"score\", 100)\n                return\n            case _:\n                logger.warning(f\"Wizard test unsupported: {cmd}\")\n                return\n\n        await self.sio_ns.emit(\"wizard\", message)\n\n    async def cmd_act(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        func = getattr(actuators, command)\n        await func(self)\n\n    async def cmd_cam(self, cmd: str):\n        _, _, command = cmd.partition(\"_\")\n        match command:\n            case \"snapshot\":\n                await cameras.snapshot()\n            case \"camera_position\":\n                await self.get_camera_position()\n\n    async def get_camera_position(self):\n        if camera_position := await cameras.calibrate_camera(self):\n            logger.info(\n                f\"Planner: Camera position in robot:\"\n                f\" X={camera_position.x:.0f} Y={camera_position.y:.0f} Z={camera_position.z:.0f}\"\n            )\n        else:\n            logger.info(\"Planner: No table marker found\")\n\n    async def update_actuator_state(self, actuator_state: ActuatorState):\n        # actuators_states = getattr(self.game_context, f\"{actuator_state.kind.name}_states\")\n        # actuators_states[actuator_state.id] = actuator_state\n        # if not self.virtual and actuator_state.id in self.game_context.emulated_actuator_states:\n        #     self.game_context.emulated_actuator_states.remove(actuator_state.id)\n        pass\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.__init__","title":"<code>__init__(robot_id, server_url, robot_width, robot_length, obstacle_radius, obstacle_bb_margin, obstacle_bb_vertices, max_distance, obstacle_sender_interval, path_refresh_interval, plot, starter_pin, oled_bus, oled_address, debug)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>Robot ID</p> required <code>server_url</code> <code>str</code> <p>Socket.IO Server URL</p> required <code>robot_width</code> <code>int</code> <p>Width of the robot (in mm)</p> required <code>robot_length</code> <code>int</code> <p>Length of the robot (in mm)</p> required <code>obstacle_radius</code> <code>int</code> <p>Radius of a dynamic obstacle (in mm)</p> required <code>obstacle_bb_margin</code> <code>float</code> <p>Obstacle bounding box margin in percent of the radius</p> required <code>obstacle_bb_vertices</code> <code>int</code> <p>Number of obstacle bounding box vertices</p> required <code>max_distance</code> <code>int</code> <p>Maximum distance to take avoidance points into account (mm)</p> required <code>obstacle_sender_interval</code> <code>float</code> <p>Interval between each send of obstacles to dashboards (in seconds)</p> required <code>path_refresh_interval</code> <code>float</code> <p>Interval between each update of robot paths (in seconds)</p> required <code>plot</code> <code>bool</code> <p>Display avoidance graph in realtime</p> required <code>starter_pin</code> <code>int | None</code> <p>GPIO pin connected to the starter</p> required <code>oled_bus</code> <code>int | None</code> <p>PAMI OLED display i2c bus</p> required <code>oled_address</code> <code>int | None</code> <p>PAMI OLED display i2c address</p> required <code>debug</code> <code>bool</code> <p>enable debug messages</p> required Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def __init__(\n    self,\n    robot_id: int,\n    server_url: str,\n    robot_width: int,\n    robot_length: int,\n    obstacle_radius: int,\n    obstacle_bb_margin: float,\n    obstacle_bb_vertices: int,\n    max_distance: int,\n    obstacle_sender_interval: float,\n    path_refresh_interval: float,\n    plot: bool,\n    starter_pin: int | None,\n    oled_bus: int | None,\n    oled_address: int | None,\n    debug: bool,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        robot_id: Robot ID\n        server_url: Socket.IO Server URL\n        robot_width: Width of the robot (in mm)\n        robot_length: Length of the robot (in mm)\n        obstacle_radius: Radius of a dynamic obstacle (in mm)\n        obstacle_bb_margin: Obstacle bounding box margin in percent of the radius\n        obstacle_bb_vertices: Number of obstacle bounding box vertices\n        max_distance: Maximum distance to take avoidance points into account (mm)\n        obstacle_sender_interval: Interval between each send of obstacles to dashboards (in seconds)\n        path_refresh_interval: Interval between each update of robot paths (in seconds)\n        plot: Display avoidance graph in realtime\n        starter_pin: GPIO pin connected to the starter\n        oled_bus: PAMI OLED display i2c bus\n        oled_address: PAMI OLED display i2c address\n        debug: enable debug messages\n    \"\"\"\n    self.robot_id = robot_id\n    self.server_url = server_url\n    self.oled_bus = oled_bus\n    self.oled_address = oled_address\n    self.debug = debug\n\n    # We have to make sure the Planner is the first object calling the constructor\n    # of the Properties singleton\n    if Properties in Singleton._instance:\n        raise RuntimeError(\"Properties class must not be initialized before this point.\")\n    self.properties = Properties(\n        robot_id=robot_id,\n        robot_width=robot_width,\n        robot_length=robot_length,\n        obstacle_radius=obstacle_radius,\n        obstacle_bb_margin=obstacle_bb_margin,\n        obstacle_bb_vertices=obstacle_bb_vertices,\n        max_distance=max_distance,\n        obstacle_sender_interval=obstacle_sender_interval,\n        path_refresh_interval=path_refresh_interval,\n        plot=plot,\n    )\n    self.virtual = platform.machine() != \"aarch64\"\n    self.retry_connection = True\n    self.sio = socketio.AsyncClient(logger=False)\n    self.sio_ns = sio_events.SioEvents(self)\n    self.sio.register_namespace(self.sio_ns)\n    self.game_context = GameContext()\n    self.process_manager = Manager()\n    self.sio_receiver_queue = asyncio.Queue()\n    self.sio_emitter_queue = self.process_manager.Queue()\n    self.action: actions.Action | None = None\n    self.actions = action_classes.get(self.game_context.strategy, actions.Actions)(self)\n    self.obstacles: models.DynObstacleList = []\n    self.obstacles_sender_loop = AsyncLoop(\n        \"Obstacles sender loop\",\n        obstacle_sender_interval,\n        self.send_obstacles,\n        logger=self.debug,\n    )\n    self._pose_current: models.Pose | None = None\n    self._pose_order: pose.Pose | None = None\n    self.pose_reached: bool = True\n    self.avoidance_path: list[pose.Pose] = []\n    self.blocked_counter: int = 0\n    self.controller = self.game_context.default_controller\n    self.game_wizard = GameWizard(self)\n    self.start_position: StartPosition | None = None\n    available_start_poses = self.game_context.get_available_start_poses()\n    if available_start_poses:\n        self.start_position = available_start_poses[(self.robot_id - 1) % len(available_start_poses)]\n    self.sio_receiver_task: asyncio.Task | None = None\n    self.sio_emitter_task: asyncio.Task | None = None\n    self.countdown_task: asyncio.Task | None = None\n\n    self.shared_properties: DictProxy = self.process_manager.dict(\n        {\n            \"robot_id\": self.robot_id,\n            \"exiting\": False,\n            \"avoidance_strategy\": self.game_context.avoidance_strategy,\n            \"pose_current\": {},\n            \"pose_order\": {},\n            \"last_avoidance_pose_current\": {},\n            \"obstacles\": [],\n            \"path_refresh_interval\": path_refresh_interval,\n            \"robot_width\": robot_width,\n            \"obstacle_radius\": obstacle_radius,\n            \"obstacle_bb_vertices\": obstacle_bb_vertices,\n            \"obstacle_bb_margin\": obstacle_bb_margin,\n            \"max_distance\": max_distance,\n            \"plot\": plot,\n        }\n    )\n    self.avoidance_process: Process | None = None\n\n    if starter_pin:\n        self.starter = Button(\n            starter_pin,\n            pull_up=False,\n            bounce_time=None,\n        )\n    else:\n        self.starter = Button(\n            17,\n            pull_up=True,\n            pin_factory=MockFactory(),\n        )\n\n    self.starter.when_pressed = partial(self.sio_emitter_queue.put, (\"starter_changed\", True))\n    self.starter.when_released = partial(self.sio_emitter_queue.put, (\"starter_changed\", False))\n\n    if self.oled_bus and self.oled_address:\n        self.oled_serial = i2c(port=self.oled_bus, address=self.oled_address)\n        self.oled_device = sh1106(self.oled_serial)\n        self.oled_font = ImageFont.truetype(\"DejaVuSansMono.ttf\", 9)\n        self.oled_image = canvas(self.oled_device)\n        self.oled_update_loop = AsyncLoop(\n            \"OLED display update loop\",\n            0.5,\n            self.update_oled_display,\n            logger=self.debug,\n        )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.blocked","title":"<code>blocked()</code>  <code>async</code>","text":"<p>Function called when a robot cannot find a path to go to the current pose of the current action</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def blocked(self):\n    \"\"\"\n    Function called when a robot cannot find a path to go to the current pose of the current action\n    \"\"\"\n    if (current_action := self.action) and current_action.interruptable:\n        logger.debug(\"Planner: blocked\")\n        if new_action := self.get_action():\n            await self.set_action(new_action)\n        await current_action.recycle()\n        self.actions.append(current_action)\n        if not self.pose_order:\n            await self.sio_receiver_queue.put(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_avoidance","title":"<code>cmd_choose_avoidance()</code>  <code>async</code>","text":"<p>Choose avoidance strategy command from the menu. Send avoidance strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_avoidance(self):\n    \"\"\"\n    Choose avoidance strategy command from the menu.\n    Send avoidance strategy wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Avoidance\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in AvoidanceStrategy],\n            \"value\": self.game_context.avoidance_strategy.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_camp","title":"<code>cmd_choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.game_context.camp.color.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_start_position","title":"<code>cmd_choose_start_position()</code>  <code>async</code>","text":"<p>Choose start position command from the menu. Send start position wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_start_position(self):\n    \"\"\"\n    Choose start position command from the menu.\n    Send start position wizard message.\n    \"\"\"\n    if self.start_position is None:\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Error\",\n                \"type\": \"message\",\n                \"value\": \"No start position available with this Camp/Table\",\n            },\n        )\n    else:\n        await self.sio_ns.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Start Position\",\n                \"type\": \"choice_integer\",\n                \"choices\": [p.name for p in self.game_context.get_available_start_poses()],\n                \"value\": self.start_position.name,\n            },\n        )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_strategy","title":"<code>cmd_choose_strategy()</code>  <code>async</code>","text":"<p>Choose strategy command from the menu. Send strategy wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_strategy(self):\n    \"\"\"\n    Choose strategy command from the menu.\n    Send strategy wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Strategy\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in Strategy],\n            \"value\": self.game_context.strategy.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_choose_table","title":"<code>cmd_choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio_ns.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": self.game_context._table.name,\n        },\n    )\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_next","title":"<code>cmd_next()</code>  <code>async</code>","text":"<p>Next command from the menu. Ignored if current pose is not reached for all robots.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_next(self):\n    \"\"\"\n    Next command from the menu.\n    Ignored if current pose is not reached for all robots.\n    \"\"\"\n    if self.game_context.playing:\n        return\n\n    # Check that pose_reached is set\n    if not self.pose_reached:\n        return\n\n    await self.sio_receiver_queue.put(self.next_pose())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_play","title":"<code>cmd_play()</code>  <code>async</code>","text":"<p>Play command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_play(self):\n    \"\"\"\n    Play command from the menu.\n    \"\"\"\n    if self.game_context.playing:\n        return\n\n    self.game_context.countdown = self.game_context.game_duration\n    self.game_context.playing = True\n    await self.sio_ns.emit(\"start_video_record\")\n    await self.sio_receiver_queue.put(self.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_reset","title":"<code>cmd_reset()</code>  <code>async</code>","text":"<p>Reset command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_reset(self):\n    \"\"\"\n    Reset command from the menu.\n    \"\"\"\n    await self.reset()\n    await self.sio_ns.emit(\"cmd_reset\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.cmd_stop","title":"<code>cmd_stop()</code>  <code>async</code>","text":"<p>Stop command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def cmd_stop(self):\n    \"\"\"\n    Stop command from the menu.\n    \"\"\"\n    self.game_context.playing = False\n    await self.sio_ns.emit(\"stop_video_record\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.command","title":"<code>command(cmd)</code>  <code>async</code>","text":"<p>Execute a command from the menu.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def command(self, cmd: str):\n    \"\"\"\n    Execute a command from the menu.\n    \"\"\"\n    if cmd.startswith(\"wizard_\"):\n        await self.cmd_wizard_test(cmd)\n        return\n\n    if cmd.startswith(\"act_\"):\n        await self.cmd_act(cmd)\n        return\n\n    if cmd.startswith(\"cam_\"):\n        await self.cmd_cam(cmd)\n        return\n\n    if cmd == \"config\":\n        # Get JSON Schema\n        schema = TypeAdapter(Properties).json_schema()\n        # Add namespace in JSON Schema\n        schema[\"namespace\"] = \"/planner\"\n        # Add current values in JSON Schema\n        for prop, value in RootModel[Properties](self.properties).model_dump().items():\n            schema[\"properties\"][prop][\"value\"] = value\n        # Send config\n        await self.sio_ns.emit(\"config\", schema)\n        return\n\n    if cmd == \"game_wizard\":\n        await self.game_wizard.start()\n        return\n\n    if not (cmd_func := getattr(self, f\"cmd_{cmd}\", None)):\n        logger.warning(f\"Unknown command: {cmd}\")\n        return\n\n    await cmd_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connect to SocketIO server.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def connect(self):\n    \"\"\"\n    Connect to SocketIO server.\n    \"\"\"\n    self.retry_connection = True\n    try:\n        await self.try_connect()\n        await self.sio.wait()\n    except asyncio.CancelledError:\n        self.process_manager.shutdown()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.create_dyn_obstacle","title":"<code>create_dyn_obstacle(center, radius=None, bb_radius=None)</code>","text":"<p>Create a dynamic obstacle.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Vertex</code> <p>center of the obstacle</p> required <code>radius</code> <code>float | None</code> <p>radius of the obstacle, use the value from global properties if not specified</p> <code>None</code> <code>bb_radius</code> <code>float | None</code> <p>radius of the bounding box</p> <code>None</code> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def create_dyn_obstacle(\n    self,\n    center: models.Vertex,\n    radius: float | None = None,\n    bb_radius: float | None = None,\n) -&gt; models.DynRoundObstacle:\n    \"\"\"\n    Create a dynamic obstacle.\n\n    Arguments:\n        center: center of the obstacle\n        radius: radius of the obstacle, use the value from global properties if not specified\n        bb_radius: radius of the bounding box\n    \"\"\"\n    if radius is None:\n        radius = self.properties.obstacle_radius\n\n    if bb_radius is None:\n        bb_radius = radius + self.properties.robot_width / 2\n\n    obstacle = models.DynRoundObstacle(\n        x=center.x,\n        y=center.y,\n        radius=radius,\n    )\n    obstacle.create_bounding_box(bb_radius, self.properties.obstacle_bb_vertices)\n\n    return obstacle\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.get_action","title":"<code>get_action()</code>","text":"<p>Get a new action for a robot. Simply choose next action in the list for now.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def get_action(self) -&gt; actions.Action | None:\n    \"\"\"\n    Get a new action for a robot.\n    Simply choose next action in the list for now.\n    \"\"\"\n    sorted_actions = sorted(\n        [action for action in self.actions if not action.recycled and action.weight() &gt; 0],\n        key=lambda action: action.weight(),\n    )\n\n    if len(sorted_actions) == 0:\n        return None\n\n    action = sorted_actions[-1]\n    self.actions.remove(action)\n    return action\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.next_pose","title":"<code>next_pose()</code>  <code>async</code>","text":"<p>Select the next pose for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def next_pose(self):\n    \"\"\"\n    Select the next pose for a robot.\n    \"\"\"\n    logger.debug(\"Planner: next_pose()\")\n    try:\n        # Get and set new pose\n        self.pose_reached = False\n        await self.next_pose_in_action()\n\n        # If no pose left in current action, get and set new action\n        if not self.pose_order and (new_action := self.get_action()):\n            await self.set_action(new_action)\n            if not self.pose_order:\n                await self.sio_receiver_queue.put(self.set_pose_reached())\n    except Exception as exc:  # noqa\n        logger.warning(f\"Planner: Unknown exception {exc}\")\n        traceback.print_exc()\n        raise\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Reset planner, context, robots and actions.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def reset(self):\n    \"\"\"\n    Reset planner, context, robots and actions.\n    \"\"\"\n    await self.stop()\n    await self.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_action","title":"<code>set_action(action)</code>  <code>async</code>","text":"<p>Set current action.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_action(self, action: \"actions.Action\"):\n    \"\"\"\n    Set current action.\n    \"\"\"\n    logger.debug(f\"Planner: set action '{action.name}'\")\n    self.pose_order = None\n    self.action = action\n    await self.action.act_before_action()\n    await self.next_pose_in_action()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_obstacles","title":"<code>set_obstacles(obstacles)</code>","text":"<p>Store obstacles detected by a robot sent by Detector. Add bounding box and radius.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def set_obstacles(self, obstacles: list[models.Vertex]) -&gt; None:\n    \"\"\"\n    Store obstacles detected by a robot sent by Detector.\n    Add bounding box and radius.\n    \"\"\"\n    table = self.game_context.table\n    if self.robot_id == 1:\n        bb_radius = self.properties.obstacle_radius + self.properties.robot_length / 2\n\n        self.obstacles = [\n            self.create_dyn_obstacle(obstacle, bb_radius)\n            for obstacle in obstacles\n            if table.contains(obstacle, self.properties.obstacle_radius)\n        ]\n    else:\n        # In case of PAMI, the detected obstacle is at the front the real obstacle\n        # instead of at its center.\n        # Since we use a specific avoidance strategy that only needs to know the path\n        # is intersecting the obstacle, the radius can be reduced to the minimum to create\n        # a bounding box.\n        self.obstacles = [\n            self.create_dyn_obstacle(obstacle, radius=10, bb_radius=10)\n            for obstacle in obstacles\n            if table.contains(obstacle)\n        ]\n    self.obstacles += [p for p in self.game_context.plant_supplies.values() if p.enabled and table.contains(p)]\n    self.obstacles += [p for p in self.game_context.pot_supplies.values() if p.enabled and table.contains(p)]\n    self.obstacles += [p for p in self.game_context.fixed_obstacles if table.contains(p)]\n\n    self.shared_properties[\"obstacles\"] = [\n        obstacle.model_dump(exclude_defaults=True) for obstacle in self.obstacles\n    ]\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_current","title":"<code>set_pose_current(pose)</code>","text":"<p>Set current pose of a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def set_pose_current(self, pose: models.Pose) -&gt; None:\n    \"\"\"\n    Set current pose of a robot.\n    \"\"\"\n    self.pose_current = models.Pose.model_validate(pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_reached","title":"<code>set_pose_reached()</code>  <code>async</code>","text":"<p>Set pose reached for a robot.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_reached(self):\n    \"\"\"\n    Set pose reached for a robot.\n    \"\"\"\n    logger.debug(\"Planner: set_pose_reached()\")\n\n    self.shared_properties[\"last_avoidance_pose_current\"] = None\n\n    if len(self.avoidance_path) &gt; 1:\n        # The pose reached is intermediate, do nothing.\n        return\n\n    # Set pose reached\n    self.avoidance_path = []\n    if not self.pose_reached and (pose_order := self.pose_order):\n        self.pose_order = None\n        await pose_order.act_after_pose()\n    else:\n        self.pose_order = None\n\n    self.pose_reached = True\n    if (action := self.action) and len(self.action.poses) == 0:\n        self.action = None\n        await action.act_after_action()\n\n    if not self.game_context.playing:\n        return\n\n    await self.next_pose()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.set_pose_start","title":"<code>set_pose_start(pose_start)</code>  <code>async</code>","text":"<p>Set the start position of the robot for the next game.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def set_pose_start(self, pose_start: models.Pose):\n    \"\"\"\n    Set the start position of the robot for the next game.\n    \"\"\"\n    self.action = None\n    self.pose_current = pose_start.model_copy()\n    self.pose_order = None\n    self.pose_reached = True\n    self.avoidance_path = []\n    await self.sio_ns.emit(\"pose_start\", pose_start.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.soft_reset","title":"<code>soft_reset()</code>  <code>async</code>","text":"<p>Only reset context and actions.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def soft_reset(self):\n    \"\"\"\n    Only reset context and actions.\n    \"\"\"\n    self.game_context.reset()\n    self.actions = action_classes.get(self.game_context.strategy, actions.Actions)(self)\n    await self.set_pose_start(self.game_context.get_start_pose(self.start_position).pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.start","title":"<code>start()</code>  <code>async</code>","text":"<p>Start sending obstacles list.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def start(self):\n    \"\"\"\n    Start sending obstacles list.\n    \"\"\"\n    logger.info(\"Planner: start\")\n    self.shared_properties[\"exiting\"] = False\n    await self.soft_reset()\n    await self.set_pose_start(self.game_context.get_start_pose(self.start_position).pose)\n    await self.set_controller(self.game_context.default_controller, True)\n    self.sio_receiver_task = asyncio.create_task(\n        self.task_sio_receiver(),\n        name=\"Robot: Task SIO Receiver\",\n    )\n    self.sio_emitter_task = asyncio.create_task(\n        self.task_sio_emitter(),\n        name=\"Robot: Task SIO Emitter\",\n    )\n    await self.sio_ns.emit(\"starter_changed\", self.starter.is_pressed)\n    await self.sio_ns.emit(\"game_reset\")\n    await self.countdown_start()\n    self.obstacles_sender_loop.start()\n    if self.oled_bus and self.oled_address:\n        self.oled_update_loop.start()\n\n    self.avoidance_process = Process(\n        target=avoidance_process,\n        args=(\n            self.game_context.strategy,\n            self.game_context.table,\n            self.shared_properties,\n            self.sio_emitter_queue,\n        ),\n    )\n    self.avoidance_process.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.stop","title":"<code>stop()</code>  <code>async</code>","text":"<p>Stop running tasks.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def stop(self):\n    \"\"\"\n    Stop running tasks.\n    \"\"\"\n    logger.info(\"Planner: stop\")\n\n    self.shared_properties[\"exiting\"] = True\n\n    await self.sio_ns.emit(\"stop_video_record\")\n\n    await self.countdown_stop()\n\n    await self.obstacles_sender_loop.stop()\n    if self.oled_bus and self.oled_address:\n        await self.oled_update_loop.stop()\n\n    if self.sio_emitter_task:\n        self.sio_emitter_task.cancel()\n        try:\n            await self.sio_emitter_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task SIO Emitter stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n    self.sio_emitter_task = None\n\n    if self.sio_receiver_task:\n        self.sio_receiver_task.cancel()\n        try:\n            await self.sio_receiver_task\n        except asyncio.CancelledError:\n            logger.info(\"Planner: Task SIO Receiver stopped\")\n        except Exception as exc:\n            logger.warning(f\"Planner: Unexpected exception {exc}\")\n    self.sio_receiver_task = None\n\n    if self.avoidance_process and self.avoidance_process.is_alive():\n        self.avoidance_process.join()\n        self.avoidance_process = None\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.try_connect","title":"<code>try_connect()</code>  <code>async</code>","text":"<p>Poll to wait for the first connection. Disconnections/reconnections are handle directly by the client.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def try_connect(self):\n    \"\"\"\n    Poll to wait for the first connection.\n    Disconnections/reconnections are handle directly by the client.\n    \"\"\"\n    while self.retry_connection:\n        try:\n            await self.sio.connect(self.server_url, namespaces=[\"/planner\"])\n        except socketio.exceptions.ConnectionError:\n            time.sleep(2)\n            continue\n        break\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.update_config","title":"<code>update_config(config)</code>","text":"<p>Update a Planner property with the value sent by the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>def update_config(self, config: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update a Planner property with the value sent by the dashboard.\n    \"\"\"\n    self.properties.__setattr__(name := config[\"name\"], value := config[\"value\"])\n    if name in self.shared_properties:\n        self.shared_properties[name] = value\n    match name:\n        case \"obstacle_sender_interval\":\n            self.obstacles_sender_loop.interval = self.properties.obstacle_sender_interval\n        case \"robot_width\" | \"obstacle_bb_vertices\":\n            self.game_context.create_artifacts()\n            self.game_context.create_fixed_obstacles()\n</code></pre>"},{"location":"reference/cogip/tools/planner/planner/#cogip.tools.planner.planner.Planner.wizard_response","title":"<code>wizard_response(message)</code>  <code>async</code>","text":"<p>Handle wizard response sent from the dashboard.</p> Source code in <code>cogip/tools/planner/planner.py</code> <pre><code>async def wizard_response(self, message: dict[str, Any]):\n    \"\"\"\n    Handle wizard response sent from the dashboard.\n    \"\"\"\n    if (value := message[\"value\"]) is None:\n        return\n\n    match name := message.get(\"name\"):\n        case \"Choose Camp\":\n            new_camp = Camp.Colors[value]\n            if self.game_context.camp.color == new_camp:\n                return\n            if self.game_context._table == TableEnum.Training and new_camp == Camp.Colors.blue:\n                logger.warning(\"Wizard: only yellow camp is authorized on training table\")\n                return\n            self.game_context.camp.color = new_camp\n            await self.soft_reset()\n            logger.info(f\"Wizard: New camp: {self.game_context.camp.color.name}\")\n        case \"Choose Strategy\":\n            new_strategy = Strategy[value]\n            if self.game_context.strategy == new_strategy:\n                return\n            self.game_context.strategy = new_strategy\n            await self.soft_reset()\n            logger.info(f\"Wizard: New strategy: {self.game_context.strategy.name}\")\n        case \"Choose Avoidance\":\n            new_strategy = AvoidanceStrategy[value]\n            if self.game_context.avoidance_strategy == new_strategy:\n                return\n            self.game_context.avoidance_strategy = new_strategy\n            self.shared_properties[\"avoidance_strategy\"] = new_strategy\n            logger.info(f\"Wizard: New avoidance strategy: {self.game_context.avoidance_strategy.name}\")\n        case \"Choose Start Position\":\n            start_position = StartPosition[value]\n            self.start_position = start_position\n            await self.soft_reset()\n        case \"Choose Table\":\n            new_table = TableEnum[value]\n            if self.game_context.table == new_table:\n                return\n            if self.game_context.camp.color == Camp.Colors.blue and new_table == TableEnum.Training:\n                logger.warning(\"Wizard: training table is not supported with blue camp\")\n                await self.sio_ns.emit(\n                    \"wizard\",\n                    {\n                        \"name\": \"Error\",\n                        \"type\": \"message\",\n                        \"value\": \"Training table is not supported with blue camp\",\n                    },\n                )\n                return\n            self.game_context.table = new_table\n            self.shared_properties[\"table\"] = new_table\n            await self.soft_reset()\n            logger.info(f\"Wizard: New table: {self.game_context._table.name}\")\n        case game_wizard_response if game_wizard_response.startswith(\"Game Wizard\"):\n            await self.game_wizard.response(message)\n        case wizard_test_response if wizard_test_response.startswith(\"Wizard Test\"):\n            logger.info(f\"Wizard test response: {name} = {value}\")\n        case _:\n            logger.warning(f\"Wizard: Unknown type: {name}\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/","title":"pose","text":""},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose","title":"<code>AdaptedPose</code>","text":"<p>               Bases: <code>Pose</code></p> <p>Like a Pose, but its values are automatically adapted to selected camp during initialization. So to define static positions in actions, we can use this class to set pose related to the default camp, and if the camp changes, the pose will be adapted on reset.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class AdaptedPose(Pose):\n    \"\"\"\n    Like a Pose, but its values are automatically adapted to selected camp\n    during initialization.\n    So to define static positions in actions, we can use this class to set pose related\n    to the default camp, and if the camp changes, the pose will be adapted on reset.\n    \"\"\"\n\n    _camp: ClassVar[Camp] = Camp()\n\n    @field_validator(\"y\")\n    @classmethod\n    def adapt_y(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt Y depending on the camp at initialization.\n        \"\"\"\n        return Camp().adapt_y(v)\n\n    @field_validator(\"O\")\n    @classmethod\n    def adapt_O(cls, v, **kwargs):\n        \"\"\"\n        Validator to adapt the angle depending on the camp at initialization.\n        \"\"\"\n        return Camp().adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_O","title":"<code>adapt_O(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt the angle depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"O\")\n@classmethod\ndef adapt_O(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt the angle depending on the camp at initialization.\n    \"\"\"\n    return Camp().adapt_angle(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.AdaptedPose.adapt_y","title":"<code>adapt_y(v, **kwargs)</code>  <code>classmethod</code>","text":"<p>Validator to adapt Y depending on the camp at initialization.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@field_validator(\"y\")\n@classmethod\ndef adapt_y(cls, v, **kwargs):\n    \"\"\"\n    Validator to adapt Y depending on the camp at initialization.\n    \"\"\"\n    return Camp().adapt_y(v)\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>PathPose</code></p> <p>Pose class used in actions. A function can be executed before moving and an other once it is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>class Pose(PathPose):\n    \"\"\"\n    Pose class used in actions.\n    A function can be executed before moving and an other once it is reached.\n    \"\"\"\n\n    before_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    intermediate_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n    after_pose_func: Callable[[socketio.ClientNamespace], Awaitable[None]] | None = None\n\n    @final\n    async def act_before_pose(self):\n        \"\"\"\n        Function executed before the robot starts moving.\n        \"\"\"\n        if self.before_pose_func:\n            await self.before_pose_func()\n\n    @final\n    async def act_intermediate_pose(self):\n        \"\"\"\n        Function executed once an intermediate pose is reached.\n        \"\"\"\n        if self.intermediate_pose_func:\n            await self.intermediate_pose_func()\n\n    @final\n    async def act_after_pose(self):\n        \"\"\"\n        Function executed once the pose is reached.\n        \"\"\"\n        if self.after_pose_func:\n            await self.after_pose_func()\n\n    @property\n    def path_pose(self) -&gt; PathPose:\n        \"\"\"\n        Convert the pose into its parent class.\n        \"\"\"\n        return PathPose(**self.model_dump())\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.path_pose","title":"<code>path_pose: PathPose</code>  <code>property</code>","text":"<p>Convert the pose into its parent class.</p>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_after_pose","title":"<code>act_after_pose()</code>  <code>async</code>","text":"<p>Function executed once the pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_after_pose(self):\n    \"\"\"\n    Function executed once the pose is reached.\n    \"\"\"\n    if self.after_pose_func:\n        await self.after_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_before_pose","title":"<code>act_before_pose()</code>  <code>async</code>","text":"<p>Function executed before the robot starts moving.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_before_pose(self):\n    \"\"\"\n    Function executed before the robot starts moving.\n    \"\"\"\n    if self.before_pose_func:\n        await self.before_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/pose/#cogip.tools.planner.pose.Pose.act_intermediate_pose","title":"<code>act_intermediate_pose()</code>  <code>async</code>","text":"<p>Function executed once an intermediate pose is reached.</p> Source code in <code>cogip/tools/planner/pose.py</code> <pre><code>@final\nasync def act_intermediate_pose(self):\n    \"\"\"\n    Function executed once an intermediate pose is reached.\n    \"\"\"\n    if self.intermediate_pose_func:\n        await self.intermediate_pose_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/positions/","title":"positions","text":""},{"location":"reference/cogip/tools/planner/positions/#cogip.tools.planner.positions.StartPosition","title":"<code>StartPosition</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for available start positions.</p> Source code in <code>cogip/tools/planner/positions.py</code> <pre><code>class StartPosition(IntEnum):\n    \"\"\"\n    Enum for available start positions.\n    \"\"\"\n\n    Top = auto()\n    Bottom = auto()\n    Opposite = auto()\n    PAMI2 = auto()\n    PAMI3 = auto()\n    PAMI4 = auto()\n    PAMI2_TRAINING = auto()\n    PAMI3_TRAINING = auto()\n    PAMI4_TRAINING = auto()\n    Center = auto()\n</code></pre>"},{"location":"reference/cogip/tools/planner/properties/","title":"properties","text":""},{"location":"reference/cogip/tools/planner/sio_events/","title":"sio_events","text":""},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents","title":"<code>SioEvents</code>","text":"<p>               Bases: <code>AsyncClientNamespace</code></p> <p>Handle all SocketIO events received by Planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>class SioEvents(socketio.AsyncClientNamespace):\n    \"\"\"\n    Handle all SocketIO events received by Planner.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__(\"/planner\")\n        self.planner = planner\n        self.game_context = context.GameContext()\n\n    async def on_connect(self):\n        \"\"\"\n        On connection to cogip-server.\n        \"\"\"\n        await asyncio.to_thread(\n            polling2.poll,\n            lambda: self.client.connected is True,\n            step=0.2,\n            poll_forever=True,\n        )\n        logger.info(\"Connected to cogip-server\")\n        await self.emit(\"connected\")\n        await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n        if self.planner.robot_id == 1:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n        else:\n            await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n        await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n\n    async def on_disconnect(self):\n        \"\"\"\n        On disconnection from cogip-server.\n        \"\"\"\n        await self.planner.stop()\n        logger.info(\"Disconnected from cogip-server\")\n\n    async def on_connect_error(self, data: dict[str, Any]):\n        \"\"\"\n        On connection error, check if a Planner is already connected and exit,\n        or retry connection.\n        \"\"\"\n        if (\n            data\n            and isinstance(data, dict)\n            and (message := data.get(\"message\"))\n            and message == \"A planner is already connected\"\n        ):\n            logger.error(f\"Connection to cogip-server failed: {message}\")\n            self.planner.retry_connection = False\n            return\n        else:\n            logger.error(f\"Connection to cogip-server failed: {data = }\")\n\n    async def on_copilot_connected(self):\n        \"\"\"\n        Copilot connected, start planner.\n        \"\"\"\n        await self.planner.start()\n\n    async def on_copilot_disconnected(self):\n        \"\"\"\n        Copilot disconnected, stop planner.\n        \"\"\"\n        await self.planner.stop()\n\n    def on_starter_changed(self, pushed: bool):\n        \"\"\"\n        Signal received from the Monitor when the starter state changes in emulation mode.\n        \"\"\"\n        if not self.planner.virtual:\n            return\n        if pushed:\n            self.planner.starter.pin.drive_low()\n        else:\n            self.planner.starter.pin.drive_high()\n\n    async def on_reset(self):\n        \"\"\"\n        Callback on reset message from copilot.\n        \"\"\"\n        await self.planner.reset()\n\n    async def on_pose_current(self, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose current message.\n        \"\"\"\n        self.planner.set_pose_current(models.Pose.model_validate(pose))\n\n    async def on_pose_reached(self):\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        await self.planner.sio_receiver_queue.put(self.planner.set_pose_reached())\n\n    async def on_command(self, cmd: str):\n        \"\"\"\n        Callback on command message from dashboard.\n        \"\"\"\n        await self.planner.command(cmd)\n\n    async def on_config_updated(self, config: dict[str, Any]):\n        \"\"\"\n        Callback on config update from dashboard.\n        \"\"\"\n        self.planner.update_config(config)\n\n    async def on_obstacles(self, obstacles: dict[str, Any]):\n        \"\"\"\n        Callback on obstacles message.\n        \"\"\"\n        self.planner.set_obstacles(TypeAdapter(list[models.Vertex]).validate_python(obstacles))\n\n    async def on_wizard(self, message: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.planner.wizard_response(message)\n\n    async def on_game_end(self):\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        await self.planner.game_end()\n\n    async def on_actuator_state(self, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        try:\n            state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n        except ValidationError as exc:\n            logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n            return\n\n        await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_actuator_state","title":"<code>on_actuator_state(actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_actuator_state(self, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    try:\n        state = TypeAdapter(ActuatorState).validate_python(actuator_state)\n    except ValidationError as exc:\n        logger.warning(f\"Failed to decode ActuatorState: {exc}\")\n        return\n\n    await self.planner.update_actuator_state(state)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_command","title":"<code>on_command(cmd)</code>  <code>async</code>","text":"<p>Callback on command message from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_command(self, cmd: str):\n    \"\"\"\n    Callback on command message from dashboard.\n    \"\"\"\n    await self.planner.command(cmd)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_config_updated","title":"<code>on_config_updated(config)</code>  <code>async</code>","text":"<p>Callback on config update from dashboard.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_config_updated(self, config: dict[str, Any]):\n    \"\"\"\n    Callback on config update from dashboard.\n    \"\"\"\n    self.planner.update_config(config)\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect","title":"<code>on_connect()</code>  <code>async</code>","text":"<p>On connection to cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect(self):\n    \"\"\"\n    On connection to cogip-server.\n    \"\"\"\n    await asyncio.to_thread(\n        polling2.poll,\n        lambda: self.client.connected is True,\n        step=0.2,\n        poll_forever=True,\n    )\n    logger.info(\"Connected to cogip-server\")\n    await self.emit(\"connected\")\n    await self.emit(\"register_menu\", {\"name\": \"planner\", \"menu\": menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"wizard\", \"menu\": wizard_test_menu.model_dump()})\n    if self.planner.robot_id == 1:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": robot_actuators_menu.model_dump()})\n    else:\n        await self.emit(\"register_menu\", {\"name\": \"actuators\", \"menu\": pami_actuators_menu.model_dump()})\n    await self.emit(\"register_menu\", {\"name\": \"cameras\", \"menu\": cameras_menu.model_dump()})\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_connect_error","title":"<code>on_connect_error(data)</code>  <code>async</code>","text":"<p>On connection error, check if a Planner is already connected and exit, or retry connection.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_connect_error(self, data: dict[str, Any]):\n    \"\"\"\n    On connection error, check if a Planner is already connected and exit,\n    or retry connection.\n    \"\"\"\n    if (\n        data\n        and isinstance(data, dict)\n        and (message := data.get(\"message\"))\n        and message == \"A planner is already connected\"\n    ):\n        logger.error(f\"Connection to cogip-server failed: {message}\")\n        self.planner.retry_connection = False\n        return\n    else:\n        logger.error(f\"Connection to cogip-server failed: {data = }\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_connected","title":"<code>on_copilot_connected()</code>  <code>async</code>","text":"<p>Copilot connected, start planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_connected(self):\n    \"\"\"\n    Copilot connected, start planner.\n    \"\"\"\n    await self.planner.start()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_copilot_disconnected","title":"<code>on_copilot_disconnected()</code>  <code>async</code>","text":"<p>Copilot disconnected, stop planner.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_copilot_disconnected(self):\n    \"\"\"\n    Copilot disconnected, stop planner.\n    \"\"\"\n    await self.planner.stop()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_disconnect","title":"<code>on_disconnect()</code>  <code>async</code>","text":"<p>On disconnection from cogip-server.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_disconnect(self):\n    \"\"\"\n    On disconnection from cogip-server.\n    \"\"\"\n    await self.planner.stop()\n    logger.info(\"Disconnected from cogip-server\")\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_game_end","title":"<code>on_game_end()</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_game_end(self):\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    await self.planner.game_end()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_obstacles","title":"<code>on_obstacles(obstacles)</code>  <code>async</code>","text":"<p>Callback on obstacles message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_obstacles(self, obstacles: dict[str, Any]):\n    \"\"\"\n    Callback on obstacles message.\n    \"\"\"\n    self.planner.set_obstacles(TypeAdapter(list[models.Vertex]).validate_python(obstacles))\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_pose_current","title":"<code>on_pose_current(pose)</code>  <code>async</code>","text":"<p>Callback on pose current message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_pose_current(self, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose current message.\n    \"\"\"\n    self.planner.set_pose_current(models.Pose.model_validate(pose))\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_pose_reached","title":"<code>on_pose_reached()</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_pose_reached(self):\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    await self.planner.sio_receiver_queue.put(self.planner.set_pose_reached())\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_reset","title":"<code>on_reset()</code>  <code>async</code>","text":"<p>Callback on reset message from copilot.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_reset(self):\n    \"\"\"\n    Callback on reset message from copilot.\n    \"\"\"\n    await self.planner.reset()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_starter_changed","title":"<code>on_starter_changed(pushed)</code>","text":"<p>Signal received from the Monitor when the starter state changes in emulation mode.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>def on_starter_changed(self, pushed: bool):\n    \"\"\"\n    Signal received from the Monitor when the starter state changes in emulation mode.\n    \"\"\"\n    if not self.planner.virtual:\n        return\n    if pushed:\n        self.planner.starter.pin.drive_low()\n    else:\n        self.planner.starter.pin.drive_high()\n</code></pre>"},{"location":"reference/cogip/tools/planner/sio_events/#cogip.tools.planner.sio_events.SioEvents.on_wizard","title":"<code>on_wizard(message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/planner/sio_events.py</code> <pre><code>async def on_wizard(self, message: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.planner.wizard_response(message)\n</code></pre>"},{"location":"reference/cogip/tools/planner/table/","title":"table","text":""},{"location":"reference/cogip/tools/planner/table/#cogip.tools.planner.table.TableEnum","title":"<code>TableEnum</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum for available tables.</p> Source code in <code>cogip/tools/planner/table.py</code> <pre><code>class TableEnum(IntEnum):\n    \"\"\"\n    Enum for available tables.\n    \"\"\"\n\n    Training = 0\n    Game = 1\n</code></pre>"},{"location":"reference/cogip/tools/planner/wizard/","title":"wizard","text":""},{"location":"reference/cogip/tools/planner/actions/actions/","title":"actions","text":""},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action","title":"<code>Action</code>","text":"<p>This class represents an action of the game. It contains a list of Pose to reach in order. A function can be executed before the action starts and after it ends.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class Action:\n    \"\"\"\n    This class represents an action of the game.\n    It contains a list of Pose to reach in order.\n    A function can be executed before the action starts and after it ends.\n    \"\"\"\n\n    def __init__(self, name: str, planner: \"Planner\", actions: \"Actions\", interruptable: bool = True):\n        self.name = name\n        self.planner = planner\n        self.actions = actions\n        self.interruptable = interruptable\n        self.game_context = context.GameContext()\n        self.poses: list[Pose] = []\n        self.before_action_func: Callable[[], Awaitable[None]] | None = None\n        self.after_action_func: Callable[[], Awaitable[None]] | None = None\n        self.recycled: bool = False\n\n    def weight(self) -&gt; float:\n        \"\"\"\n        Weight of the action.\n        It can be used to choose the next action to select.\n        This is the generic implementation.\n        \"\"\"\n        raise NotImplementedError\n\n    @final\n    async def act_before_action(self):\n        \"\"\"\n        Function executed before the action starts.\n        \"\"\"\n        if self.before_action_func:\n            await self.before_action_func()\n\n    @final\n    async def act_after_action(self):\n        \"\"\"\n        Function executed after the action ends.\n        \"\"\"\n        if self.after_action_func:\n            await self.after_action_func()\n\n        # Re-enable all actions after a successful action\n        for action in self.actions:\n            action.recycled = False\n\n    async def recycle(self):\n        \"\"\"\n        Function called if the action is blocked and put back in the actions list\n        \"\"\"\n        self.recycled = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.act_after_action","title":"<code>act_after_action()</code>  <code>async</code>","text":"<p>Function executed after the action ends.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>@final\nasync def act_after_action(self):\n    \"\"\"\n    Function executed after the action ends.\n    \"\"\"\n    if self.after_action_func:\n        await self.after_action_func()\n\n    # Re-enable all actions after a successful action\n    for action in self.actions:\n        action.recycled = False\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.act_before_action","title":"<code>act_before_action()</code>  <code>async</code>","text":"<p>Function executed before the action starts.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>@final\nasync def act_before_action(self):\n    \"\"\"\n    Function executed before the action starts.\n    \"\"\"\n    if self.before_action_func:\n        await self.before_action_func()\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.recycle","title":"<code>recycle()</code>  <code>async</code>","text":"<p>Function called if the action is blocked and put back in the actions list</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>async def recycle(self):\n    \"\"\"\n    Function called if the action is blocked and put back in the actions list\n    \"\"\"\n    self.recycled = True\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Action.weight","title":"<code>weight()</code>","text":"<p>Weight of the action. It can be used to choose the next action to select. This is the generic implementation.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>def weight(self) -&gt; float:\n    \"\"\"\n    Weight of the action.\n    It can be used to choose the next action to select.\n    This is the generic implementation.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.Actions","title":"<code>Actions</code>","text":"<p>               Bases: <code>list[Action]</code></p> <p>List of actions. Just inherits from list for now.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class Actions(list[Action]):\n    \"\"\"\n    List of actions.\n    Just inherits from list for now.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\"):\n        super().__init__()\n        self.planner = planner\n        self.game_context = context.GameContext()\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/actions/#cogip.tools.planner.actions.actions.WaitAction","title":"<code>WaitAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used if no other action is available. Reset recycled attribute of all actions at the end.</p> Source code in <code>cogip/tools/planner/actions/actions.py</code> <pre><code>class WaitAction(Action):\n    \"\"\"\n    Action used if no other action is available.\n    Reset recycled attribute of all actions at the end.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: \"Actions\"):\n        super().__init__(\"Wait action\", planner, actions)\n        self.before_action_func = self.before_wait\n        self.after_action_func = self.after_wait\n\n    def weight(self) -&gt; float:\n        return 1\n\n    async def before_wait(self):\n        logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: before action\")\n\n    async def after_wait(self):\n        logger.debug(f\"Robot {self.planner.robot_id}: WaitAction: after action\")\n        await asyncio.sleep(2)\n\n        for action in self.actions:\n            action.recycled = False\n\n        self.actions.append(WaitAction(self.planner, self.actions))\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/back_and_forth/","title":"back_and_forth","text":""},{"location":"reference/cogip/tools/planner/actions/back_and_forth/#cogip.tools.planner.actions.back_and_forth.BackAndForthAction","title":"<code>BackAndForthAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Example action that generate its poses depending of the robot's pose at the beginning of the action. The robot will go from the current position to its opposite position in loop.</p> Source code in <code>cogip/tools/planner/actions/back_and_forth.py</code> <pre><code>class BackAndForthAction(Action):\n    \"\"\"\n    Example action that generate its poses depending of the robot's pose\n    at the beginning of the action.\n    The robot will go from the current position to its opposite position in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"BackAnForth action\", planner, actions)\n        self.before_action_func = self.compute_poses\n\n    async def compute_poses(self) -&gt; None:\n        x = self.planner.pose_current.x\n        y = self.game_context.table.y_min + self.game_context.table.y_max - self.planner.pose_current.y\n        angle = -self.planner.pose_current.O\n        pose1 = Pose(\n            x=x,\n            y=y,\n            O=angle,\n            max_speed_linear=66,\n            max_speed_angular=66,\n        )\n        pose2 = Pose(**self.planner.pose_current.model_dump())\n        pose1.after_pose_func = partial(self.append_pose, pose1)\n        pose2.after_pose_func = partial(self.append_pose, pose2)\n        self.poses.append(pose1)\n        self.poses.append(pose2)\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/","title":"base_actions","text":""},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.AlignAction","title":"<code>AlignAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used align the robot before game start.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class AlignAction(Action):\n    \"\"\"\n    Action used align the robot before game start.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"Align action\", planner, actions)\n        self.before_action_func = self.init_poses\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.game_context.avoidance_strategy = new_strategy\n        self.planner.shared_properties[\"avoidance_strategy\"] = new_strategy\n\n    async def init_poses(self):\n        self.start_pose = self.planner.pose_current.model_copy()\n        self.start_avoidance = self.game_context.avoidance_strategy\n\n        await asyncio.gather(\n            actuators.bottom_grip_close(self.planner),\n            actuators.top_grip_close(self.planner),\n            actuators.arm_panel_close(self.planner),\n            actuators.cart_in(self.planner),\n            asyncio.sleep(0.5),\n        )\n        await asyncio.gather(\n            actuators.bottom_lift_up(self.planner),\n            actuators.top_lift_up(self.planner),\n        )\n\n        if Camp().adapt_y(self.start_pose.y) &gt; 0:\n            # Do not do alignment if the robot is in the opposite start position because it is not in a corner\n            return\n\n        pose1 = AdaptedPose(\n            x=self.start_pose.x,\n            y=-1700 + self.game_context.properties.robot_length / 2,\n            O=0,\n            max_speed_linear=5,\n            max_speed_angular=5,\n            allow_reverse=True,\n            bypass_anti_blocking=True,\n            timeout_ms=0,  # TODO\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose1)\n\n    async def before_pose1(self):\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_pose1(self):\n        self.set_avoidance(self.start_avoidance)\n        current_pose = self.planner.pose_current.model_copy()\n        current_pose.y = Camp().adapt_y(-1500 + self.game_context.properties.robot_length / 2)\n        current_pose.O = Camp().adapt_angle(90)\n        await self.planner.sio_ns.emit(\"pose_start\", current_pose.model_dump())\n\n        pose2 = AdaptedPose(\n            x=current_pose.x,\n            y=-1250,\n            O=180 if current_pose.x &gt; 0 else 0,\n            max_speed_linear=20,\n            max_speed_angular=20,\n            allow_reverse=False,\n        )\n        self.poses.append(pose2)\n\n        if current_pose.x &gt; 0:\n            x = 1200 - self.game_context.properties.robot_length / 2\n        else:\n            x = -1200 + self.game_context.properties.robot_length / 2\n        pose3 = AdaptedPose(\n            x=x,\n            y=-1250,\n            O=0,\n            max_speed_linear=5,\n            max_speed_angular=5,\n            allow_reverse=True,\n            bypass_anti_blocking=True,\n            timeout_ms=0,  # TODO\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose3,\n            after_pose_func=self.after_pose3,\n        )\n        self.poses.append(pose3)\n\n    async def before_pose3(self):\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n\n    async def after_pose3(self):\n        self.set_avoidance(self.start_avoidance)\n        current_pose = self.planner.pose_current.model_copy()\n        if current_pose.x &gt; 0:\n            current_pose.x = 1000 - self.game_context.properties.robot_length / 2\n        else:\n            current_pose.x = -1000 + self.game_context.properties.robot_length / 2\n        current_pose.O = 180 if current_pose.x &gt; 0 else 0\n        await self.planner.sio_ns.emit(\"pose_start\", current_pose.model_dump())\n\n        pose4 = Pose(\n            x=730 if current_pose.x &gt; 0 else -730,\n            y=current_pose.y,\n            O=current_pose.O,\n            max_speed_linear=33,\n            max_speed_angular=33,\n            allow_reverse=False,\n        )\n        self.poses.append(pose4)\n\n        pose5 = Pose(\n            x=self.start_pose.x,\n            y=self.start_pose.y,\n            O=self.start_pose.O,\n            max_speed_linear=33,\n            max_speed_angular=33,\n            allow_reverse=True,\n        )\n        self.poses.append(pose5)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.DropInDropoffZoneAction","title":"<code>DropInDropoffZoneAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Drop plants from the lower grips in a dropoff zone.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class DropInDropoffZoneAction(Action):\n    \"\"\"\n    Drop plants from the lower grips in a dropoff zone.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, dropoff_zone_id: artifacts.DropoffZoneID, slot: int):\n        super().__init__(\"DropInDropoffZone action\", planner, actions)\n        self.dropoff_zone = self.game_context.dropoff_zones[dropoff_zone_id]\n        self.slot = slot\n        self.push_pot: PushPotAction | None = None\n        self.after_action_func = self.after_action\n\n        match dropoff_zone_id:\n            case artifacts.DropoffZoneID.Top:\n                x = self.dropoff_zone.x + (self.slot - 1) * 125 - self.game_context.properties.robot_length / 2\n                y = -1180\n                if self.slot == 2:\n                    # Prepare PushPot action\n                    self.push_pot = PushPotAction(self.planner, self.actions, artifacts.PotSupplyID.LocalTop)\n                    x2 = self.push_pot.poses[0].x\n                    y2 = self.push_pot.poses[0].y\n                else:\n                    x2 = x - 150\n                    y2 = y\n                angle = 0\n            case artifacts.DropoffZoneID.Bottom:\n                x = self.dropoff_zone.x - (self.slot - 1) * 125 + self.game_context.properties.robot_length / 2\n                y = -1180\n                if self.slot == 2 and self.game_context._table == TableEnum.Training:\n                    # Prepare PushPot action\n                    self.push_pot = PushPotAction(self.planner, self.actions, artifacts.PotSupplyID.LocalMiddle)\n                    x2 = self.push_pot.poses[0].x\n                    y2 = self.push_pot.poses[0].y\n                else:\n                    x2 = x + 150\n                    y2 = y\n                angle = 180\n            case artifacts.DropoffZoneID.Opposite:\n                x = x2 = self.dropoff_zone.x\n                y = self.dropoff_zone.y + (self.slot - 1) * 125 - self.game_context.properties.robot_length / 2\n                y2 = y - 150\n                angle = 90\n\n        self.poses.append(\n            AdaptedPose(\n                x=x,\n                y=y,\n                O=angle,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=False,\n                after_pose_func=self.after_pose1,\n            )\n        )\n\n        self.poses.append(\n            AdaptedPose(\n                x=x2,\n                y=y2,\n                O=angle,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=True,\n                after_pose_func=self.after_pose2,\n            )\n        )\n\n    async def after_pose1(self):\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state\n            and self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state\n        ):\n            # Do not count plant without pot because we do not know its color\n            self.game_context.score += 3  # Plant valid\n            self.game_context.score += 1  # Plant in pot\n\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state\n            and self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state\n        ):\n            # Do not count plant without pot because we do not know its color\n            self.game_context.score += 3  # Plant valid\n            self.game_context.score += 1  # Plant in pot\n\n        await actuators.bottom_grip_open(self.planner)\n        await actuators.cart_magnet_off(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.cart_in(self.planner)\n\n    async def after_pose2(self):\n        self.dropoff_zone.free_slots -= 1\n        if BoolSensorEnum.BOTTOM_GRIP_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state = False\n        if BoolSensorEnum.MAGNET_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state = False\n        if BoolSensorEnum.MAGNET_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state = False\n        if BoolSensorEnum.BOTTOM_GRIP_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state = False\n\n    async def after_action(self):\n        if self.push_pot:\n            self.actions.append(self.push_pot)\n\n    def weight(self) -&gt; float:\n        if not (\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state\n            and self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state\n        ):\n            return 0\n\n        if self.slot + 1 == self.dropoff_zone.free_slots:\n            return 1000000.0\n        return 0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.DropInPlanterAction","title":"<code>DropInPlanterAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Drop plants from the upper grips in a planter.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class DropInPlanterAction(Action):\n    \"\"\"\n    Drop plants from the upper grips in a planter.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, planter_id: artifacts.PlanterID):\n        super().__init__(\"DropInPlanter action\", planner, actions)\n        self.planter = self.game_context.planters[planter_id]\n        self.blocking_extra_move = 20\n        self.front_excess = 85\n        self.approach_delta = 50\n        self.half_robot_length = self.game_context.properties.robot_length / 2\n\n        if self.game_context.camp.color == Camp.Colors.yellow:\n            match planter_id:\n                case artifacts.PlanterID.Top:\n                    drop_x = self.planter.x + self.front_excess + self.blocking_extra_move - self.half_robot_length\n                    approach_x = self.planter.x - self.approach_delta - self.half_robot_length\n                    approach_y = drop_y = self.planter.y\n                case artifacts.PlanterID.LocalSide | artifacts.PlanterID.Test:\n                    approach_x = drop_x = self.planter.x\n                    drop_y = self.planter.y - self.front_excess - self.blocking_extra_move + self.half_robot_length\n                    approach_y = self.planter.y + self.approach_delta + self.half_robot_length\n                case artifacts.PlanterID.OppositeSide:\n                    approach_x = drop_x = self.planter.x\n                    drop_y = self.planter.y + self.front_excess + self.blocking_extra_move - self.half_robot_length\n                    approach_y = self.planter.y - self.approach_delta - self.half_robot_length\n        else:\n            match planter_id:\n                case artifacts.PlanterID.Top:\n                    drop_x = self.planter.x + self.front_excess + self.blocking_extra_move - self.half_robot_length\n                    approach_x = self.planter.x - self.approach_delta - self.half_robot_length\n                    approach_y = drop_y = self.planter.y\n                case artifacts.PlanterID.LocalSide | artifacts.PlanterID.Test:\n                    approach_x = drop_x = self.planter.x\n                    drop_y = self.planter.y + self.front_excess + self.blocking_extra_move - self.half_robot_length\n                    approach_y = self.planter.y - self.approach_delta - self.half_robot_length\n                case artifacts.PlanterID.OppositeSide:\n                    approach_x = drop_x = self.planter.x\n                    drop_y = self.planter.y - self.front_excess - self.blocking_extra_move + self.half_robot_length\n                    approach_y = self.planter.y + self.approach_delta + self.half_robot_length\n\n        self.poses.append(\n            Pose(\n                x=approach_x,\n                y=approach_y,\n                O=self.planter.O,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=False,\n                before_pose_func=self.before_pose1,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=drop_x,\n                y=drop_y,\n                O=self.planter.O,\n                max_speed_linear=5,\n                max_speed_angular=5,\n                allow_reverse=False,\n                bypass_anti_blocking=True,\n                timeout_ms=0,  # TODO\n                before_pose_func=self.before_pose2,\n                after_pose_func=self.after_pose2,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=approach_x,\n                y=approach_y,\n                O=self.planter.O,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=True,\n            )\n        )\n\n    def set_avoidance(self, new_strategy: AvoidanceStrategy):\n        self.game_context.avoidance_strategy = new_strategy\n        self.planner.shared_properties[\"avoidance_strategy\"] = new_strategy\n\n    async def before_pose1(self):\n        self.start_pose = self.planner.pose_current.model_copy()\n        self.start_avoidance = self.game_context.avoidance_strategy\n        match self.planter.id:\n            case artifacts.PlanterID.LocalSide:\n                self.game_context.pot_supplies[artifacts.PotSupplyID.LocalTop].enabled = False\n            case artifacts.PlanterID.Test:\n                self.game_context.pot_supplies[artifacts.PotSupplyID.LocalMiddle].enabled = False\n            case artifacts.PlanterID.OppositeSide:\n                self.game_context.pot_supplies[artifacts.PotSupplyID.OppositeMiddle].enabled = False\n\n    async def before_pose2(self):\n        self.set_avoidance(AvoidanceStrategy.Disabled)\n        await actuators.bottom_grip_mid_close(self.planner)\n\n    async def after_pose2(self):\n        self.set_avoidance(self.start_avoidance)\n\n        if self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_LEFT].state:\n            self.game_context.score += 3  # Plant valid\n            self.game_context.score += 1  # Plant in planter\n        if self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_RIGHT].state:\n            self.game_context.score += 3  # Plant valid\n            self.game_context.score += 1  # Plant in planter\n\n        await actuators.top_lift_mid(self.planner)\n        await asyncio.sleep(0.7)\n        await actuators.top_grip_open(self.planner)\n        await asyncio.sleep(0.5)\n        await actuators.bottom_grip_mid_open(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.bottom_grip_open(self.planner)\n\n        if self.planner.virtual:\n            current_pose = self.planner.pose_current.model_copy()\n            if self.game_context.camp.color == Camp.Colors.yellow:\n                match self.planter.id:\n                    case artifacts.PlanterID.Top:\n                        current_pose.x = self.planter.x - self.half_robot_length\n                    case artifacts.PlanterID.LocalSide | artifacts.PlanterID.Test:\n                        current_pose.y = self.planter.y + self.half_robot_length\n                    case artifacts.PlanterID.OppositeSide:\n                        current_pose.y = self.planter.y - self.half_robot_length\n            else:\n                match self.planter.id:\n                    case artifacts.PlanterID.Top:\n                        current_pose.x = self.planter.x - self.half_robot_length\n                    case artifacts.PlanterID.LocalSide | artifacts.PlanterID.Test:\n                        current_pose.y = self.planter.y - self.half_robot_length\n                    case artifacts.PlanterID.OppositeSide:\n                        current_pose.y = self.planter.y + self.half_robot_length\n\n            current_pose.O = self.planter.O\n            await self.planner.sio_ns.emit(\"pose_start\", current_pose.model_dump())\n\n        if BoolSensorEnum.TOP_GRIP_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_LEFT].state = False\n        if BoolSensorEnum.TOP_GRIP_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_RIGHT].state = False\n\n    def weight(self) -&gt; float:\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state\n        ):\n            return 0\n        if not (\n            self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_LEFT].state\n            and self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_RIGHT].state\n        ):\n            return 0\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state\n        ):\n            return 0\n        match self.planter.id:\n            case artifacts.PlanterID.LocalSide:\n                if self.game_context.pot_supplies[artifacts.PotSupplyID.LocalTop].count &gt; 0:\n                    return 0\n            case artifacts.PlanterID.OppositeSide:\n                if self.game_context.pot_supplies[artifacts.PotSupplyID.OppositeMiddle].count &gt; 0:\n                    return 0\n\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.GripAction","title":"<code>GripAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to grip plants.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class GripAction(Action):\n    \"\"\"\n    Action used to grip plants.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, plant_supply_id: artifacts.PlantSupplyID):\n        super().__init__(\"Grip action\", planner, actions)\n        self.before_action_func = self.before_action\n        self.plant_supply = self.game_context.plant_supplies[plant_supply_id]\n        self.stop_before_center_1 = 180\n\n    async def recycle(self):\n        self.plant_supply.enabled = True\n        self.recycled = True\n\n    async def before_action(self):\n        # Compute first pose to get plants using bottom grips\n        self.plant_supply.enabled = False\n        self.start_pose = self.planner.pose_current.model_copy()\n        dist_x = self.plant_supply.x - self.planner.pose_current.x\n        dist_y = self.plant_supply.y - self.planner.pose_current.y\n        dist = math.hypot(dist_x, dist_y)\n        pose = Pose(\n            x=self.plant_supply.x - dist_x / dist * self.stop_before_center_1,\n            y=self.plant_supply.y - dist_y / dist * self.stop_before_center_1,\n            O=0,\n            max_speed_linear=30,\n            max_speed_angular=30,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            before_pose_func=self.before_pose1,\n            intermediate_pose_func=self.intermediate_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose)\n\n    async def before_pose1(self):\n        await actuators.arm_panel_close(self.planner)\n        await actuators.bottom_lift_down(self.planner)\n        await asyncio.sleep(0.5)\n        await actuators.top_lift_down(self.planner)\n        await asyncio.sleep(0.5)\n        await asyncio.gather(\n            actuators.bottom_grip_open(self.planner),\n            actuators.top_grip_open(self.planner),\n        )\n\n    async def intermediate_pose1(self):\n        # Update first pose to take avoidance into account\n        dist_x = self.plant_supply.x - self.planner.pose_current.x\n        dist_y = self.plant_supply.y - self.planner.pose_current.y\n        dist = math.hypot(dist_x, dist_y)\n        self.planner.pose_order.x = self.plant_supply.x - dist_x / dist * self.stop_before_center_1\n        self.planner.pose_order.y = self.plant_supply.y - dist_y / dist * self.stop_before_center_1\n        self.planner.shared_properties[\"pose_order\"] = self.planner.pose_order.path_pose.model_dump(exclude_unset=True)\n\n    async def after_pose1(self):\n        await actuators.top_grip_mid_open(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.top_grip_mid(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.top_grip_mid_close(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.top_grip_close(self.planner)\n        await asyncio.sleep(0.1)\n\n        if BoolSensorEnum.TOP_GRIP_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_LEFT].state = True\n        if BoolSensorEnum.TOP_GRIP_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_RIGHT].state = True\n\n        # Step back\n        back_dist = 100\n        diff_x = back_dist * math.cos(math.radians(self.planner.pose_current.O))\n        diff_y = back_dist * math.sin(math.radians(self.planner.pose_current.O))\n\n        pose = Pose(\n            x=self.planner.pose_current.x - diff_x,\n            y=self.planner.pose_current.y - diff_y,\n            O=0,\n            max_speed_linear=66,\n            max_speed_angular=66,\n            allow_reverse=True,\n            bypass_final_orientation=True,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose)\n\n    async def after_pose2(self):\n        await actuators.top_lift_up(self.planner)\n        await asyncio.sleep(0.5)\n\n        # Compute pose to get plants using bottom grips\n        forward_dist = 220\n        diff_x = forward_dist * math.cos(math.radians(self.planner.pose_current.O))\n        diff_y = forward_dist * math.sin(math.radians(self.planner.pose_current.O))\n\n        pose = Pose(\n            x=self.planner.pose_current.x + diff_x,\n            y=self.planner.pose_current.y + diff_y,\n            O=0,\n            max_speed_linear=20,\n            max_speed_angular=20,\n            allow_reverse=False,\n            bypass_final_orientation=True,\n            after_pose_func=self.after_pose3,\n        )\n        self.poses.append(pose)\n\n    async def after_pose3(self):\n        await actuators.bottom_grip_mid_open(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.bottom_grip_mid(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.bottom_grip_mid_close(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.bottom_grip_close(self.planner)\n        await asyncio.sleep(0.1)\n        await actuators.bottom_lift_up(self.planner)\n        if BoolSensorEnum.BOTTOM_GRIP_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state = True\n        if BoolSensorEnum.BOTTOM_GRIP_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state = True\n\n        # Step back\n        back_dist = 250\n        diff_x = back_dist * math.cos(math.radians(self.planner.pose_current.O))\n        diff_y = back_dist * math.sin(math.radians(self.planner.pose_current.O))\n\n        pose = Pose(\n            x=self.planner.pose_current.x - diff_x,\n            y=self.planner.pose_current.y - diff_y,\n            O=0,\n            max_speed_linear=66,\n            max_speed_angular=66,\n            allow_reverse=True,\n            bypass_final_orientation=True,\n            after_pose_func=self.after_pose4,\n        )\n        self.poses.append(pose)\n\n    async def after_pose4(self):\n        self.plant_supply.enabled = True\n\n    def weight(self) -&gt; float:\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.TOP_GRIP_RIGHT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state\n        ):\n            return 0\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.PotCaptureAction","title":"<code>PotCaptureAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to capture pots using magnets.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class PotCaptureAction(Action):\n    \"\"\"\n    Action used to capture pots using magnets.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, pot_supply_id: artifacts.PotSupplyID):\n        super().__init__(\"PotCapture action\", planner, actions)\n        self.before_action_func = self.before_action\n        self.pot_supply = self.game_context.pot_supplies[pot_supply_id]\n        self.shift_approach = 335\n        self.shift_forward = 160\n\n        match self.pot_supply.angle:\n            case -90:\n                self.approach_x = self.pot_supply.x\n                self.approach_y = -1500 + self.shift_approach\n                self.capture_x = self.approach_x\n                self.capture_y = self.approach_y - self.shift_forward\n            case 90:\n                self.approach_x = self.pot_supply.x\n                self.approach_y = 1500 - self.shift_approach\n                self.capture_x = self.approach_x\n                self.capture_y = self.approach_y + self.shift_forward\n            case 180:\n                self.approach_x = -1000 + self.shift_approach\n                self.approach_y = self.pot_supply.y\n                self.capture_x = self.approach_x - self.shift_forward\n                self.capture_y = self.approach_y\n\n    async def recycle(self):\n        await actuators.cart_magnet_off(self.planner)\n        await actuators.cart_in(self.planner)\n        self.pot_supply.enabled = True\n        self.recycled = True\n\n    async def before_action(self):\n        self.start_pose = self.planner.pose_current.model_copy()\n\n        pose = Pose(\n            x=self.approach_x,\n            y=self.approach_y,\n            O=self.pot_supply.angle,\n            max_speed_linear=66,\n            max_speed_angular=66,\n            allow_reverse=False,\n            before_pose_func=self.before_pose1,\n            after_pose_func=self.after_pose1,\n        )\n        self.poses.append(pose)\n\n        # Capture\n        pose = Pose(\n            x=self.capture_x,\n            y=self.capture_y,\n            O=self.pot_supply.angle,\n            max_speed_linear=5,\n            max_speed_angular=5,\n            allow_reverse=False,\n            bypass_anti_blocking=True,\n            timeout_ms=3000,\n            after_pose_func=self.after_pose2,\n        )\n        self.poses.append(pose)\n\n        # Step-back\n        pose = Pose(\n            x=self.approach_x,\n            y=self.approach_y,\n            O=self.pot_supply.angle,\n            max_speed_linear=10,\n            max_speed_angular=10,\n            allow_reverse=True,\n            after_pose_func=self.after_pose3,\n        )\n        self.poses.append(pose)\n\n    async def before_pose1(self):\n        await asyncio.gather(\n            actuators.bottom_grip_close(self.planner),\n            actuators.top_grip_close(self.planner),\n        )\n        await asyncio.gather(\n            actuators.top_lift_up(self.planner),\n            actuators.bottom_lift_up(self.planner),\n        )\n\n    async def after_pose1(self):\n        await actuators.cart_out(self.planner)\n        await actuators.cart_magnet_on(self.planner)\n\n        self.pot_supply.enabled = False\n\n    async def after_pose2(self):\n        await asyncio.sleep(1)\n\n    async def after_pose3(self):\n        self.pot_supply.enabled = True\n        self.pot_supply.count -= 2\n        if BoolSensorEnum.MAGNET_LEFT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state = True\n        if BoolSensorEnum.MAGNET_RIGHT in self.game_context.emulated_actuator_states:\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state = True\n\n    def weight(self) -&gt; float:\n        if self.pot_supply.count &lt; 5:\n            return 0\n        if not (\n            self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_LEFT].state\n            and self.game_context.bool_sensor_states[BoolSensorEnum.BOTTOM_GRIP_RIGHT].state\n        ):\n            return 0\n        if (\n            self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_LEFT].state\n            or self.game_context.bool_sensor_states[BoolSensorEnum.MAGNET_RIGHT].state\n        ):\n            return 0\n\n        return 2000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.PushPotAction","title":"<code>PushPotAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>push pot in front of a planter.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class PushPotAction(Action):\n    \"\"\"\n    push pot in front of a planter.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, pot_supply_id: artifacts.PotSupplyID):\n        super().__init__(\"PushPot action\", planner, actions)\n        self.pot_supply = self.game_context.pot_supplies[pot_supply_id]\n        self.after_action_func = self.after_action\n        self.half_robot_length = self.game_context.properties.robot_length / 2\n        margin_x = 160\n        margin_y = 50\n\n        match pot_supply_id:\n            case artifacts.PotSupplyID.LocalMiddle:\n                approach_x = self.pot_supply.x - margin_x - self.half_robot_length\n                approach_y = push_y = -1500 + margin_y + self.half_robot_length\n                approach_angle = push_angle = 180\n                push_x = approach_x + margin_x * 2 + 30\n            case artifacts.PotSupplyID.LocalTop:\n                approach_x = self.pot_supply.x + margin_x + self.half_robot_length\n                approach_y = push_y = -1500 + margin_y + self.half_robot_length\n                approach_angle = push_angle = 0\n                push_x = approach_x - margin_x * 2 - 30\n            case _:\n                logger.warning(f\"PushPot not available for pot supply {pot_supply_id}\")\n                return\n\n        self.poses.append(\n            AdaptedPose(\n                x=approach_x,\n                y=approach_y,\n                O=approach_angle,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=True,\n            )\n        )\n\n        self.poses.append(\n            AdaptedPose(\n                x=push_x,\n                y=push_y,\n                O=push_angle,\n                max_speed_linear=10,\n                max_speed_angular=10,\n                allow_reverse=True,\n                bypass_final_orientation=True,\n                before_pose_func=self.before_pose2,\n            )\n        )\n\n    async def before_pose2(self):\n        self.pot_supply.enabled = False\n\n    async def after_action(self):\n        self.pot_supply.count = 0\n\n    async def recycle(self):\n        if self.game_context.countdown &gt; 15:\n            self.pot_supply.enabled = True\n        self.recycled = True\n\n    def weight(self) -&gt; float:\n        return 9000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/base_actions/#cogip.tools.planner.actions.base_actions.SolarPanelsAction","title":"<code>SolarPanelsAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Activate a solar panel group.</p> Source code in <code>cogip/tools/planner/actions/base_actions.py</code> <pre><code>class SolarPanelsAction(Action):\n    \"\"\"\n    Activate a solar panel group.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, solar_panels_id: artifacts.SolarPanelsID):\n        super().__init__(\"SolarPanels action\", planner, actions)\n        self.solar_panels = self.game_context.solar_panels[solar_panels_id]\n        self.before_action_func = self.before_action\n        self.shift_x = -215\n        self.shift_y = 285\n\n    async def recycle(self):\n        await actuators.arm_panel_close(self.planner)\n        self.recycled = True\n\n    async def before_action(self):\n        self.start_pose = self.planner.pose_current.model_copy()\n        if self.game_context.camp.color == Camp.Colors.blue:\n            self.shift_y = -self.shift_y\n\n        if self.solar_panels.id == artifacts.SolarPanelsID.Shared:\n            self.game_context.pot_supplies[artifacts.PotSupplyID.LocalBottom].enabled = False\n            self.game_context.pot_supplies[artifacts.PotSupplyID.LocalBottom].count = 0\n            await asyncio.sleep(0.5)\n\n        # Start pose\n        self.pose1 = Pose(\n            x=self.solar_panels.x - self.shift_x,\n            y=self.solar_panels.y - self.shift_y,\n            O=90,\n            max_speed_linear=66,\n            max_speed_angular=66,\n            allow_reverse=True,\n            after_pose_func=self.after_pose1,\n        )\n\n        self.poses.append(self.pose1)\n\n        # End pose\n        self.poses.append(\n            Pose(\n                x=self.solar_panels.x - self.shift_x,\n                y=self.solar_panels.y + self.shift_y,\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                allow_reverse=True,\n                after_pose_func=self.after_pose2,\n            )\n        )\n\n        if self.solar_panels.id == artifacts.SolarPanelsID.Shared:\n            # Go back to pose1\n            self.poses.append(\n                Pose(\n                    x=self.pose1.x,\n                    y=self.pose1.y,\n                    O=self.pose1.O,\n                    max_speed_linear=66,\n                    max_speed_angular=66,\n                    allow_reverse=True,\n                )\n            )\n\n    async def after_pose1(self):\n        await actuators.arm_panel_open(self.planner)\n        await asyncio.sleep(1)\n\n    async def after_pose2(self):\n        await actuators.arm_panel_close(self.planner)\n        await asyncio.sleep(0.5)\n        self.game_context.score += 15\n\n    def weight(self) -&gt; float:\n        return 2000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/camera_calibration/","title":"camera_calibration","text":""},{"location":"reference/cogip/tools/planner/actions/camera_calibration/#cogip.tools.planner.actions.camera_calibration.CameraCalibrationAction","title":"<code>CameraCalibrationAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>This action moves around the front right table marker, and take pictures to compute camera extrinsic parameters (ie, the position of the camera relative to the robot center).</p> Source code in <code>cogip/tools/planner/actions/camera_calibration.py</code> <pre><code>class CameraCalibrationAction(Action):\n    \"\"\"\n    This action moves around the front right table marker, and take pictures to compute\n    camera extrinsic parameters (ie, the position of the camera relative to the robot center).\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"CameraCalibration action\", planner, actions)\n        self.camera_positions: list[Vertex] = []\n        self.after_action_func = self.print_camera_positions\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-(1500 - 450 + self.game_context.properties.robot_width / 2),\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-800,\n                O=160,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-220,\n                y=-540,\n                O=-160,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-260,\n                y=-320,\n                O=-130,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-500,\n                y=-320,\n                O=-90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-710,\n                y=-460,\n                O=-70,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-810,\n                y=-760,\n                O=0,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-(1000 - 450 + self.game_context.properties.robot_width / 2),\n                y=-(1500 - 450 + self.game_context.properties.robot_width / 2),\n                O=90,\n                max_speed_linear=66,\n                max_speed_angular=66,\n                after_pose_func=self.calibrate_camera,\n            )\n        )\n\n    async def calibrate_camera(self):\n        await asyncio.sleep(1)\n        if pose := await calibrate_camera(self.planner):\n            self.camera_positions.append(pose)\n        await asyncio.sleep(0.5)\n\n    async def print_camera_positions(self):\n        x = 0\n        y = 0\n        z = 0\n        for i, p in enumerate(self.camera_positions):\n            logger.info(f\"Camera position {i: 2d}: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\")\n            x += p.x\n            y += p.y\n            z += p.z\n\n        if n := len(self.camera_positions):\n            p = Vertex(x=x / n, y=y / n, z=z / n)\n            logger.info(f\"=&gt; Camera position mean: X={p.x:.0f} Y={p.y:.0f} Z={p.z:.0f}\")\n        else:\n            logger.warning(\"No camera position found\")\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/game_grip_first/","title":"game_grip_first","text":""},{"location":"reference/cogip/tools/planner/actions/game_solar_first/","title":"game_solar_first","text":""},{"location":"reference/cogip/tools/planner/actions/pami/","title":"pami","text":""},{"location":"reference/cogip/tools/planner/actions/position_test/","title":"position_test","text":""},{"location":"reference/cogip/tools/planner/actions/position_test/#cogip.tools.planner.actions.position_test.AngularPositionTestAction","title":"<code>AngularPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them rotate of 180\u00b0 in the same position. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/position_test.py</code> <pre><code>class AngularPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them rotate of 180\u00b0 in the same position.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"AngularPositionTest action\", planner, actions)\n        self.angular_distance = 180\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.allow_reverse = True\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n            max_speed_linear=self.linear_speed,\n            max_speed_angular=self.angular_speed,\n            allow_reverse=self.allow_reverse,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"O\": self.pose_start.O + self.angular_distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/position_test/#cogip.tools.planner.actions.position_test.LinearPositionTestAction","title":"<code>LinearPositionTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Action used to move the robot without table. First set start position on 0x0. Them move straight forward along 100 cm. Then go back to start position. Do it in loop.</p> Source code in <code>cogip/tools/planner/actions/position_test.py</code> <pre><code>class LinearPositionTestAction(Action):\n    \"\"\"\n    Action used to move the robot without table.\n    First set start position on 0x0.\n    Them move straight forward along 100 cm.\n    Then go back to start position.\n    Do it in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"LinearPositionTest action\", planner, actions)\n        self.distance = 750\n        self.linear_speed = 66\n        self.angular_speed = 66\n        self.allow_reverse = True\n        self.before_action_func = self.init_start_position\n        self.pose_init = models.Pose(\n            x=-500,\n            y=-300,\n            O=-90,\n            max_speed_linear=self.linear_speed,\n            max_speed_angular=self.angular_speed,\n            allow_reverse=self.allow_reverse,\n        )\n        self.pose_start = Pose(**self.pose_init.model_dump())\n        self.pose_start.after_pose_func = partial(self.append_pose, self.pose_start)\n        self.pose_end = self.pose_start.model_copy(update={\"y\": self.pose_start.y - self.distance})\n        self.pose_end.after_pose_func = partial(self.append_pose, self.pose_end)\n        self.poses.append(self.pose_end)\n        self.poses.append(self.pose_start)\n\n    async def init_start_position(self):\n        await self.planner.set_pose_start(self.pose_init)\n        self.planner.pose_reached = False\n        self.planner.action = self\n\n    async def append_pose(self, pose: Pose) -&gt; None:\n        self.poses.append(pose)\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/solar_panels/","title":"solar_panels","text":""},{"location":"reference/cogip/tools/planner/actions/solar_panels/#cogip.tools.planner.actions.solar_panels.DiscoverSolarPanelsAction","title":"<code>DiscoverSolarPanelsAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Use the camera to find orientation of solar panels.</p> Source code in <code>cogip/tools/planner/actions/solar_panels.py</code> <pre><code>class DiscoverSolarPanelsAction(Action):\n    \"\"\"\n    Use the camera to find orientation of solar panels.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"DiscoverSolarPanel action\", planner, actions)\n        self.poses.append(\n            Pose(\n                x=-500,\n                y=-1000,\n                O=180,\n                max_speed_linear=33,\n                max_speed_angular=33,\n                after_pose_func=self.get_solar_panels,\n            )\n        )\n\n    async def get_solar_panels(self):\n        await asyncio.sleep(2)\n        solar_panels = await get_solar_panels(self.planner)\n        for panel_id, angle in solar_panels.items():\n            # Angle are given for yellow camp only\n            log_prefix = f\"Solar panel {panel_id}: angle={angle}\"\n            match angle:\n                case angle if -5 &lt;= angle &lt; 20:\n                    logger.info(f\"{log_prefix}, need activation\")\n                    self.actions.append(SolarPanelAction(self.planner, self.actions, panel_id, angle))\n                case angle if 20 &lt;= angle &lt;= 180:\n                    logger.info(f\"{log_prefix}, already activated\")\n                case angle if -179 &lt;= angle &lt;= -160:\n                    logger.info(f\"{log_prefix}, already activated\")\n                case _:\n                    logger.info(f\"{log_prefix}, cannot be activated\")\n\n    def weight(self) -&gt; float:\n        return 900000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/solar_panels/#cogip.tools.planner.actions.solar_panels.SetRobotPositionAction","title":"<code>SetRobotPositionAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Use the camera and a table Aruco marker to find the current robot position.</p> Source code in <code>cogip/tools/planner/actions/solar_panels.py</code> <pre><code>class SetRobotPositionAction(Action):\n    \"\"\"\n    Use the camera and a table Aruco marker to find the current robot position.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"SetRobotPosition action\", planner, actions)\n        self.after_action_func = self.get_position\n\n    async def get_position(self):\n        await actuators.arm_panel_close(self.planner)\n\n        pose = await get_robot_position(self.planner)\n        if not pose:\n            logger.error(\"Cannot find table marker and current robot position\")\n            return\n\n        await self.planner.set_pose_start(pose)\n        self.planner.pose_reached = False\n\n        self.actions.append(DiscoverSolarPanelsAction(self.planner, self.actions))\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/solar_panels/#cogip.tools.planner.actions.solar_panels.SolarPanelAction","title":"<code>SolarPanelAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Activate a solar panel.</p> Source code in <code>cogip/tools/planner/actions/solar_panels.py</code> <pre><code>class SolarPanelAction(Action):\n    \"\"\"\n    Activate a solar panel.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions, panel_id: int, angle: float):\n        super().__init__(\"SolarPanelAction action\", planner, actions)\n        self.panel_id = panel_id\n        self.angle = angle\n        solar_panel = solar_panels_positions[panel_id]\n\n        robot_y = solar_panel.y - 30\n\n        self.poses.append(\n            Pose(\n                x=-750,\n                y=robot_y,\n                O=180,\n                max_speed_linear=33,\n                max_speed_angular=33,\n                after_pose_func=self.extend_arm,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-1000 + self.game_context.properties.robot_width / 2 + 20,\n                y=robot_y,\n                O=180,\n                max_speed_linear=33,\n                max_speed_angular=33,\n                allow_reverse=False,\n            )\n        )\n\n        self.poses.append(\n            Pose(\n                x=-750,\n                y=robot_y,\n                O=180,\n                max_speed_linear=33,\n                max_speed_angular=33,\n                after_pose_func=self.fold_arm,\n            )\n        )\n\n    async def extend_arm(self):\n        await actuators.arm_panel_open(self.planner)\n\n    async def fold_arm(self):\n        await actuators.arm_panel_close(self.planner)\n\n    def weight(self) -&gt; float:\n        return 800000.0 + self.panel_id\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/speed_test/","title":"speed_test","text":""},{"location":"reference/cogip/tools/planner/actions/speed_test/#cogip.tools.planner.actions.speed_test.SpeedTestAction","title":"<code>SpeedTestAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Dummy action for pid calibration. Same dummy pose in loop.</p> Source code in <code>cogip/tools/planner/actions/speed_test.py</code> <pre><code>class SpeedTestAction(Action):\n    \"\"\"\n    Dummy action for pid calibration.\n    Same dummy pose in loop.\n    \"\"\"\n\n    def __init__(self, planner: \"Planner\", actions: Actions):\n        super().__init__(\"Pid calibration action\", planner, actions)\n        self.pose = Pose()\n        self.pose.after_pose_func = self.after_pose\n        self.poses = [self.pose]\n\n    def weight(self) -&gt; float:\n        return 1000000.0\n\n    async def after_pose(self):\n        self.poses.append(self.pose)\n</code></pre>"},{"location":"reference/cogip/tools/planner/actions/test_align/","title":"test_align","text":""},{"location":"reference/cogip/tools/planner/actions/test_dropoff/","title":"test_dropoff","text":""},{"location":"reference/cogip/tools/planner/actions/test_grip/","title":"test_grip","text":""},{"location":"reference/cogip/tools/planner/actions/test_planters/","title":"test_planters","text":""},{"location":"reference/cogip/tools/planner/actions/test_pot_capture/","title":"test_pot_capture","text":""},{"location":"reference/cogip/tools/planner/actions/test_solar_panels/","title":"test_solar_panels","text":""},{"location":"reference/cogip/tools/planner/avoidance/avoidance/","title":"avoidance","text":""},{"location":"reference/cogip/tools/planner/avoidance/debug/","title":"debug","text":""},{"location":"reference/cogip/tools/planner/avoidance/debug/#cogip.tools.planner.avoidance.debug.DebugWindow","title":"<code>DebugWindow</code>","text":"Source code in <code>cogip/tools/planner/avoidance/debug.py</code> <pre><code>class DebugWindow:\n    ui_thread: threading.Thread | None = None\n\n    def __init__(self):\n        self.app = None\n        if DebugWindow.ui_thread is None:\n            DebugWindow.ui_thread = threading.Thread(target=self.start_qapp)\n            DebugWindow.ui_thread.start()\n            time.sleep(0.05)  # Wait for a short time to ensure QApplication instance created.\n\n        self.point_start: models.Pose | None = None\n        self.point_goal: models.Pose | None = None\n\n        self.fixed_obstacles: list[visibility_road_map.ObstaclePolygon] = []\n        self.dyn_obstacles: list[visibility_road_map.ObstaclePolygon] = []\n\n        self.visibility_nodes: list[tuple[float, float]] = []\n        self.graph: list[tuple[float, float]] = []\n        self.road_map: list[tuple[float, float, float, float]] = []\n        self.path: list[tuple[float, float]] = []\n\n        self.win = MainWindow(self)\n        self.win.show()\n\n    def start_qapp(self):\n        \"\"\"a thread for QApplication event loop\"\"\"\n        self.app = QtWidgets.QApplication(sys.argv)\n        self.app.exec_()\n\n    def update(self):\n        self.win.repaint()\n\n    def reset(self):\n        self.point_start = None\n        self.point_goal = None\n        self.dyn_obstacles.clear()\n        self.visibility_nodes.clear()\n        self.graph.clear()\n        self.road_map.clear()\n        self.path.clear()\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/debug/#cogip.tools.planner.avoidance.debug.DebugWindow.start_qapp","title":"<code>start_qapp()</code>","text":"<p>a thread for QApplication event loop</p> Source code in <code>cogip/tools/planner/avoidance/debug.py</code> <pre><code>def start_qapp(self):\n    \"\"\"a thread for QApplication event loop\"\"\"\n    self.app = QtWidgets.QApplication(sys.argv)\n    self.app.exec_()\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/process/","title":"process","text":""},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search/","title":"dijkstra_search","text":"<p>Dijkstra Search library</p> <p>author: Atsushi Sakai (@Atsushi_twi)</p>"},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search/#cogip.tools.planner.avoidance.visibility_road_map.dijkstra_search.DijkstraSearch","title":"<code>DijkstraSearch</code>","text":"Source code in <code>cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search.py</code> <pre><code>class DijkstraSearch:\n    class Node:\n        \"\"\"\n        Node class for dijkstra search\n        \"\"\"\n\n        def __init__(self, x, y, cost=None, parent=None, edge_ids=None):\n            self.x = x\n            self.y = y\n            self.cost = cost\n            self.parent = parent\n            self.edge_ids = edge_ids\n\n        def __str__(self):\n            return str(self.x) + \",\" + str(self.y) + \",\" + str(self.cost) + \",\" + str(self.parent)\n\n    def __init__(self, win: DebugWindow | None = None):\n        self.win = win\n\n    def search(self, sx, sy, gx, gy, node_x, node_y, edge_ids_list):\n        \"\"\"\n        Search shortest path\n\n        s_x: start x positions [m]\n        s_y: start y positions [m]\n        gx: goal x position [m]\n        gx: goal x position [m]\n        node_x: node x position\n        node_y: node y position\n        edge_ids_list: edge_list each item includes a list of edge ids\n        \"\"\"\n\n        start_node = self.Node(sx, sy, 0.0, -1)\n        goal_node = self.Node(gx, gy, 0.0, -1)\n        current_node = None\n\n        open_set, close_set = dict(), dict()\n        open_set[self.find_id(node_x, node_y, start_node)] = start_node\n\n        while True:\n            if self.has_node_in_set(close_set, goal_node):\n                # print(\"goal is found!\")\n                goal_node.parent = current_node.parent\n                goal_node.cost = current_node.cost\n                break\n            elif not open_set:\n                # print(\"Cannot find path\")\n                break\n\n            current_id = min(open_set, key=lambda o: open_set[o].cost)\n            current_node = open_set[current_id]\n\n            if self.win:\n                # show graph\n                if len(close_set.keys()) % 2 == 0:\n                    self.win.graph.append((current_node.x, current_node.y))\n\n            # Remove the item from the open set\n            del open_set[current_id]\n            # Add it to the closed set\n            close_set[current_id] = current_node\n\n            # expand search grid based on motion model\n            for i in range(len(edge_ids_list[current_id])):\n                n_id = edge_ids_list[current_id][i]\n                dx = node_x[n_id] - current_node.x\n                dy = node_y[n_id] - current_node.y\n                d = math.hypot(dx, dy)\n                node = self.Node(node_x[n_id], node_y[n_id], current_node.cost + d, current_id)\n\n                if n_id in close_set:\n                    continue\n                # Otherwise if it is already in the open set\n                if n_id in open_set:\n                    if open_set[n_id].cost &gt; node.cost:\n                        open_set[n_id] = node\n                else:\n                    open_set[n_id] = node\n\n        # generate final course\n        rx, ry = self.generate_final_path(close_set, goal_node)\n\n        return rx, ry\n\n    @staticmethod\n    def generate_final_path(close_set, goal_node):\n        rx, ry = [goal_node.x], [goal_node.y]\n        parent = goal_node.parent\n        while parent != -1:\n            n = close_set[parent]\n            rx.append(n.x)\n            ry.append(n.y)\n            parent = n.parent\n        rx, ry = rx[::-1], ry[::-1]  # reverse it\n        return rx, ry\n\n    def has_node_in_set(self, target_set, node):\n        for key in target_set:\n            if self.is_same_node(target_set[key], node):\n                return True\n        return False\n\n    def find_id(self, node_x_list, node_y_list, target_node):\n        for i, _ in enumerate(node_x_list):\n            if self.is_same_node_with_xy(node_x_list[i], node_y_list[i], target_node):\n                return i\n        return None\n\n    @staticmethod\n    def is_same_node_with_xy(node_x, node_y, node_b):\n        dist = np.hypot(node_x - node_b.x, node_y - node_b.y)\n        return dist &lt;= 0.1\n\n    @staticmethod\n    def is_same_node(node_a, node_b):\n        dist = np.hypot(node_a.x - node_b.x, node_a.y - node_b.y)\n        return dist &lt;= 0.1\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search/#cogip.tools.planner.avoidance.visibility_road_map.dijkstra_search.DijkstraSearch.Node","title":"<code>Node</code>","text":"<p>Node class for dijkstra search</p> Source code in <code>cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search.py</code> <pre><code>class Node:\n    \"\"\"\n    Node class for dijkstra search\n    \"\"\"\n\n    def __init__(self, x, y, cost=None, parent=None, edge_ids=None):\n        self.x = x\n        self.y = y\n        self.cost = cost\n        self.parent = parent\n        self.edge_ids = edge_ids\n\n    def __str__(self):\n        return str(self.x) + \",\" + str(self.y) + \",\" + str(self.cost) + \",\" + str(self.parent)\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search/#cogip.tools.planner.avoidance.visibility_road_map.dijkstra_search.DijkstraSearch.search","title":"<code>search(sx, sy, gx, gy, node_x, node_y, edge_ids_list)</code>","text":"<p>Search shortest path</p> <p>s_x: start x positions [m] s_y: start y positions [m] gx: goal x position [m] gx: goal x position [m] node_x: node x position node_y: node y position edge_ids_list: edge_list each item includes a list of edge ids</p> Source code in <code>cogip/tools/planner/avoidance/visibility_road_map/dijkstra_search.py</code> <pre><code>def search(self, sx, sy, gx, gy, node_x, node_y, edge_ids_list):\n    \"\"\"\n    Search shortest path\n\n    s_x: start x positions [m]\n    s_y: start y positions [m]\n    gx: goal x position [m]\n    gx: goal x position [m]\n    node_x: node x position\n    node_y: node y position\n    edge_ids_list: edge_list each item includes a list of edge ids\n    \"\"\"\n\n    start_node = self.Node(sx, sy, 0.0, -1)\n    goal_node = self.Node(gx, gy, 0.0, -1)\n    current_node = None\n\n    open_set, close_set = dict(), dict()\n    open_set[self.find_id(node_x, node_y, start_node)] = start_node\n\n    while True:\n        if self.has_node_in_set(close_set, goal_node):\n            # print(\"goal is found!\")\n            goal_node.parent = current_node.parent\n            goal_node.cost = current_node.cost\n            break\n        elif not open_set:\n            # print(\"Cannot find path\")\n            break\n\n        current_id = min(open_set, key=lambda o: open_set[o].cost)\n        current_node = open_set[current_id]\n\n        if self.win:\n            # show graph\n            if len(close_set.keys()) % 2 == 0:\n                self.win.graph.append((current_node.x, current_node.y))\n\n        # Remove the item from the open set\n        del open_set[current_id]\n        # Add it to the closed set\n        close_set[current_id] = current_node\n\n        # expand search grid based on motion model\n        for i in range(len(edge_ids_list[current_id])):\n            n_id = edge_ids_list[current_id][i]\n            dx = node_x[n_id] - current_node.x\n            dy = node_y[n_id] - current_node.y\n            d = math.hypot(dx, dy)\n            node = self.Node(node_x[n_id], node_y[n_id], current_node.cost + d, current_id)\n\n            if n_id in close_set:\n                continue\n            # Otherwise if it is already in the open set\n            if n_id in open_set:\n                if open_set[n_id].cost &gt; node.cost:\n                    open_set[n_id] = node\n            else:\n                open_set[n_id] = node\n\n    # generate final course\n    rx, ry = self.generate_final_path(close_set, goal_node)\n\n    return rx, ry\n</code></pre>"},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/geometry/","title":"geometry","text":""},{"location":"reference/cogip/tools/planner/avoidance/visibility_road_map/visibility_road_map/","title":"visibility_road_map","text":"<p>Visibility Road Map Planner</p> <p>author: Atsushi Sakai (@Atsushi_twi)</p>"},{"location":"reference/cogip/tools/replay/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/replay/main/","title":"main","text":""},{"location":"reference/cogip/tools/replay/main/#cogip.tools.replay.main.main","title":"<code>main()</code>","text":"<p>Starts the replay viewer.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>replay</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/replay/main.py</code> <pre><code>def main():\n    \"\"\"\n    Starts the replay viewer.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `replay` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/replay/main/#cogip.tools.replay.main.main_opt","title":"<code>main_opt(trace_file=typer.Argument(None))</code>","text":"<p>Starts replay.</p> Source code in <code>cogip/tools/replay/main.py</code> <pre><code>def main_opt(trace_file: Optional[Path] = typer.Argument(None)):  # noqa\n    \"\"\"\n    Starts replay.\n    \"\"\"\n\n    if trace_file and not trace_file.is_file():\n        logger.error(f\"Error: '{trace_file}' is not a file or does not exist.\")\n        sys.exit(1)\n\n    # Create QApplication\n    app = QtWidgets.QApplication(sys.argv)\n\n    # Create UI\n    win = MainWindow(trace_file)\n\n    # Create table entity\n    table_entity = TableEntity(win.game_view.scene_entity)\n    win.game_view.add_asset(table_entity)\n\n    # Create robot entity\n    robot_entity = RobotEntity()\n    win.game_view.add_asset(robot_entity)\n\n    # Connect UI signals\n    win.signal_new_robot_state.connect(robot_entity.new_robot_state)\n    win.signal_new_robot_state.connect(win.game_view.new_robot_state)\n    win.signal_new_robot_state.connect(win.new_robot_state)\n    win.signal_new_robot_state.connect(win.charts_view.new_robot_state)\n\n    if trace_file:\n        win.load_trace(trace_file)\n\n    # Show UI\n    win.show()\n    # win.showFullScreen()\n    win.raise_()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/","title":"mainwindow","text":""},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow","title":"<code>MainWindow</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>MainWindow class</p> <p>Build the main window of the game replay tool.</p> <p>It contains:</p> <ul> <li>a menu bar,</li> <li>a tool bar with buttons to load a trace file,</li> <li>a status bar with robot position,</li> <li>a slider with buttons to start/stop playback</li> </ul> <p>Attributes:</p> Name Type Description <code>signal_new_robot_state</code> <code>Signal</code> <p>Qt signal emitted on robot state update</p> <code>rate</code> <code>int</code> <p>number of milliseconds between two states during automatic playback</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>class MainWindow(QtWidgets.QMainWindow):\n    \"\"\"MainWindow class\n\n    Build the main window of the game replay tool.\n\n    It contains:\n\n      - a menu bar,\n      - a tool bar with buttons to load a trace file,\n      - a status bar with robot position,\n      - a slider with buttons to start/stop playback\n\n    Attributes:\n        signal_new_robot_state: Qt signal emitted on robot state update\n        rate: number of milliseconds between two states during automatic playback\n    \"\"\"\n\n    signal_new_robot_state: qtSignal = qtSignal(RobotState)\n    rate: int = 60\n\n    def __init__(self, trace: Path | None = None, *args, **kwargs):\n        \"\"\" \"\"\"\n        super().__init__(*args, **kwargs)\n        self.states = []\n        self.timer = QtCore.QTimer()\n        self.timer.timeout.connect(self.increment)\n\n        self.menu_widgets: dict[str, QtWidgets.QWidget] = {}\n\n        self.setWindowTitle(\"COGIP Replay\")\n\n        self.central_widget = QtWidgets.QWidget()\n        self.central_layout = QtWidgets.QVBoxLayout()\n        self.central_widget.setLayout(self.central_layout)\n        self.setCentralWidget(self.central_widget)\n\n        # Menu bar\n        menubar = self.menuBar()\n        file_menu = menubar.addMenu(\"&amp;File\")\n        view_menu = menubar.addMenu(\"&amp;View\")\n\n        # Toolbars\n        file_toolbar = self.addToolBar(\"File\")\n\n        # Status bar\n        status_bar = self.statusBar()\n\n        cycle_label = QtWidgets.QLabel(\"Cycle:\")\n        self.cycle_text = QtWidgets.QLabel()\n        self.cycle_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        self.cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        status_bar.addPermanentWidget(cycle_label, 0)\n        status_bar.addPermanentWidget(self.cycle_text, 0)\n\n        pos_x_label = QtWidgets.QLabel(\"X:\")\n        self.pos_x_text = QtWidgets.QLabel()\n        self.pos_x_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        self.pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        status_bar.addPermanentWidget(pos_x_label, 0)\n        status_bar.addPermanentWidget(self.pos_x_text, 0)\n\n        pos_y_label = QtWidgets.QLabel(\"Y:\")\n        self.pos_y_text = QtWidgets.QLabel()\n        self.pos_y_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        self.pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        status_bar.addPermanentWidget(pos_y_label, 0)\n        status_bar.addPermanentWidget(self.pos_y_text, 0)\n\n        pos_angle_label = QtWidgets.QLabel(\"Angle:\")\n        self.pos_angle_text = QtWidgets.QLabel()\n        self.pos_angle_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n        self.pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n        status_bar.addPermanentWidget(pos_angle_label, 0)\n        status_bar.addPermanentWidget(self.pos_angle_text, 0)\n\n        # Actions\n        # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n        # Exit action\n        self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n        self.exit_action.setShortcut(\"Ctrl+Q\")\n        self.exit_action.setStatusTip(\"Exit application\")\n        self.exit_action.triggered.connect(self.close)\n        file_menu.addAction(self.exit_action)\n        file_toolbar.addAction(self.exit_action)\n\n        # Add obstacle action\n        self.open_trace_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Open trace\", self)\n        self.open_trace_action.setShortcut(\"Ctrl+O\")\n        self.open_trace_action.setStatusTip(\"Open trace\")\n        self.open_trace_action.triggered.connect(self.open_trace)\n        file_menu.addAction(self.open_trace_action)\n        file_toolbar.addAction(self.open_trace_action)\n\n        # GameView widget\n        self.game_view = GameView()\n        self.central_layout.addWidget(self.game_view, stretch=100)\n\n        # Slider widget\n        slider_widget = QtWidgets.QWidget()\n        slider_layout = QtWidgets.QHBoxLayout(slider_widget)\n        slider_widget.setLayout(slider_layout)\n        self.central_layout.addWidget(slider_widget, stretch=1)\n\n        self.play_button = QtWidgets.QPushButton()\n        self.play_button.setIcon(QtGui.QIcon.fromTheme(\"media-playback-start\"))\n        self.play_button.setStatusTip(\"Play\")\n        self.play_button.setEnabled(False)\n        self.play_button.clicked.connect(self.play)\n        slider_layout.addWidget(self.play_button)\n\n        self.pause_button = QtWidgets.QPushButton()\n        self.pause_button.setIcon(QtGui.QIcon.fromTheme(\"media-playback-pause\"))\n        self.pause_button.setStatusTip(\"Pause\")\n        self.pause_button.setEnabled(False)\n        self.pause_button.clicked.connect(self.pause)\n        slider_layout.addWidget(self.pause_button)\n\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=00)\n        self.slider.setMinimum(0)\n        self.slider.setValue(0)\n        self.slider.setEnabled(False)\n        self.slider.valueChanged.connect(self.slider_changed)\n        self.slider.sliderMoved.connect(self.slider_moved)\n        slider_layout.addWidget(self.slider)\n\n        # Charts widget\n        self.charts_view = ChartsView(self)\n\n        # Add view action\n        self.view_charts_action = QtGui.QAction(\"Calibration Charts\", self)\n        self.view_charts_action.setStatusTip(\"Display/Hide calibration charts\")\n        self.view_charts_action.setCheckable(True)\n        self.view_charts_action.toggled.connect(self.charts_toggled)\n        self.charts_view.closed.connect(partial(self.view_charts_action.setChecked, False))\n        view_menu.addAction(self.view_charts_action)\n\n    @qtSlot(bool)\n    def charts_toggled(self, checked: bool):\n        \"\"\"\n        Qt Slot\n\n        Show/hide the calibration charts.\n\n        Arguments:\n            checked: Show action has checked or unchecked\n        \"\"\"\n        if checked:\n            self.charts_view.show()\n            self.charts_view.raise_()\n            self.charts_view.activateWindow()\n        else:\n            self.charts_view.close()\n\n    @qtSlot(RobotState)\n    def new_robot_state(self, state: RobotState):\n        \"\"\"\n        Qt Slot\n\n        Update robot position information in the status bar.\n\n        Arguments:\n            state: Robot state\n        \"\"\"\n        self.cycle_text.setText(f\"{state.cycle or 0:&gt;#6d}\")\n        self.pos_x_text.setText(f\"{state.pose_current.x:&gt; #6.2f}\")\n        self.pos_y_text.setText(f\"{state.pose_current.y:&gt; #6.2f}\")\n        self.pos_angle_text.setText(f\"{state.pose_current.O:&gt; #4.2f}\")\n\n    @qtSlot()\n    def open_trace(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a trace file.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n            parent=self,\n            caption=\"Select file to load trace\",\n            dir=\"\",\n            filter=\"Text files (*.txt)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            self.load_trace(Path(filename))\n\n    @qtSlot()\n    def load_trace(self, trace_file: Path):\n        \"\"\"\n        Qt Slot\n\n        Load a trace file.\n        \"\"\"\n        self.pause()\n        with trace_file.open() as fd:\n            lines = fd.readlines()\n        self.states = [RobotState.model_validate_json(line) for line in lines]\n        self.slider.setValue(0)\n        self.slider.setMaximum(len(self.states) - 1)\n        self.slider.setEnabled(True)\n        self.slider_changed()\n\n    @qtSlot()\n    def play(self):\n        \"\"\"\n        Qt Slot\n\n        Start automatic playback.\n        \"\"\"\n        self.play_button.setEnabled(False)\n        self.pause_button.setEnabled(True)\n        self.timer.start(self.rate)\n\n    @qtSlot()\n    def pause(self):\n        \"\"\"\n        Qt Slot\n\n        Stop automatic playback.\n        \"\"\"\n        self.timer.stop()\n        self.play_button.setEnabled(True)\n        self.pause_button.setEnabled(False)\n\n    @qtSlot()\n    def slider_changed(self):\n        \"\"\"\n        Qt Slot\n\n        Send robot state update when the current index changes,\n        ie when the slider moves, automatically or manually\n        \"\"\"\n        self.signal_new_robot_state.emit(self.states[self.slider.value()])\n\n    @qtSlot()\n    def slider_moved(self):\n        \"\"\"\n        Qt Slot\n\n        Stop automatic playback when the slider is moved manually.\n        \"\"\"\n        self.pause()\n\n    def increment(self):\n        \"\"\"\n        Jump to the next state.\n        \"\"\"\n        self.slider.setValue(self.slider.value() + 1)\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.__init__","title":"<code>__init__(trace=None, *args, **kwargs)</code>","text":"Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>def __init__(self, trace: Path | None = None, *args, **kwargs):\n    \"\"\" \"\"\"\n    super().__init__(*args, **kwargs)\n    self.states = []\n    self.timer = QtCore.QTimer()\n    self.timer.timeout.connect(self.increment)\n\n    self.menu_widgets: dict[str, QtWidgets.QWidget] = {}\n\n    self.setWindowTitle(\"COGIP Replay\")\n\n    self.central_widget = QtWidgets.QWidget()\n    self.central_layout = QtWidgets.QVBoxLayout()\n    self.central_widget.setLayout(self.central_layout)\n    self.setCentralWidget(self.central_widget)\n\n    # Menu bar\n    menubar = self.menuBar()\n    file_menu = menubar.addMenu(\"&amp;File\")\n    view_menu = menubar.addMenu(\"&amp;View\")\n\n    # Toolbars\n    file_toolbar = self.addToolBar(\"File\")\n\n    # Status bar\n    status_bar = self.statusBar()\n\n    cycle_label = QtWidgets.QLabel(\"Cycle:\")\n    self.cycle_text = QtWidgets.QLabel()\n    self.cycle_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    self.cycle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    status_bar.addPermanentWidget(cycle_label, 0)\n    status_bar.addPermanentWidget(self.cycle_text, 0)\n\n    pos_x_label = QtWidgets.QLabel(\"X:\")\n    self.pos_x_text = QtWidgets.QLabel()\n    self.pos_x_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    self.pos_x_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    status_bar.addPermanentWidget(pos_x_label, 0)\n    status_bar.addPermanentWidget(self.pos_x_text, 0)\n\n    pos_y_label = QtWidgets.QLabel(\"Y:\")\n    self.pos_y_text = QtWidgets.QLabel()\n    self.pos_y_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    self.pos_y_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    status_bar.addPermanentWidget(pos_y_label, 0)\n    status_bar.addPermanentWidget(self.pos_y_text, 0)\n\n    pos_angle_label = QtWidgets.QLabel(\"Angle:\")\n    self.pos_angle_text = QtWidgets.QLabel()\n    self.pos_angle_text.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)\n    self.pos_angle_text.setFrameStyle(QtWidgets.QFrame.Panel | QtWidgets.QFrame.Sunken)\n    status_bar.addPermanentWidget(pos_angle_label, 0)\n    status_bar.addPermanentWidget(self.pos_angle_text, 0)\n\n    # Actions\n    # Icons: https://commons.wikimedia.org/wiki/GNOME_Desktop_icons\n\n    # Exit action\n    self.exit_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"application-exit\"), \"Exit\", self)\n    self.exit_action.setShortcut(\"Ctrl+Q\")\n    self.exit_action.setStatusTip(\"Exit application\")\n    self.exit_action.triggered.connect(self.close)\n    file_menu.addAction(self.exit_action)\n    file_toolbar.addAction(self.exit_action)\n\n    # Add obstacle action\n    self.open_trace_action = QtGui.QAction(QtGui.QIcon.fromTheme(\"document-open\"), \"Open trace\", self)\n    self.open_trace_action.setShortcut(\"Ctrl+O\")\n    self.open_trace_action.setStatusTip(\"Open trace\")\n    self.open_trace_action.triggered.connect(self.open_trace)\n    file_menu.addAction(self.open_trace_action)\n    file_toolbar.addAction(self.open_trace_action)\n\n    # GameView widget\n    self.game_view = GameView()\n    self.central_layout.addWidget(self.game_view, stretch=100)\n\n    # Slider widget\n    slider_widget = QtWidgets.QWidget()\n    slider_layout = QtWidgets.QHBoxLayout(slider_widget)\n    slider_widget.setLayout(slider_layout)\n    self.central_layout.addWidget(slider_widget, stretch=1)\n\n    self.play_button = QtWidgets.QPushButton()\n    self.play_button.setIcon(QtGui.QIcon.fromTheme(\"media-playback-start\"))\n    self.play_button.setStatusTip(\"Play\")\n    self.play_button.setEnabled(False)\n    self.play_button.clicked.connect(self.play)\n    slider_layout.addWidget(self.play_button)\n\n    self.pause_button = QtWidgets.QPushButton()\n    self.pause_button.setIcon(QtGui.QIcon.fromTheme(\"media-playback-pause\"))\n    self.pause_button.setStatusTip(\"Pause\")\n    self.pause_button.setEnabled(False)\n    self.pause_button.clicked.connect(self.pause)\n    slider_layout.addWidget(self.pause_button)\n\n    self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=00)\n    self.slider.setMinimum(0)\n    self.slider.setValue(0)\n    self.slider.setEnabled(False)\n    self.slider.valueChanged.connect(self.slider_changed)\n    self.slider.sliderMoved.connect(self.slider_moved)\n    slider_layout.addWidget(self.slider)\n\n    # Charts widget\n    self.charts_view = ChartsView(self)\n\n    # Add view action\n    self.view_charts_action = QtGui.QAction(\"Calibration Charts\", self)\n    self.view_charts_action.setStatusTip(\"Display/Hide calibration charts\")\n    self.view_charts_action.setCheckable(True)\n    self.view_charts_action.toggled.connect(self.charts_toggled)\n    self.charts_view.closed.connect(partial(self.view_charts_action.setChecked, False))\n    view_menu.addAction(self.view_charts_action)\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.charts_toggled","title":"<code>charts_toggled(checked)</code>","text":"<p>Qt Slot</p> <p>Show/hide the calibration charts.</p> <p>Parameters:</p> Name Type Description Default <code>checked</code> <code>bool</code> <p>Show action has checked or unchecked</p> required Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot(bool)\ndef charts_toggled(self, checked: bool):\n    \"\"\"\n    Qt Slot\n\n    Show/hide the calibration charts.\n\n    Arguments:\n        checked: Show action has checked or unchecked\n    \"\"\"\n    if checked:\n        self.charts_view.show()\n        self.charts_view.raise_()\n        self.charts_view.activateWindow()\n    else:\n        self.charts_view.close()\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.increment","title":"<code>increment()</code>","text":"<p>Jump to the next state.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>def increment(self):\n    \"\"\"\n    Jump to the next state.\n    \"\"\"\n    self.slider.setValue(self.slider.value() + 1)\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.load_trace","title":"<code>load_trace(trace_file)</code>","text":"<p>Qt Slot</p> <p>Load a trace file.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef load_trace(self, trace_file: Path):\n    \"\"\"\n    Qt Slot\n\n    Load a trace file.\n    \"\"\"\n    self.pause()\n    with trace_file.open() as fd:\n        lines = fd.readlines()\n    self.states = [RobotState.model_validate_json(line) for line in lines]\n    self.slider.setValue(0)\n    self.slider.setMaximum(len(self.states) - 1)\n    self.slider.setEnabled(True)\n    self.slider_changed()\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.new_robot_state","title":"<code>new_robot_state(state)</code>","text":"<p>Qt Slot</p> <p>Update robot position information in the status bar.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RobotState</code> <p>Robot state</p> required Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot(RobotState)\ndef new_robot_state(self, state: RobotState):\n    \"\"\"\n    Qt Slot\n\n    Update robot position information in the status bar.\n\n    Arguments:\n        state: Robot state\n    \"\"\"\n    self.cycle_text.setText(f\"{state.cycle or 0:&gt;#6d}\")\n    self.pos_x_text.setText(f\"{state.pose_current.x:&gt; #6.2f}\")\n    self.pos_y_text.setText(f\"{state.pose_current.y:&gt; #6.2f}\")\n    self.pos_angle_text.setText(f\"{state.pose_current.O:&gt; #4.2f}\")\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.open_trace","title":"<code>open_trace()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a trace file.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef open_trace(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a trace file.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getOpenFileName(\n        parent=self,\n        caption=\"Select file to load trace\",\n        dir=\"\",\n        filter=\"Text files (*.txt)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        self.load_trace(Path(filename))\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.pause","title":"<code>pause()</code>","text":"<p>Qt Slot</p> <p>Stop automatic playback.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef pause(self):\n    \"\"\"\n    Qt Slot\n\n    Stop automatic playback.\n    \"\"\"\n    self.timer.stop()\n    self.play_button.setEnabled(True)\n    self.pause_button.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.play","title":"<code>play()</code>","text":"<p>Qt Slot</p> <p>Start automatic playback.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef play(self):\n    \"\"\"\n    Qt Slot\n\n    Start automatic playback.\n    \"\"\"\n    self.play_button.setEnabled(False)\n    self.pause_button.setEnabled(True)\n    self.timer.start(self.rate)\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.slider_changed","title":"<code>slider_changed()</code>","text":"<p>Qt Slot</p> <p>Send robot state update when the current index changes, ie when the slider moves, automatically or manually</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef slider_changed(self):\n    \"\"\"\n    Qt Slot\n\n    Send robot state update when the current index changes,\n    ie when the slider moves, automatically or manually\n    \"\"\"\n    self.signal_new_robot_state.emit(self.states[self.slider.value()])\n</code></pre>"},{"location":"reference/cogip/tools/replay/mainwindow/#cogip.tools.replay.mainwindow.MainWindow.slider_moved","title":"<code>slider_moved()</code>","text":"<p>Qt Slot</p> <p>Stop automatic playback when the slider is moved manually.</p> Source code in <code>cogip/tools/replay/mainwindow.py</code> <pre><code>@qtSlot()\ndef slider_moved(self):\n    \"\"\"\n    Qt Slot\n\n    Stop automatic playback when the slider is moved manually.\n    \"\"\"\n    self.pause()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/robotcam/app/","title":"app","text":""},{"location":"reference/cogip/tools/robotcam/app/#cogip.tools.robotcam.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/robotcam/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = CameraServer()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/","title":"camera","text":""},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler","title":"<code>CameraHandler</code>","text":"<p>Camera handler.</p> <p>Handle camera initialization.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>class CameraHandler:\n    \"\"\"\n    Camera handler.\n\n    Handle camera initialization.\n    \"\"\"\n\n    _camera_capture: cv2.VideoCapture = None  # OpenCV video capture\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _frame_rate: float = 10  # Number of images processed by seconds\n    _exiting: bool = False  # Exit requested if True\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO client and connect to server.\n        \"\"\"\n        self.settings = Settings()\n        signal.signal(signal.SIGTERM, self.exit_handler)\n\n        self.record_filename: Path | None = None\n        self.record_writer: cv2.VideoWriter | None = None\n\n        self.sio = socketio.Client(logger=False, engineio_logger=False)\n        self.register_sio_events()\n        Thread(\n            target=lambda: polling2.poll(\n                self.sio_connect,\n                step=1,\n                ignore_exceptions=(socketio.exceptions.ConnectionError),\n                poll_forever=True,\n            )\n        ).start()\n\n    @staticmethod\n    def exit_handler(signum, frame):\n        \"\"\"\n        Function called when TERM signal is received.\n        \"\"\"\n        CameraHandler._exiting = True\n        raise ExitSignal()\n\n    def sio_connect(self) -&gt; bool:\n        \"\"\"\n        Connect to SocketIO server.\n        Returning True stops polling for connection to succeed.\n        \"\"\"\n        if self._exiting:\n            return True\n\n        self.sio.connect(\n            str(self.settings.socketio_server_url),\n            namespaces=[\"/robotcam\"],\n        )\n        return True\n\n    def open_camera(self):\n        \"\"\"\n        Initialize camera.\n        \"\"\"\n        camera_name = CameraName[self.settings.camera_name].val\n        if not camera_name.exists():\n            logger.error(f\"Camera not found: {camera_name}\")\n            return\n\n        self._camera_capture = cv2.VideoCapture(str(camera_name), cv2.CAP_V4L2)\n        if not self._camera_capture.isOpened():\n            logger.error(f\"Camera handler: Cannot open camera device {camera_name}\")\n            self._camera_capture.release()\n            self._camera_capture = None\n            return\n\n        camera_codec = VideoCodec[self.settings.camera_codec].val\n\n        fourcc = cv2.VideoWriter_fourcc(*camera_codec)\n        ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n        if not ret:\n            logger.warning(f\"Video codec {camera_codec} not supported\")\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n        if not ret:\n            logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n\n        ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n        if not ret:\n            logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n\n    def close_camera(self) -&gt; None:\n        \"\"\"\n        Release camera device.\n        \"\"\"\n        if self._camera_capture:\n            try:\n                self._camera_capture.release()\n                logger.info(\"Camera handler: Camera closed.\")\n            except Exception as exc:  # noqa\n                logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n        self._camera_capture = None\n\n    def open_last_frame(self, size: int) -&gt; None:\n        \"\"\"\n        Open the shared memory used to exchange last frame with the server.\n\n        Arguments:\n            size: Size of the shared memory\n        \"\"\"\n        if not self._last_frame:\n            try:\n                self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n                logger.info(\"Camera handler: shared memory for last_frame created.\")\n            except FileExistsError as exc:\n                logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n                self._last_frame = None\n\n    def close_last_frame(self) -&gt; None:\n        \"\"\"\n        Close last frame shared memory.\n        \"\"\"\n        if self._last_frame:\n            try:\n                self._last_frame.close()\n                self._last_frame.unlink()\n                logger.info(\"Camera handler: Shared memory for last frame closed.\")\n            except Exception as exc:\n                logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n        self._last_frame = None\n\n    def camera_handler(self) -&gt; None:\n        \"\"\"\n        Read and process frames from camera.\n        \"\"\"\n        interval = 1.0 / self._frame_rate\n\n        try:\n            while not self._exiting:\n                start = time.time()\n\n                if not self._camera_capture:\n                    self.open_camera()\n\n                if not self._camera_capture:\n                    logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                    sleep(1)\n                    continue\n\n                try:\n                    self.process_image()\n                except ExitSignal:\n                    break\n                except Exception as exc:\n                    logger.warning(f\"Unknown exception: {exc}\")\n                    self.close_camera()\n                    sleep(1)\n                    continue\n\n                now = time.time()\n                duration = now - start\n                if duration &gt; interval:\n                    logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n                else:\n                    wait = interval - duration\n                    time.sleep(wait)\n\n        except (KeyboardInterrupt, ExitSignal):\n            pass\n\n        logger.info(\"Camera handler: Exiting.\")\n\n        self.close_last_frame()\n        self.close_camera()\n        if self.sio.connected:\n            self.sio.disconnect()\n\n    def process_image(self) -&gt; None:\n        \"\"\"\n        Read one frame from camera, process it, send samples to cogip-server\n        and generate image to stream.\n        \"\"\"\n        image_color: np.ndarray\n        ret, image_color = self._camera_capture.read()\n        if not ret:\n            raise Exception(\"Camera handler: Cannot read frame.\")\n\n        image_stream: np.ndarray = image_color\n\n        # Encode the frame in BMP format (larger but faster than JPEG)\n        encoded_image: np.ndarray\n        ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n        if not ret:\n            raise Exception(\"Can't encode frame.\")\n\n        # frame = (b'--frame\\r\\n' b'Content-Type: image/bmp\\r\\n\\r\\n' + encoded_image.tobytes() + b'\\r\\n')\n        frame = encoded_image.tobytes()\n        self.open_last_frame(len(frame))\n\n        if self._last_frame:\n            self._last_frame.buf[0 : len(frame)] = frame\n\n        if self.record_writer:\n            self.record_writer.write(image_stream)\n\n    def start_video_record(self):\n        if self.record_writer:\n            self.stop_video_record()\n        records_dir = Path.home() / \"records\"\n        records_dir.mkdir(exist_ok=True)\n        # Keep only 20 last records\n        for old_record in sorted(records_dir.glob(\"*.mp4\"))[:-20]:\n            old_record.unlink()\n        timestamp = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\n        self.record_filename = records_dir / f\"robot{self.settings.id}_{timestamp}.mp4\"\n\n        logger.info(f\"Start recording video in {self.record_filename}\")\n        self.record_writer = cv2.VideoWriter(\n            str(self.record_filename),\n            cv2.VideoWriter_fourcc(*\"mp4v\"),\n            self._frame_rate,\n            (self.settings.camera_width, self.settings.camera_height),\n        )\n\n    def stop_video_record(self):\n        if self.record_writer:\n            logger.info(\"Stop recording video\")\n            self.record_writer.release()\n            self.record_filename = None\n            self.record_writer = None\n\n    def register_sio_events(self) -&gt; None:\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect():\n            \"\"\"\n            Callback on server connection.\n            \"\"\"\n            polling2.poll(lambda: self.sio.connected is True, step=0.2, poll_forever=True)\n            logger.info(\"Camera handler: connected to server\")\n            self.sio.emit(\"connected\", namespace=\"/robotcam\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def connect_error(data):\n            \"\"\"\n            Callback on server connection error.\n            \"\"\"\n            logger.info(\"Camera handler: connection to server failed.\")\n\n        @self.sio.event(namespace=\"/robotcam\")\n        def disconnect():\n            \"\"\"\n            Callback on server disconnection.\n            \"\"\"\n            logger.info(\"Camera handler: disconnected from server\")\n\n        @self.sio.on(\"start_video_record\", namespace=\"/robotcam\")\n        def start_video_record():\n            self.start_video_record()\n\n        @self.sio.on(\"stop_video_record\", namespace=\"/robotcam\")\n        def stop_video_record():\n            self.stop_video_record()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO client and connect to server.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO client and connect to server.\n    \"\"\"\n    self.settings = Settings()\n    signal.signal(signal.SIGTERM, self.exit_handler)\n\n    self.record_filename: Path | None = None\n    self.record_writer: cv2.VideoWriter | None = None\n\n    self.sio = socketio.Client(logger=False, engineio_logger=False)\n    self.register_sio_events()\n    Thread(\n        target=lambda: polling2.poll(\n            self.sio_connect,\n            step=1,\n            ignore_exceptions=(socketio.exceptions.ConnectionError),\n            poll_forever=True,\n        )\n    ).start()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.camera_handler","title":"<code>camera_handler()</code>","text":"<p>Read and process frames from camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def camera_handler(self) -&gt; None:\n    \"\"\"\n    Read and process frames from camera.\n    \"\"\"\n    interval = 1.0 / self._frame_rate\n\n    try:\n        while not self._exiting:\n            start = time.time()\n\n            if not self._camera_capture:\n                self.open_camera()\n\n            if not self._camera_capture:\n                logger.warning(\"Camera handler: Failed to open camera, retry in 1s.\")\n                sleep(1)\n                continue\n\n            try:\n                self.process_image()\n            except ExitSignal:\n                break\n            except Exception as exc:\n                logger.warning(f\"Unknown exception: {exc}\")\n                self.close_camera()\n                sleep(1)\n                continue\n\n            now = time.time()\n            duration = now - start\n            if duration &gt; interval:\n                logger.warning(f\"Function too long: {duration} &gt; {interval}\")\n            else:\n                wait = interval - duration\n                time.sleep(wait)\n\n    except (KeyboardInterrupt, ExitSignal):\n        pass\n\n    logger.info(\"Camera handler: Exiting.\")\n\n    self.close_last_frame()\n    self.close_camera()\n    if self.sio.connected:\n        self.sio.disconnect()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.close_camera","title":"<code>close_camera()</code>","text":"<p>Release camera device.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def close_camera(self) -&gt; None:\n    \"\"\"\n    Release camera device.\n    \"\"\"\n    if self._camera_capture:\n        try:\n            self._camera_capture.release()\n            logger.info(\"Camera handler: Camera closed.\")\n        except Exception as exc:  # noqa\n            logger.info(\"Camera handler: Failed to release camera: {exc}\")\n\n    self._camera_capture = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.close_last_frame","title":"<code>close_last_frame()</code>","text":"<p>Close last frame shared memory.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def close_last_frame(self) -&gt; None:\n    \"\"\"\n    Close last frame shared memory.\n    \"\"\"\n    if self._last_frame:\n        try:\n            self._last_frame.close()\n            self._last_frame.unlink()\n            logger.info(\"Camera handler: Shared memory for last frame closed.\")\n        except Exception as exc:\n            logger.info(f\"Camera handler: Failed to close shared memory for last frame: {exc}\")\n\n    self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.exit_handler","title":"<code>exit_handler(signum, frame)</code>  <code>staticmethod</code>","text":"<p>Function called when TERM signal is received.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>@staticmethod\ndef exit_handler(signum, frame):\n    \"\"\"\n    Function called when TERM signal is received.\n    \"\"\"\n    CameraHandler._exiting = True\n    raise ExitSignal()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.open_camera","title":"<code>open_camera()</code>","text":"<p>Initialize camera.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def open_camera(self):\n    \"\"\"\n    Initialize camera.\n    \"\"\"\n    camera_name = CameraName[self.settings.camera_name].val\n    if not camera_name.exists():\n        logger.error(f\"Camera not found: {camera_name}\")\n        return\n\n    self._camera_capture = cv2.VideoCapture(str(camera_name), cv2.CAP_V4L2)\n    if not self._camera_capture.isOpened():\n        logger.error(f\"Camera handler: Cannot open camera device {camera_name}\")\n        self._camera_capture.release()\n        self._camera_capture = None\n        return\n\n    camera_codec = VideoCodec[self.settings.camera_codec].val\n\n    fourcc = cv2.VideoWriter_fourcc(*camera_codec)\n    ret = self._camera_capture.set(cv2.CAP_PROP_FOURCC, fourcc)\n    if not ret:\n        logger.warning(f\"Video codec {camera_codec} not supported\")\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_WIDTH, self.settings.camera_width)\n    if not ret:\n        logger.warning(f\"Frame width {self.settings.camera_width} not supported\")\n\n    ret = self._camera_capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self.settings.camera_height)\n    if not ret:\n        logger.warning(f\"Frame height {self.settings.camera_height} not supported\")\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.open_last_frame","title":"<code>open_last_frame(size)</code>","text":"<p>Open the shared memory used to exchange last frame with the server.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the shared memory</p> required Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def open_last_frame(self, size: int) -&gt; None:\n    \"\"\"\n    Open the shared memory used to exchange last frame with the server.\n\n    Arguments:\n        size: Size of the shared memory\n    \"\"\"\n    if not self._last_frame:\n        try:\n            self._last_frame = SharedMemory(name=\"last_frame\", create=True, size=size)\n            logger.info(\"Camera handler: shared memory for last_frame created.\")\n        except FileExistsError as exc:\n            logger.warning(f\"Camera handler: Failed to create shared memory for last_frame: {exc}\")\n            self._last_frame = None\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.process_image","title":"<code>process_image()</code>","text":"<p>Read one frame from camera, process it, send samples to cogip-server and generate image to stream.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def process_image(self) -&gt; None:\n    \"\"\"\n    Read one frame from camera, process it, send samples to cogip-server\n    and generate image to stream.\n    \"\"\"\n    image_color: np.ndarray\n    ret, image_color = self._camera_capture.read()\n    if not ret:\n        raise Exception(\"Camera handler: Cannot read frame.\")\n\n    image_stream: np.ndarray = image_color\n\n    # Encode the frame in BMP format (larger but faster than JPEG)\n    encoded_image: np.ndarray\n    ret, encoded_image = cv2.imencode(\".bmp\", image_stream)\n\n    if not ret:\n        raise Exception(\"Can't encode frame.\")\n\n    # frame = (b'--frame\\r\\n' b'Content-Type: image/bmp\\r\\n\\r\\n' + encoded_image.tobytes() + b'\\r\\n')\n    frame = encoded_image.tobytes()\n    self.open_last_frame(len(frame))\n\n    if self._last_frame:\n        self._last_frame.buf[0 : len(frame)] = frame\n\n    if self.record_writer:\n        self.record_writer.write(image_stream)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/camera/#cogip.tools.robotcam.camera.CameraHandler.sio_connect","title":"<code>sio_connect()</code>","text":"<p>Connect to SocketIO server. Returning True stops polling for connection to succeed.</p> Source code in <code>cogip/tools/robotcam/camera.py</code> <pre><code>def sio_connect(self) -&gt; bool:\n    \"\"\"\n    Connect to SocketIO server.\n    Returning True stops polling for connection to succeed.\n    \"\"\"\n    if self._exiting:\n        return True\n\n    self.sio.connect(\n        str(self.settings.socketio_server_url),\n        namespaces=[\"/robotcam\"],\n    )\n    return True\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/main/","title":"main","text":""},{"location":"reference/cogip/tools/robotcam/main/#cogip.tools.robotcam.main.main","title":"<code>main()</code>","text":"<p>Launch COGIP Robot Camera.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-robotcam</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/robotcam/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Launch COGIP Robot Camera.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-robotcam` script using this function as entrypoint.\n    \"\"\"\n    settings = Settings()\n\n    # Start Camera handler process\n    p = Process(target=start_camera_handler)\n    p.start()\n\n    # Start web server\n    uvicorn.run(\n        \"cogip.tools.robotcam.app:app\",\n        host=\"0.0.0.0\",\n        port=8100 + settings.id,\n        workers=settings.nb_workers,\n        log_level=\"warning\",\n    )\n\n    p.terminate()\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/","title":"server","text":""},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer","title":"<code>CameraServer</code>","text":"<p>Camera web server.</p> <p>Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>class CameraServer:\n    \"\"\"\n    Camera web server.\n\n    Handle FastAPI server to stream camera video and SocketIO client to send detected samples to server.\n    \"\"\"\n\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n    _last_frame: SharedMemory = None  # Last generated frame to stream on web server\n    _original_uvicorn_exit_handler = UvicornServer.handle_exit\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create FastAPI application and SocketIO client.\n        \"\"\"\n        self.settings = Settings()\n        CameraServer._exiting = False\n\n        self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", debug=False)\n        self.register_endpoints()\n\n        UvicornServer.handle_exit = self.handle_exit\n\n        self.records_dir = Path.home() / \"records\"\n        self.records_dir.mkdir(exist_ok=True)\n        # Keep only 100 last records\n        for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n            old_record.unlink()\n\n        # Load camera intrinsic parameters\n        self.camera_matrix: cv2.typing.MatLike | None = None\n        self.dist_coefs: cv2.typing.MatLike | None = None\n        if self.settings.camera_intrinsic_params:\n            params_filename = self.settings.camera_intrinsic_params\n        else:\n            params_filename = get_camera_intrinsic_params_filename(\n                self.settings.id,\n                CameraName[self.settings.camera_name],\n                VideoCodec[self.settings.camera_codec],\n                self.settings.camera_width,\n                self.settings.camera_height,\n            )\n\n        if not params_filename.exists():\n            logger.warning(f\"Camera intrinsic parameters file not found: {params_filename}\")\n        else:\n            self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(params_filename)\n\n        # Load camera extrinsic parameters\n        self.extrinsic_params: CameraExtrinsicParameters | None = None\n        if self.settings.camera_extrinsic_params:\n            params_filename = self.settings.camera_extrinsic_params\n        else:\n            params_filename = get_camera_extrinsic_params_filename(\n                self.settings.id,\n                CameraName[self.settings.camera_name],\n                VideoCodec[self.settings.camera_codec],\n                self.settings.camera_width,\n                self.settings.camera_height,\n            )\n\n        if not params_filename.exists():\n            logger.warning(f\"Camera extrinsic parameters file not found: {params_filename}\")\n        else:\n            self.extrinsic_params = load_camera_extrinsic_params(params_filename)\n\n        self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n        self.parameters = cv2.aruco.DetectorParameters()\n        self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.parameters)\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        CameraServer._exiting = True\n\n        if CameraServer._last_frame:\n            try:\n                CameraServer._last_frame.close()\n                logger.info(\"Camera server: Detached shared memory for last frame.\")\n            except FileNotFoundError:\n                pass\n\n        CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n\n    def camera_connect(self) -&gt; bool:\n        if self._exiting:\n            return True\n\n        try:\n            CameraServer._last_frame = SharedMemory(name=\"last_frame\")\n        except Exception:\n            CameraServer._last_frame = None\n            logger.warning(\"Camera server: Failed to attach to shared memory last_frame, retrying in 1s.\")\n            return False\n        logger.info(\"Camera server: Attached to shared memory last_frame.\")\n        return True\n\n    async def camera_streamer(self):\n        \"\"\"\n        Frame generator.\n        Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n        \"\"\"\n        while not self._exiting:\n            yield b\"--frame\\r\\n\"\n            yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n            yield bytes(self._last_frame.buf)\n            yield b\"\\r\\n\"\n\n    def register_endpoints(self) -&gt; None:\n        @self.app.on_event(\"startup\")\n        async def startup_event():\n            \"\"\"\n            Function called at FastAPI server startup.\n            \"\"\"\n            # Poll in background to wait for camera server connection through shared memory.\n            Thread(\n                target=lambda: polling2.poll(\n                    self.camera_connect,\n                    step=1,\n                    poll_forever=True,\n                )\n            ).start()\n\n        @self.app.on_event(\"shutdown\")\n        async def shutdown_event():\n            \"\"\"\n            Function called at FastAPI server shutdown.\n            \"\"\"\n            pass\n\n        @self.app.get(\"/\")\n        def index():\n            \"\"\"\n            Camera stream.\n            \"\"\"\n            stream = self.camera_streamer() if CameraServer._last_frame else \"\"\n            return StreamingResponse(stream, media_type=\"multipart/x-mixed-replace;boundary=frame\")\n\n        @self.app.get(\"/snapshot\", status_code=200)\n        async def snapshot():\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-snapshot\"\n\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n        @self.app.get(\"/camera_calibration\", status_code=200)\n        async def camera_calibration(x: float, y: float, angle: float) -&gt; Vertex:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-calibration\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            robot_pose = Pose(x=x, y=y, O=angle)\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            # Compute camera position on table\n            table_camera_tvec, table_camera_angle = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute camera position in robot if robot position is given\n            camera_position = get_camera_position_in_robot(\n                robot_pose,\n                table_camera_tvec,\n                table_camera_angle,\n            )\n\n            return camera_position\n\n        @self.app.get(\"/solar_panels\", status_code=200)\n        async def solar_panels(x: float, y: float, angle: float) -&gt; dict[int, float]:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, rejected = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-panels\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                return {}\n\n            robot_pose = Pose(x=x, y=y, O=angle)\n\n            # Keep solar panel markers only\n            solar_panel_markers = [corners for id, corners in zip(marker_ids, marker_corners) if id[0] == 47]\n\n            if len(solar_panel_markers) == 0:\n                return {}\n\n            panels = get_solar_panel_positions(\n                solar_panel_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n                self.extrinsic_params,\n                robot_pose,\n            )\n\n            return panels\n\n        @self.app.get(\"/robot_position\", status_code=200)\n        async def robot_position() -&gt; Pose:\n            jpg_as_np = np.frombuffer(self._last_frame.buf, dtype=np.uint8)\n            frame = cv2.imdecode(jpg_as_np, flags=1)\n            dst = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n\n            # Detect marker corners\n            marker_corners, marker_ids, _ = self.detector.detectMarkers(dst)\n\n            # Draw detected markers\n            cv2.aruco.drawDetectedMarkers(frame, marker_corners, marker_ids)\n\n            # Record image\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            basename = f\"robot{self.settings.id}-{timestamp}-position\"\n            record_filename = self.records_dir / f\"{basename}.jpg\"\n            cv2.imwrite(str(record_filename), frame)\n\n            if marker_ids is None:\n                raise HTTPException(status_code=404, detail=\"No marker found\")\n\n            # Keep table markers only\n            table_markers = {\n                id[0]: corners for id, corners in zip(marker_ids, marker_corners) if id[0] in [20, 21, 22, 23]\n            }\n\n            if len(table_markers) == 0:\n                raise HTTPException(status_code=404, detail=\"No table marker found\")\n\n            # Compute camera position on table\n            camera_tvec, camera_angle = get_camera_position_on_table(\n                table_markers,\n                self.camera_matrix,\n                self.dist_coefs,\n            )\n\n            # Compute robot position on table\n            delta_tvec = np.array([self.extrinsic_params.x, self.extrinsic_params.y])\n            camera_tvec_rotated = rotate_2d(camera_tvec[0:2], -camera_angle)\n            robot_tvec_rotated = camera_tvec_rotated + delta_tvec\n            robot_tvec = rotate_2d(robot_tvec_rotated, camera_angle)\n            camera_angle_degrees = np.rad2deg(camera_angle)\n            logger.info(\n                \"Robot position: \"\n                f\"X={robot_tvec[0]:.0f} Y={robot_tvec[1]:.0f} Z={camera_tvec[2]:.0f} Angle={camera_angle_degrees:.0f}\"\n            )\n            return Pose(x=robot_tvec[0], y=robot_tvec[1], z=camera_tvec[2], O=camera_angle_degrees)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create FastAPI application and SocketIO client.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create FastAPI application and SocketIO client.\n    \"\"\"\n    self.settings = Settings()\n    CameraServer._exiting = False\n\n    self.app = FastAPI(title=\"COGIP Robot Camera Streamer\", debug=False)\n    self.register_endpoints()\n\n    UvicornServer.handle_exit = self.handle_exit\n\n    self.records_dir = Path.home() / \"records\"\n    self.records_dir.mkdir(exist_ok=True)\n    # Keep only 100 last records\n    for old_record in sorted(self.records_dir.glob(\"*.jpg\"))[:-100]:\n        old_record.unlink()\n\n    # Load camera intrinsic parameters\n    self.camera_matrix: cv2.typing.MatLike | None = None\n    self.dist_coefs: cv2.typing.MatLike | None = None\n    if self.settings.camera_intrinsic_params:\n        params_filename = self.settings.camera_intrinsic_params\n    else:\n        params_filename = get_camera_intrinsic_params_filename(\n            self.settings.id,\n            CameraName[self.settings.camera_name],\n            VideoCodec[self.settings.camera_codec],\n            self.settings.camera_width,\n            self.settings.camera_height,\n        )\n\n    if not params_filename.exists():\n        logger.warning(f\"Camera intrinsic parameters file not found: {params_filename}\")\n    else:\n        self.camera_matrix, self.dist_coefs = load_camera_intrinsic_params(params_filename)\n\n    # Load camera extrinsic parameters\n    self.extrinsic_params: CameraExtrinsicParameters | None = None\n    if self.settings.camera_extrinsic_params:\n        params_filename = self.settings.camera_extrinsic_params\n    else:\n        params_filename = get_camera_extrinsic_params_filename(\n            self.settings.id,\n            CameraName[self.settings.camera_name],\n            VideoCodec[self.settings.camera_codec],\n            self.settings.camera_width,\n            self.settings.camera_height,\n        )\n\n    if not params_filename.exists():\n        logger.warning(f\"Camera extrinsic parameters file not found: {params_filename}\")\n    else:\n        self.extrinsic_params = load_camera_extrinsic_params(params_filename)\n\n    self.aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)\n    self.parameters = cv2.aruco.DetectorParameters()\n    self.detector = cv2.aruco.ArucoDetector(self.aruco_dict, self.parameters)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.camera_streamer","title":"<code>camera_streamer()</code>  <code>async</code>","text":"<p>Frame generator. Yield frames produced by camera_handler.</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>async def camera_streamer(self):\n    \"\"\"\n    Frame generator.\n    Yield frames produced by [camera_handler][cogip.tools.robotcam.camera.CameraHandler.camera_handler].\n    \"\"\"\n    while not self._exiting:\n        yield b\"--frame\\r\\n\"\n        yield b\"Content-Type: image/bmp\\r\\n\\r\\n\"\n        yield bytes(self._last_frame.buf)\n        yield b\"\\r\\n\"\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/server/#cogip.tools.robotcam.server.CameraServer.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/robotcam/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    CameraServer._exiting = True\n\n    if CameraServer._last_frame:\n        try:\n            CameraServer._last_frame.close()\n            logger.info(\"Camera server: Detached shared memory for last frame.\")\n        except FileNotFoundError:\n            pass\n\n    CameraServer._original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/robotcam/settings/","title":"settings","text":""},{"location":"reference/cogip/tools/server/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server/__main__/#cogip.tools.server.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO/Web server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO/Web server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server/app/","title":"app","text":""},{"location":"reference/cogip/tools/server/app/#cogip.tools.server.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server/context/","title":"context","text":""},{"location":"reference/cogip/tools/server/context/#cogip.tools.server.context.Context","title":"<code>Context</code>  <code>dataclass</code>","text":"<p>Server context class recording variables using in multiple namespaces.</p> <p>Attributes:</p> Name Type Description <code>robot_id</code> <code>int | None</code> <p>Robot ID</p> <code>planner_sid</code> <code>str | None</code> <p>Planner sid</p> <code>copilot_sid</code> <code>str | None</code> <p>Copilot sid</p> <code>detector_sid</code> <code>str | None</code> <p>Detector sid</p> <code>robotcam_sid</code> <code>str | None</code> <p>Robotcam sid</p> <code>beacon_sid</code> <code>str | None</code> <p>Beacon server sid</p> <code>monitor_sid</code> <code>str | None</code> <p>Monitor sid</p> <code>tool_menus</code> <code>dict[str, ShellMenu]</code> <p>all registered tool menus</p> <code>current_tool_menu</code> <code>str | None</code> <p>name of the currently selected tool menu</p> <code>shell_menu</code> <code>ShellMenu | None</code> <p>last received shell menu</p> <code>virtual</code> <p>Whether robot is virtual or not</p> Source code in <code>cogip/tools/server/context.py</code> <pre><code>@dataclass\nclass Context(metaclass=Singleton):\n    \"\"\"\n    Server context class recording variables using in multiple namespaces.\n\n    Attributes:\n        robot_id:           Robot ID\n        planner_sid:        Planner sid\n        copilot_sid:        Copilot sid\n        detector_sid:       Detector sid\n        robotcam_sid:       Robotcam sid\n        beacon_sid:         Beacon server sid\n        monitor_sid:        Monitor sid\n        tool_menus:         all registered tool menus\n        current_tool_menu:  name of the currently selected tool menu\n        shell_menu:         last received shell menu\n        virtual:            Whether robot is virtual or not\n    \"\"\"\n\n    robot_id: int | None = None\n    planner_sid: str | None = None\n    copilot_sid: str | None = None\n    detector_sid: str | None = None\n    robotcam_sid: str | None = None\n    beacon_sid: str | None = None\n    monitor_sid: str | None = None\n    tool_menus: dict[str, models.ShellMenu] = field(default_factory=dict)\n    current_tool_menu: str | None = None\n    shell_menu: models.ShellMenu | None = None\n    virtual = platform.machine() != \"aarch64\"\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/","title":"recorder","text":""},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecordFileHandler","title":"<code>GameRecordFileHandler</code>","text":"<p>               Bases: <code>RotatingFileHandler</code></p> <p>Log handler specific to the game recorder, using record filenames with timestamps defined at the creation of the log file.</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>class GameRecordFileHandler(RotatingFileHandler):\n    \"\"\"\n    Log handler specific to the game recorder, using record filenames\n    with timestamps defined at the creation of the log file.\n    \"\"\"\n\n    def __init__(self, root_dir=\"/var/tmp/cogip\", backupCount=20):\n        \"\"\"Class constructor\"\"\"\n        self._root_dir = Path(root_dir).resolve()\n        self._root_dir.mkdir(parents=True, exist_ok=True)\n        super().__init__(\n            filename=self.newBaseFilename(),\n            mode=\"a\",\n            maxBytes=0,\n            backupCount=backupCount,\n            encoding=None,\n            delay=False,\n        )\n\n    def newBaseFilename(self) -&gt; str:\n        \"\"\"\n        Create a log filename based on current time.\n        \"\"\"\n        current_time = int(time.time())\n        time_tuple = time.localtime(current_time)\n        return f\"{self._root_dir}/game-{time.strftime('%Y-%m-%d_%H-%M-%S', time_tuple)}.log\"\n\n    def doRollover(self):\n        \"\"\"\n        Create a new record file and clean-up old files.\n        \"\"\"\n        if self.stream:\n            self.stream.close()\n            self.stream = None\n\n        current_record_file = Path(self.baseFilename)\n        if current_record_file.exists() and current_record_file.stat().st_size == 0:\n            current_record_file.unlink()\n\n        self.baseFilename = self.newBaseFilename()\n\n        if self.backupCount &gt; 0:\n            record_files = sorted(self._root_dir.glob(\"*.log\"))\n            if len(record_files) &gt; self.backupCount:\n                for _ in range(len(record_files) - self.backupCount):\n                    record_files.pop(0).unlink(missing_ok=True)\n\n        if not self.delay:\n            self.stream = self._open()\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecordFileHandler.__init__","title":"<code>__init__(root_dir='/var/tmp/cogip', backupCount=20)</code>","text":"<p>Class constructor</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>def __init__(self, root_dir=\"/var/tmp/cogip\", backupCount=20):\n    \"\"\"Class constructor\"\"\"\n    self._root_dir = Path(root_dir).resolve()\n    self._root_dir.mkdir(parents=True, exist_ok=True)\n    super().__init__(\n        filename=self.newBaseFilename(),\n        mode=\"a\",\n        maxBytes=0,\n        backupCount=backupCount,\n        encoding=None,\n        delay=False,\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecordFileHandler.doRollover","title":"<code>doRollover()</code>","text":"<p>Create a new record file and clean-up old files.</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>def doRollover(self):\n    \"\"\"\n    Create a new record file and clean-up old files.\n    \"\"\"\n    if self.stream:\n        self.stream.close()\n        self.stream = None\n\n    current_record_file = Path(self.baseFilename)\n    if current_record_file.exists() and current_record_file.stat().st_size == 0:\n        current_record_file.unlink()\n\n    self.baseFilename = self.newBaseFilename()\n\n    if self.backupCount &gt; 0:\n        record_files = sorted(self._root_dir.glob(\"*.log\"))\n        if len(record_files) &gt; self.backupCount:\n            for _ in range(len(record_files) - self.backupCount):\n                record_files.pop(0).unlink(missing_ok=True)\n\n    if not self.delay:\n        self.stream = self._open()\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecordFileHandler.newBaseFilename","title":"<code>newBaseFilename()</code>","text":"<p>Create a log filename based on current time.</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>def newBaseFilename(self) -&gt; str:\n    \"\"\"\n    Create a log filename based on current time.\n    \"\"\"\n    current_time = int(time.time())\n    time_tuple = time.localtime(current_time)\n    return f\"{self._root_dir}/game-{time.strftime('%Y-%m-%d_%H-%M-%S', time_tuple)}.log\"\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecorder","title":"<code>GameRecorder</code>","text":"Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>class GameRecorder(metaclass=Singleton):\n    def __init__(self):\n        self._game_recorder = logging.getLogger(\"GameRecorder\")\n        self._game_recorder.setLevel(logging.INFO)\n        self._game_recorder.propagate = False\n        self._loop = asyncio.get_running_loop()\n        self._record_dir = os.environ.get(\"SERVER_RECORD_DIR\", \"/var/tmp/cogip\")\n        self._recording = False\n\n        try:\n            self._record_handler = GameRecordFileHandler(self._record_dir)\n            self._game_recorder.addHandler(self._record_handler)\n        except OSError:\n            logger.warning(f\"Failed to record games in directory '{self._record_dir}'\")\n            self._record_handler = None\n\n    @property\n    def recording(self) -&gt; bool:\n        return self._recording\n\n    @recording.setter\n    def recording(self, enabled: bool) -&gt; None:\n        self._recording = enabled\n\n    def record(self, record: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Write a record in the current record file.\n        Do it only the the robot the game has started.\n        \"\"\"\n        if self._record_handler and self._recording:\n            self._game_recorder.info(json.dumps(record))\n\n    async def async_record(self, record: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Async version of [`record()`][cogip.tools.server.recorder.GameRecorder.record] .\n        \"\"\"\n        await self._loop.run_in_executor(None, self.record, record)\n\n    def do_rollover(self) -&gt; None:\n        \"\"\"\n        Switch to a new record file.\n        \"\"\"\n        if self._record_handler:\n            self._record_handler.doRollover()\n\n    async def async_do_rollover(self) -&gt; None:\n        \"\"\"\n        Async version of [`record()`][cogip.tools.server.recorder.GameRecorder.do_rollover] .\n        \"\"\"\n        await self._loop.run_in_executor(None, self._record_handler.doRollover)\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecorder.async_do_rollover","title":"<code>async_do_rollover()</code>  <code>async</code>","text":"<p>Async version of <code>record()</code> .</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>async def async_do_rollover(self) -&gt; None:\n    \"\"\"\n    Async version of [`record()`][cogip.tools.server.recorder.GameRecorder.do_rollover] .\n    \"\"\"\n    await self._loop.run_in_executor(None, self._record_handler.doRollover)\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecorder.async_record","title":"<code>async_record(record)</code>  <code>async</code>","text":"<p>Async version of <code>record()</code> .</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>async def async_record(self, record: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Async version of [`record()`][cogip.tools.server.recorder.GameRecorder.record] .\n    \"\"\"\n    await self._loop.run_in_executor(None, self.record, record)\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecorder.do_rollover","title":"<code>do_rollover()</code>","text":"<p>Switch to a new record file.</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>def do_rollover(self) -&gt; None:\n    \"\"\"\n    Switch to a new record file.\n    \"\"\"\n    if self._record_handler:\n        self._record_handler.doRollover()\n</code></pre>"},{"location":"reference/cogip/tools/server/recorder/#cogip.tools.server.recorder.GameRecorder.record","title":"<code>record(record)</code>","text":"<p>Write a record in the current record file. Do it only the the robot the game has started.</p> Source code in <code>cogip/tools/server/recorder.py</code> <pre><code>def record(self, record: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Write a record in the current record file.\n    Do it only the the robot the game has started.\n    \"\"\"\n    if self._record_handler and self._recording:\n        self._game_recorder.info(json.dumps(record))\n</code></pre>"},{"location":"reference/cogip/tools/server/server/","title":"server","text":""},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server/server.py</code> <pre><code>class Server:\n    _exiting: bool = False  # True if Uvicorn server was ask to shutdown\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server.\n        \"\"\"\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n        self.sio.register_namespace(namespaces.MonitorNamespace(self))\n        self.sio.register_namespace(namespaces.CopilotNamespace(self))\n        self.sio.register_namespace(namespaces.DetectorNamespace(self))\n        self.sio.register_namespace(namespaces.PlannerNamespace(self))\n        self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n        self.sio.register_namespace(namespaces.BeaconNamespace(self))\n\n        self.context = context.Context()\n        self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n        self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n        self.context.tool_menus[\"root\"] = self.root_menu\n        self.context.current_tool_menu = \"root\"\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    async def register_menu(self, namespace: str, data: dict[str, Any]) -&gt; None:\n        if not (name := data.get(\"name\")):\n            logger.warning(f\"register_menu: missing 'name' in data: {data}\")\n            return\n        if not (menu_dict := data.get(\"menu\")):\n            logger.warning(f\"register_menu: missing 'menu' in data: {data}\")\n            return\n        try:\n            menu = models.ShellMenu.model_validate(menu_dict)\n        except ValidationError as exc:\n            logger.warning(f\"register_menu: cannot validate 'menu': {exc}\")\n            return\n\n        ns_name = f\"{namespace}/{name}\"\n        entry = models.MenuEntry(cmd=ns_name, desc=f\"{menu.name} Menu\")\n        if ns_name not in self.context.tool_menus:\n            self.root_menu.entries.append(entry)\n        exit_entry = models.MenuEntry(cmd=\"exit\", desc=\"Exit Menu\")\n        menu.entries.append(exit_entry)\n        self.context.tool_menus[ns_name] = menu\n        await self.sio.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n</code></pre>"},{"location":"reference/cogip/tools/server/server/#cogip.tools.server.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server.</p> Source code in <code>cogip/tools/server/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server.\n    \"\"\"\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n    self.sio.register_namespace(namespaces.MonitorNamespace(self))\n    self.sio.register_namespace(namespaces.CopilotNamespace(self))\n    self.sio.register_namespace(namespaces.DetectorNamespace(self))\n    self.sio.register_namespace(namespaces.PlannerNamespace(self))\n    self.sio.register_namespace(namespaces.RobotcamNamespace(self))\n    self.sio.register_namespace(namespaces.BeaconNamespace(self))\n\n    self.context = context.Context()\n    self.context.robot_id = int(os.environ[\"ROBOT_ID\"])\n    self.root_menu = models.ShellMenu(name=\"Root Menu\", entries=[])\n    self.context.tool_menus[\"root\"] = self.root_menu\n    self.context.current_tool_menu = \"root\"\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/","title":"beacon","text":""},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace","title":"<code>BeaconNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to beacon server.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>class BeaconNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to beacon server.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/beacon\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.recorder = GameRecorder()\n\n    async def on_connect(self, sid, environ):\n        if self.context.beacon_sid:\n            message = \"A beacon server is already connected\"\n            logger.error(f\"Beacon verser connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.beacon_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Beacon connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.beacon_sid = None\n        logger.info(\"Beacon disconnected.\")\n\n    async def on_reset(self, sid):\n        \"\"\"\n        Callback on reset message.\n        \"\"\"\n        await self.emit(\"reset\", namespace=\"/planner\")\n\n    async def on_command(self, sid, cmd):\n        \"\"\"\n        Callback on command.\n        \"\"\"\n        await self.emit(\"command\", cmd, namespace=\"/planner\")\n\n    async def on_wizard(self, sid, message):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_command","title":"<code>on_command(sid, cmd)</code>  <code>async</code>","text":"<p>Callback on command.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_command(self, sid, cmd):\n    \"\"\"\n    Callback on command.\n    \"\"\"\n    await self.emit(\"command\", cmd, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_reset(self, sid):\n    \"\"\"\n    Callback on reset message.\n    \"\"\"\n    await self.emit(\"reset\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/beacon/#cogip.tools.server.namespaces.beacon.BeaconNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/beacon.py</code> <pre><code>async def on_wizard(self, sid, message):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    await self.emit(\"wizard\", message, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/","title":"copilot","text":""},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace","title":"<code>CopilotNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to copilot.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>class CopilotNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to copilot.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/copilot\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.recorder = GameRecorder()\n        self.context.copilot_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.copilot_sid:\n            message = \"A copilot is already connected\"\n            logger.error(f\"Copilot connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.copilot_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Copilot connected.\")\n        await self.emit(\"copilot_connected\", namespace=\"/planner\")\n\n    async def on_disconnect(self, sid):\n        self.context.copilot_sid = None\n        self.context.shell_menu = None\n        await self.emit(\"copilot_disconnected\", namespace=\"/planner\")\n        logger.info(\"Copilot disconnected.\")\n\n    async def on_reset(self, sid) -&gt; None:\n        \"\"\"\n        Callback on reset event.\n        \"\"\"\n        await self.emit(\"reset\", namespace=\"/planner\")\n        await self.recorder.async_do_rollover()\n        self.recorder.recording = True\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"copilot\", data)\n\n    async def on_pose_reached(self, sid) -&gt; None:\n        \"\"\"\n        Callback on pose reached message.\n        \"\"\"\n        await self.emit(\"pose_reached\", namespace=\"/planner\")\n\n    async def on_menu(self, sid, menu):\n        \"\"\"\n        Callback on menu event.\n        \"\"\"\n        self.context.shell_menu = models.ShellMenu.model_validate(menu)\n        await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n\n    async def on_pose(self, sid, pose):\n        \"\"\"\n        Callback on pose event.\n        \"\"\"\n        await self.emit(\"pose_current\", pose, namespace=\"/detector\")\n        await self.emit(\"pose_current\", pose, namespace=\"/planner\")\n        await self.emit(\"pose_current\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n        await self.recorder.async_record({\"pose_current\": pose})\n\n    async def on_state(self, sid, state):\n        \"\"\"\n        Callback on state event.\n        \"\"\"\n        await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n        await self.recorder.async_record({\"state\": state})\n\n    async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n        \"\"\"\n        Callback on actuator_state message.\n        \"\"\"\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n        await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n\n    async def on_pid(self, sid, pid: dict[str, Any]):\n        \"\"\"\n        Callback on pid message.\n        \"\"\"\n        await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_game_end(self, sid) -&gt; None:\n        \"\"\"\n        Callback on game end message.\n        \"\"\"\n        await self.emit(\"game_end\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_actuator_state","title":"<code>on_actuator_state(sid, actuator_state)</code>  <code>async</code>","text":"<p>Callback on actuator_state message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_actuator_state(self, sid, actuator_state: dict[str, Any]):\n    \"\"\"\n    Callback on actuator_state message.\n    \"\"\"\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/planner\")\n    await self.emit(\"actuator_state\", actuator_state, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game end message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_game_end(self, sid) -&gt; None:\n    \"\"\"\n    Callback on game end message.\n    \"\"\"\n    await self.emit(\"game_end\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_menu","title":"<code>on_menu(sid, menu)</code>  <code>async</code>","text":"<p>Callback on menu event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_menu(self, sid, menu):\n    \"\"\"\n    Callback on menu event.\n    \"\"\"\n    self.context.shell_menu = models.ShellMenu.model_validate(menu)\n    await self.emit(\"shell_menu\", (self.context.robot_id, menu), namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pid","title":"<code>on_pid(sid, pid)</code>  <code>async</code>","text":"<p>Callback on pid message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pid(self, sid, pid: dict[str, Any]):\n    \"\"\"\n    Callback on pid message.\n    \"\"\"\n    await self.emit(\"pid\", pid, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pose","title":"<code>on_pose(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pose(self, sid, pose):\n    \"\"\"\n    Callback on pose event.\n    \"\"\"\n    await self.emit(\"pose_current\", pose, namespace=\"/detector\")\n    await self.emit(\"pose_current\", pose, namespace=\"/planner\")\n    await self.emit(\"pose_current\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n    await self.recorder.async_record({\"pose_current\": pose})\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_pose_reached","title":"<code>on_pose_reached(sid)</code>  <code>async</code>","text":"<p>Callback on pose reached message.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_pose_reached(self, sid) -&gt; None:\n    \"\"\"\n    Callback on pose reached message.\n    \"\"\"\n    await self.emit(\"pose_reached\", namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"copilot\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_reset","title":"<code>on_reset(sid)</code>  <code>async</code>","text":"<p>Callback on reset event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_reset(self, sid) -&gt; None:\n    \"\"\"\n    Callback on reset event.\n    \"\"\"\n    await self.emit(\"reset\", namespace=\"/planner\")\n    await self.recorder.async_do_rollover()\n    self.recorder.recording = True\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/copilot/#cogip.tools.server.namespaces.copilot.CopilotNamespace.on_state","title":"<code>on_state(sid, state)</code>  <code>async</code>","text":"<p>Callback on state event.</p> Source code in <code>cogip/tools/server/namespaces/copilot.py</code> <pre><code>async def on_state(self, sid, state):\n    \"\"\"\n    Callback on state event.\n    \"\"\"\n    await self.emit(\"state\", (self.context.robot_id, state), namespace=\"/dashboard\")\n    await self.recorder.async_record({\"state\": state})\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to dashboards.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to dashboards.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n\n    async def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        await self.emit(\"tool_menu\", self.context.tool_menus[self.context.current_tool_menu].model_dump(), to=sid)\n\n        if self.context.shell_menu:\n            await self.emit(\"shell_menu\", (self.context.robot_id, self.context.shell_menu.model_dump()), to=sid)\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on tool command message from dashboard.\n        \"\"\"\n        # Find entry in current menu\n        entry = None\n        for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n            if entry.cmd == cmd:\n                break\n\n        # Check if it corresponds to a menu or a command\n        if entry and entry.cmd in self.context.tool_menus:\n            # Enter a menu\n            self.context.current_tool_menu = cmd\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            # Forward command to corresponding namespace\n            if cmd == \"exit\":\n                self.context.current_tool_menu = \"root\"\n                await self.emit(\n                    \"tool_menu\",\n                    self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                    namespace=\"/dashboard\",\n                )\n            else:\n                split_ns = self.context.current_tool_menu.split(\"/\")\n                namespace = split_ns.pop(0)\n                await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n\n    async def on_shell_cmd(self, sid, cmd: str) -&gt; None:\n        \"\"\"\n        Callback on shell command message from dashboard.\n        \"\"\"\n        await self.emit(\"shell_command\", cmd, namespace=\"/copilot\")\n\n    async def on_config_updated(self, sid, config: dict[str, Any]) -&gt; None:\n        namespace = config.pop(\"namespace\")\n        await self.emit(\"config_updated\", config, namespace=namespace)\n\n    async def on_actuators_start(self, sid):\n        \"\"\"\n        Callback on actuators_start message.\n        \"\"\"\n        await self.emit(\"actuators_start\", namespace=\"/copilot\")\n\n    async def on_actuators_stop(self, sid):\n        \"\"\"\n        Callback on actuators_stop message.\n        \"\"\"\n        await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        namespace = data.pop(\"namespace\")\n        await self.emit(\"wizard\", data, namespace=namespace)\n        await self.emit(\"close_wizard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_start","title":"<code>on_actuators_start(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_start message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_start(self, sid):\n    \"\"\"\n    Callback on actuators_start message.\n    \"\"\"\n    await self.emit(\"actuators_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_actuators_stop","title":"<code>on_actuators_stop(sid)</code>  <code>async</code>","text":"<p>Callback on actuators_stop message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_actuators_stop(self, sid):\n    \"\"\"\n    Callback on actuators_stop message.\n    \"\"\"\n    await self.emit(\"actuators_stop\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_shell_cmd","title":"<code>on_shell_cmd(sid, cmd)</code>  <code>async</code>","text":"<p>Callback on shell command message from dashboard.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_shell_cmd(self, sid, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on shell command message from dashboard.\n    \"\"\"\n    await self.emit(\"shell_command\", cmd, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_tool_cmd","title":"<code>on_tool_cmd(sid, cmd)</code>  <code>async</code>","text":"<p>Callback on tool command message from dashboard.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_tool_cmd(self, sid, cmd: str) -&gt; None:\n    \"\"\"\n    Callback on tool command message from dashboard.\n    \"\"\"\n    # Find entry in current menu\n    entry = None\n    for entry in self.context.tool_menus[self.context.current_tool_menu].entries:\n        if entry.cmd == cmd:\n            break\n\n    # Check if it corresponds to a menu or a command\n    if entry and entry.cmd in self.context.tool_menus:\n        # Enter a menu\n        self.context.current_tool_menu = cmd\n        await self.emit(\n            \"tool_menu\",\n            self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n            namespace=\"/dashboard\",\n        )\n    else:\n        # Forward command to corresponding namespace\n        if cmd == \"exit\":\n            self.context.current_tool_menu = \"root\"\n            await self.emit(\n                \"tool_menu\",\n                self.context.tool_menus[self.context.current_tool_menu].model_dump(),\n                namespace=\"/dashboard\",\n            )\n        else:\n            split_ns = self.context.current_tool_menu.split(\"/\")\n            namespace = split_ns.pop(0)\n            await self.emit(\"command\", cmd, namespace=f\"/{namespace}\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/dashboard/#cogip.tools.server.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    namespace = data.pop(\"namespace\")\n    await self.emit(\"wizard\", data, namespace=namespace)\n    await self.emit(\"close_wizard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/","title":"detector","text":""},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace","title":"<code>DetectorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to detector.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>class DetectorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to detector.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/detector\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.recorder = GameRecorder()\n\n    async def on_connect(self, sid, environ):\n        if self.context.detector_sid:\n            message = \"A detector is already connected\"\n            logger.error(f\"Detector connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n\n        self.context.detector_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Detector connected.\")\n        if self.context.virtual:\n            await self.emit(\"start_sensors_emulation\", self.context.robot_id, namespace=\"/monitor\")\n\n    async def on_disconnect(self, sid):\n        if self.context.virtual:\n            await self.emit(\"stop_sensors_emulation\", self.context.robot_id, namespace=\"/monitor\")\n        self.context.detector_sid = None\n        logger.info(\"Detector disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"detector\", data)\n\n    async def on_obstacles(self, sid, obstacles: list[dict[str, Any]]):\n        \"\"\"\n        Callback on obstacles message.\n\n        Receive a list of obstacles, computed from sensors data by the Detector.\n        These obstacles are sent to planner to compute avoidance path.\n        \"\"\"\n        await self.emit(\"obstacles\", obstacles, namespace=\"/planner\")\n        await self.recorder.async_record({\"obstacles\": obstacles})\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_obstacles","title":"<code>on_obstacles(sid, obstacles)</code>  <code>async</code>","text":"<p>Callback on obstacles message.</p> <p>Receive a list of obstacles, computed from sensors data by the Detector. These obstacles are sent to planner to compute avoidance path.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_obstacles(self, sid, obstacles: list[dict[str, Any]]):\n    \"\"\"\n    Callback on obstacles message.\n\n    Receive a list of obstacles, computed from sensors data by the Detector.\n    These obstacles are sent to planner to compute avoidance path.\n    \"\"\"\n    await self.emit(\"obstacles\", obstacles, namespace=\"/planner\")\n    await self.recorder.async_record({\"obstacles\": obstacles})\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/detector/#cogip.tools.server.namespaces.detector.DetectorNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/detector.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"detector\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/monitor/","title":"monitor","text":""},{"location":"reference/cogip/tools/server/namespaces/monitor/#cogip.tools.server.namespaces.monitor.MonitorNamespace","title":"<code>MonitorNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to monitor.</p> Source code in <code>cogip/tools/server/namespaces/monitor.py</code> <pre><code>class MonitorNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to monitor.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/monitor\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.monitor_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.monitor_sid:\n            message = \"A monitor is already connected\"\n            logger.error(f\"Monitor connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.monitor_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Monitor connected.\")\n        await self.emit(\"add_robot\", (self.context.robot_id, self.context.virtual), namespace=\"/monitor\")\n        if self.context.virtual:\n            await self.emit(\"start_sensors_emulation\", self.context.robot_id, namespace=\"/monitor\")\n\n    def on_disconnect(self, sid):\n        self.context.monitor_sid = None\n        logger.info(\"Monitor disconnected.\")\n\n    async def on_sensors_data(self, sid, sensors_data: list[int]):\n        \"\"\"\n        Callback on sensors data.\n\n        In emulation mode, receive sensors data from the Monitor,\n        and forward to the Detector in charge of computing dynamic obstacles.\n        \"\"\"\n        await self.emit(\"sensors_data\", sensors_data, namespace=\"/detector\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_changed message.\n        \"\"\"\n        await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/monitor/#cogip.tools.server.namespaces.monitor.MonitorNamespace.on_sensors_data","title":"<code>on_sensors_data(sid, sensors_data)</code>  <code>async</code>","text":"<p>Callback on sensors data.</p> <p>In emulation mode, receive sensors data from the Monitor, and forward to the Detector in charge of computing dynamic obstacles.</p> Source code in <code>cogip/tools/server/namespaces/monitor.py</code> <pre><code>async def on_sensors_data(self, sid, sensors_data: list[int]):\n    \"\"\"\n    Callback on sensors data.\n\n    In emulation mode, receive sensors data from the Monitor,\n    and forward to the Detector in charge of computing dynamic obstacles.\n    \"\"\"\n    await self.emit(\"sensors_data\", sensors_data, namespace=\"/detector\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/monitor/#cogip.tools.server.namespaces.monitor.MonitorNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_changed message.</p> Source code in <code>cogip/tools/server/namespaces/monitor.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_changed message.\n    \"\"\"\n    await self.emit(\"starter_changed\", pushed, namespace=\"/planner\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/","title":"planner","text":""},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace","title":"<code>PlannerNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to planner.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>class PlannerNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to planner.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/planner\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.connected = False\n        self.recorder = GameRecorder()\n        self.context.planner_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.planner_sid:\n            logger.error(\"Planner connection refused: a planner is already connected\")\n            raise ConnectionRefusedError(\"A planner is already connected\")\n        self.context.planner_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Planner connected.\")\n        if self.context.copilot_sid:\n            await self.emit(\"copilot_connected\", namespace=\"/planner\")\n\n    def on_disconnect(self, sid):\n        self.context.planner_sid = None\n        logger.info(\"Planner disconnected.\")\n\n    async def on_register_menu(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on register_menu.\n        \"\"\"\n        await self.cogip_server.register_menu(\"planner\", data)\n\n    async def on_pose_start(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose start.\n        Forward to pose to copilot.\n        \"\"\"\n        await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n\n    async def on_pose_order(self, sid, pose: dict[str, Any]):\n        \"\"\"\n        Callback on pose order.\n        Forward to pose to copilot and dashboards.\n        \"\"\"\n        await self.emit(\"pose_order\", pose, namespace=\"/copilot\")\n        await self.emit(\"pose_order\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n        await self.recorder.async_record({\"pose_order\": pose})\n\n    async def on_obstacles(self, sid, obstacles: list[dict[str, Any]]):\n        \"\"\"\n        Callback on obstacles message.\n\n        Receive a list of all obstacles.\n        These obstacles are sent to planner to monitor/dashboards for display.\n        \"\"\"\n        await self.emit(\"obstacles\", obstacles, namespace=\"/dashboard\")\n\n    async def on_wizard(self, sid, message: list[dict[str, Any]]):\n        \"\"\"\n        Callback on wizard message.\n        Forward to dashboard.\n        \"\"\"\n        message[\"namespace\"] = \"/planner\"\n        await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n\n    async def on_set_controller(self, sid, controller: int):\n        \"\"\"\n        Callback on set_controller message.\n        Forward to copilot.\n        \"\"\"\n        await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n\n    async def on_path(self, sid, path: list[dict[str, float]]):\n        \"\"\"\n        Callback on robot path.\n        Forward the path to dashboard.\n        \"\"\"\n        await self.emit(\"path\", (self.context.robot_id, path), namespace=\"/dashboard\")\n        await self.recorder.async_record({\"pose_order\": path})\n\n    async def on_config(self, sid, config: dict[str, Any]):\n        \"\"\"\n        Callback on config message.\n        \"\"\"\n        await self.emit(\"config\", config, namespace=\"/dashboard\")\n\n    async def on_cmd_reset(self, sid):\n        \"\"\"\n        Callback on cmd_reset message.\n        \"\"\"\n        await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n\n    async def on_starter_changed(self, sid, pushed: bool):\n        \"\"\"\n        Callback on starter_pushed message.\n        \"\"\"\n        await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/monitor\")\n\n    async def on_close_wizard(self, sid):\n        \"\"\"\n        Callback on close_wizard message.\n        \"\"\"\n        await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    async def on_game_start(self, sid):\n        \"\"\"\n        Callback on game_start message.\n        \"\"\"\n        await self.emit(\"game_start\", namespace=\"/copilot\")\n\n    async def on_game_end(self, sid):\n        \"\"\"\n        Callback on game_end message.\n        \"\"\"\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_robot_end(self, sid):\n        \"\"\"\n        Callback on robot_end message.\n        \"\"\"\n        await self.emit(\"game_end\", namespace=\"/copilot\")\n\n    async def on_game_reset(self, sid):\n        \"\"\"\n        Callback on game_reset message.\n        \"\"\"\n        await self.emit(\"game_reset\", namespace=\"/copilot\")\n\n    async def on_score(self, sid, score: int):\n        \"\"\"\n        Callback on score message.\n        \"\"\"\n        await self.emit(\"score\", score, namespace=\"/dashboard\")\n\n    async def on_actuator_command(self, sid, data):\n        \"\"\"\n        Callback on actuator_command message.\n        \"\"\"\n        await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n\n    async def on_start_video_record(self, sid):\n        \"\"\"\n        Callback on start_video_record message.\n        \"\"\"\n        await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n\n    async def on_stop_video_record(self, sid):\n        \"\"\"\n        Callback on stop_video_record message.\n        \"\"\"\n        await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n\n    async def on_brake(self, sid):\n        \"\"\"\n        Callback on brake message.\n        \"\"\"\n        await self.emit(\"brake\", namespace=\"/copilot\")\n\n    async def on_pami_reset(self, sid):\n        \"\"\"\n        Callback on pami_reset message.\n        \"\"\"\n        await self.emit(\"pami_reset\", namespace=\"/beacon\")\n\n    async def on_pami_camp(self, sid, data):\n        \"\"\"\n        Callback on pami_camp message.\n        \"\"\"\n        await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n\n    async def on_pami_table(self, sid, data):\n        \"\"\"\n        Callback on pami_table message.\n        \"\"\"\n        await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n\n    async def on_pami_play(self, sid):\n        \"\"\"\n        Callback on pami_play message.\n        \"\"\"\n        await self.emit(\"pami_play\", namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_actuator_command","title":"<code>on_actuator_command(sid, data)</code>  <code>async</code>","text":"<p>Callback on actuator_command message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_actuator_command(self, sid, data):\n    \"\"\"\n    Callback on actuator_command message.\n    \"\"\"\n    await self.emit(\"actuator_command\", data, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_brake","title":"<code>on_brake(sid)</code>  <code>async</code>","text":"<p>Callback on brake message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_brake(self, sid):\n    \"\"\"\n    Callback on brake message.\n    \"\"\"\n    await self.emit(\"brake\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_close_wizard","title":"<code>on_close_wizard(sid)</code>  <code>async</code>","text":"<p>Callback on close_wizard message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_close_wizard(self, sid):\n    \"\"\"\n    Callback on close_wizard message.\n    \"\"\"\n    await self.emit(\"close_wizard\", namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_cmd_reset","title":"<code>on_cmd_reset(sid)</code>  <code>async</code>","text":"<p>Callback on cmd_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_cmd_reset(self, sid):\n    \"\"\"\n    Callback on cmd_reset message.\n    \"\"\"\n    await self.emit(\"cmd_reset\", namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_config","title":"<code>on_config(sid, config)</code>  <code>async</code>","text":"<p>Callback on config message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_config(self, sid, config: dict[str, Any]):\n    \"\"\"\n    Callback on config message.\n    \"\"\"\n    await self.emit(\"config\", config, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_end","title":"<code>on_game_end(sid)</code>  <code>async</code>","text":"<p>Callback on game_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_end(self, sid):\n    \"\"\"\n    Callback on game_end message.\n    \"\"\"\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_reset","title":"<code>on_game_reset(sid)</code>  <code>async</code>","text":"<p>Callback on game_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_reset(self, sid):\n    \"\"\"\n    Callback on game_reset message.\n    \"\"\"\n    await self.emit(\"game_reset\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_game_start","title":"<code>on_game_start(sid)</code>  <code>async</code>","text":"<p>Callback on game_start message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_game_start(self, sid):\n    \"\"\"\n    Callback on game_start message.\n    \"\"\"\n    await self.emit(\"game_start\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_obstacles","title":"<code>on_obstacles(sid, obstacles)</code>  <code>async</code>","text":"<p>Callback on obstacles message.</p> <p>Receive a list of all obstacles. These obstacles are sent to planner to monitor/dashboards for display.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_obstacles(self, sid, obstacles: list[dict[str, Any]]):\n    \"\"\"\n    Callback on obstacles message.\n\n    Receive a list of all obstacles.\n    These obstacles are sent to planner to monitor/dashboards for display.\n    \"\"\"\n    await self.emit(\"obstacles\", obstacles, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_camp","title":"<code>on_pami_camp(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_camp message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_camp(self, sid, data):\n    \"\"\"\n    Callback on pami_camp message.\n    \"\"\"\n    await self.emit(\"pami_camp\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_play","title":"<code>on_pami_play(sid)</code>  <code>async</code>","text":"<p>Callback on pami_play message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_play(self, sid):\n    \"\"\"\n    Callback on pami_play message.\n    \"\"\"\n    await self.emit(\"pami_play\", namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_reset","title":"<code>on_pami_reset(sid)</code>  <code>async</code>","text":"<p>Callback on pami_reset message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_reset(self, sid):\n    \"\"\"\n    Callback on pami_reset message.\n    \"\"\"\n    await self.emit(\"pami_reset\", namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pami_table","title":"<code>on_pami_table(sid, data)</code>  <code>async</code>","text":"<p>Callback on pami_table message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pami_table(self, sid, data):\n    \"\"\"\n    Callback on pami_table message.\n    \"\"\"\n    await self.emit(\"pami_table\", data, namespace=\"/beacon\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_path","title":"<code>on_path(sid, path)</code>  <code>async</code>","text":"<p>Callback on robot path. Forward the path to dashboard.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_path(self, sid, path: list[dict[str, float]]):\n    \"\"\"\n    Callback on robot path.\n    Forward the path to dashboard.\n    \"\"\"\n    await self.emit(\"path\", (self.context.robot_id, path), namespace=\"/dashboard\")\n    await self.recorder.async_record({\"pose_order\": path})\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pose_order","title":"<code>on_pose_order(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose order. Forward to pose to copilot and dashboards.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pose_order(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose order.\n    Forward to pose to copilot and dashboards.\n    \"\"\"\n    await self.emit(\"pose_order\", pose, namespace=\"/copilot\")\n    await self.emit(\"pose_order\", (self.context.robot_id, pose), namespace=\"/dashboard\")\n    await self.recorder.async_record({\"pose_order\": pose})\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_pose_start","title":"<code>on_pose_start(sid, pose)</code>  <code>async</code>","text":"<p>Callback on pose start. Forward to pose to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_pose_start(self, sid, pose: dict[str, Any]):\n    \"\"\"\n    Callback on pose start.\n    Forward to pose to copilot.\n    \"\"\"\n    await self.emit(\"pose_start\", pose, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_register_menu","title":"<code>on_register_menu(sid, data)</code>  <code>async</code>","text":"<p>Callback on register_menu.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_register_menu(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on register_menu.\n    \"\"\"\n    await self.cogip_server.register_menu(\"planner\", data)\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_robot_end","title":"<code>on_robot_end(sid)</code>  <code>async</code>","text":"<p>Callback on robot_end message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_robot_end(self, sid):\n    \"\"\"\n    Callback on robot_end message.\n    \"\"\"\n    await self.emit(\"game_end\", namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_score","title":"<code>on_score(sid, score)</code>  <code>async</code>","text":"<p>Callback on score message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_score(self, sid, score: int):\n    \"\"\"\n    Callback on score message.\n    \"\"\"\n    await self.emit(\"score\", score, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_set_controller","title":"<code>on_set_controller(sid, controller)</code>  <code>async</code>","text":"<p>Callback on set_controller message. Forward to copilot.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_set_controller(self, sid, controller: int):\n    \"\"\"\n    Callback on set_controller message.\n    Forward to copilot.\n    \"\"\"\n    await self.emit(\"set_controller\", controller, namespace=\"/copilot\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_start_video_record","title":"<code>on_start_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on start_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_start_video_record(self, sid):\n    \"\"\"\n    Callback on start_video_record message.\n    \"\"\"\n    await self.emit(\"start_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_starter_changed","title":"<code>on_starter_changed(sid, pushed)</code>  <code>async</code>","text":"<p>Callback on starter_pushed message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_starter_changed(self, sid, pushed: bool):\n    \"\"\"\n    Callback on starter_pushed message.\n    \"\"\"\n    await self.emit(\"starter_changed\", (self.context.robot_id, pushed), namespace=\"/monitor\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_stop_video_record","title":"<code>on_stop_video_record(sid)</code>  <code>async</code>","text":"<p>Callback on stop_video_record message.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_stop_video_record(self, sid):\n    \"\"\"\n    Callback on stop_video_record message.\n    \"\"\"\n    await self.emit(\"stop_video_record\", namespace=\"/robotcam\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/planner/#cogip.tools.server.namespaces.planner.PlannerNamespace.on_wizard","title":"<code>on_wizard(sid, message)</code>  <code>async</code>","text":"<p>Callback on wizard message. Forward to dashboard.</p> Source code in <code>cogip/tools/server/namespaces/planner.py</code> <pre><code>async def on_wizard(self, sid, message: list[dict[str, Any]]):\n    \"\"\"\n    Callback on wizard message.\n    Forward to dashboard.\n    \"\"\"\n    message[\"namespace\"] = \"/planner\"\n    await self.emit(\"wizard\", message, namespace=\"/dashboard\")\n</code></pre>"},{"location":"reference/cogip/tools/server/namespaces/robotcam/","title":"robotcam","text":""},{"location":"reference/cogip/tools/server/namespaces/robotcam/#cogip.tools.server.namespaces.robotcam.RobotcamNamespace","title":"<code>RobotcamNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to robotcam.</p> Source code in <code>cogip/tools/server/namespaces/robotcam.py</code> <pre><code>class RobotcamNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to robotcam.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/robotcam\")\n        self.cogip_server = cogip_server\n        self.context = Context()\n        self.context.robotcam_sid = None\n\n    async def on_connect(self, sid, environ):\n        if self.context.robotcam_sid:\n            message = \"A robotcam is already connected\"\n            logger.error(f\"Robotcam connection refused: {message}\")\n            raise ConnectionRefusedError(message)\n        self.context.robotcam_sid = sid\n\n    async def on_connected(self, sid):\n        logger.info(\"Robotcam connected.\")\n\n    def on_disconnect(self, sid):\n        self.context.robotcam_sid = None\n        logger.info(\"Robotcam disconnected.\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/__main__/","title":"__main__","text":""},{"location":"reference/cogip/tools/server_beacon/__main__/#cogip.tools.server_beacon.__main__.main","title":"<code>main()</code>","text":"<p>Launch COGIP SocketIO beacon server.</p> <p>During installation of cogip-tools, <code>setuptools</code> is configured to create the <code>cogip-server-beacon</code> script using this function as entrypoint.</p> Source code in <code>cogip/tools/server_beacon/__main__.py</code> <pre><code>def main():\n    \"\"\"\n    Launch COGIP SocketIO beacon server.\n\n    During installation of cogip-tools, `setuptools` is configured\n    to create the `cogip-server-beacon` script using this function as entrypoint.\n    \"\"\"\n    typer.run(main_opt)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/app/","title":"app","text":""},{"location":"reference/cogip/tools/server_beacon/app/#cogip.tools.server_beacon.app.create_app","title":"<code>create_app()</code>","text":"<p>Create server and return FastAPI application for uvicorn/gunicorn.</p> Source code in <code>cogip/tools/server_beacon/app.py</code> <pre><code>def create_app() -&gt; FastAPI:\n    \"\"\"\n    Create server and return FastAPI application for uvicorn/gunicorn.\n    \"\"\"\n    server = Server()\n    return server.app\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/menu/","title":"menu","text":""},{"location":"reference/cogip/tools/server_beacon/robot/","title":"robot","text":""},{"location":"reference/cogip/tools/server_beacon/server/","title":"server","text":""},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server","title":"<code>Server</code>","text":"Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>class Server:\n    original_uvicorn_exit_handler = UvicornServer.handle_exit\n    exiting: bool = False\n    robots: dict[int, Robot] = {}\n    robot_tasks: set[asyncio.Task] = set()\n\n    def __init__(self):\n        \"\"\"\n        Class constructor.\n\n        Create SocketIO server and robot servers connections\n        \"\"\"\n        UvicornServer.handle_exit = Server.handle_exit\n\n        self.sio = socketio.AsyncServer(\n            always_connect=False,\n            async_mode=\"asgi\",\n            cors_allowed_origins=\"*\",\n            logger=False,\n            engineio_logger=False,\n        )\n        self.app = socketio.ASGIApp(self.sio)\n        self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n        self.camp = Camp.Colors.yellow\n        self.table = TableEnum.Game\n\n        for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n            robot = Robot(self, i)\n            task = asyncio.create_task(robot.run())\n            Server.robots[i] = robot\n            Server.robot_tasks.add(task)\n            task.add_done_callback(Server.robot_tasks.discard)\n\n        @self.sio.event\n        def connect(sid, environ, auth):\n            logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n            raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n        @self.sio.on(\"*\")\n        def catch_all(event, sid, data):\n            logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n\n    @staticmethod\n    def handle_exit(*args, **kwargs):\n        \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n        Server.exiting = True\n        for _, robot in Server.robots.items():\n            robot.exiting = True\n            robot.sio.reconnection_attempts = -1\n        for task in Server.robot_tasks:\n            task.cancel()\n\n        Server.original_uvicorn_exit_handler(*args, **kwargs)\n\n    async def choose_camp(self):\n        \"\"\"\n        Choose camp command from the menu.\n        Send camp wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Camp\",\n                \"type\": \"camp\",\n                \"value\": self.camp.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def choose_table(self):\n        \"\"\"\n        Choose table command from the menu.\n        Send table wizard message.\n        \"\"\"\n        await self.sio.emit(\n            \"wizard\",\n            {\n                \"name\": \"Choose Table\",\n                \"type\": \"choice_str\",\n                \"choices\": [e.name for e in TableEnum],\n                \"value\": self.table.name,\n            },\n            namespace=\"/dashboard\",\n        )\n\n    async def reset_robots(self):\n        for robot_id, robot in self.robots.items():\n            if robot.sio.connected:\n                position: StartPosition | None = None\n                match robot_id:\n                    case 1:\n                        position = StartPosition.Bottom\n                    case 2:\n                        position = StartPosition.PAMI2\n                    case 3:\n                        position = StartPosition.PAMI3\n                    case 4:\n                        position = StartPosition.PAMI4\n                if position:\n                    await robot.sio.emit(\n                        \"wizard\",\n                        {\n                            \"name\": \"Choose Start Position\",\n                            \"value\": position.name,\n                        },\n                        namespace=\"/beacon\",\n                    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.__init__","title":"<code>__init__()</code>","text":"<p>Class constructor.</p> <p>Create SocketIO server and robot servers connections</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Class constructor.\n\n    Create SocketIO server and robot servers connections\n    \"\"\"\n    UvicornServer.handle_exit = Server.handle_exit\n\n    self.sio = socketio.AsyncServer(\n        always_connect=False,\n        async_mode=\"asgi\",\n        cors_allowed_origins=\"*\",\n        logger=False,\n        engineio_logger=False,\n    )\n    self.app = socketio.ASGIApp(self.sio)\n    self.sio.register_namespace(namespaces.DashboardNamespace(self))\n\n    self.camp = Camp.Colors.yellow\n    self.table = TableEnum.Game\n\n    for i in range(1, int(os.environ[\"SERVER_BEACON_MAX_ROBOTS\"]) + 1):\n        robot = Robot(self, i)\n        task = asyncio.create_task(robot.run())\n        Server.robots[i] = robot\n        Server.robot_tasks.add(task)\n        task.add_done_callback(Server.robot_tasks.discard)\n\n    @self.sio.event\n    def connect(sid, environ, auth):\n        logger.warning(f\"A client tried to connect to namespace / (sid={sid})\")\n        raise ConnectionRefusedError(\"Connection refused to namespace /\")\n\n    @self.sio.on(\"*\")\n    def catch_all(event, sid, data):\n        logger.warning(f\"A client tried to send data to namespace / (sid={sid}, event={event})\")\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_camp","title":"<code>choose_camp()</code>  <code>async</code>","text":"<p>Choose camp command from the menu. Send camp wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_camp(self):\n    \"\"\"\n    Choose camp command from the menu.\n    Send camp wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Camp\",\n            \"type\": \"camp\",\n            \"value\": self.camp.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.choose_table","title":"<code>choose_table()</code>  <code>async</code>","text":"<p>Choose table command from the menu. Send table wizard message.</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>async def choose_table(self):\n    \"\"\"\n    Choose table command from the menu.\n    Send table wizard message.\n    \"\"\"\n    await self.sio.emit(\n        \"wizard\",\n        {\n            \"name\": \"Choose Table\",\n            \"type\": \"choice_str\",\n            \"choices\": [e.name for e in TableEnum],\n            \"value\": self.table.name,\n        },\n        namespace=\"/dashboard\",\n    )\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/server/#cogip.tools.server_beacon.server.Server.handle_exit","title":"<code>handle_exit(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Overload function for Uvicorn handle_exit</p> Source code in <code>cogip/tools/server_beacon/server.py</code> <pre><code>@staticmethod\ndef handle_exit(*args, **kwargs):\n    \"\"\"Overload function for Uvicorn handle_exit\"\"\"\n    Server.exiting = True\n    for _, robot in Server.robots.items():\n        robot.exiting = True\n        robot.sio.reconnection_attempts = -1\n    for task in Server.robot_tasks:\n        task.cancel()\n\n    Server.original_uvicorn_exit_handler(*args, **kwargs)\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/","title":"dashboard","text":""},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace","title":"<code>DashboardNamespace</code>","text":"<p>               Bases: <code>AsyncNamespace</code></p> <p>Handle all SocketIO events related to Beacon dashboard.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>class DashboardNamespace(socketio.AsyncNamespace):\n    \"\"\"\n    Handle all SocketIO events related to Beacon dashboard.\n    \"\"\"\n\n    def __init__(self, cogip_server: \"server.Server\"):\n        super().__init__(\"/dashboard\")\n        self.cogip_server = cogip_server\n\n    def on_connect(self, sid, environ):\n        pass\n\n    async def on_connected(self, sid):\n        logger.info(\"Dashboard connected.\")\n        for robot_id, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await self.cogip_server.sio.emit(\"add_robot\", robot_id, namespace=\"/dashboard\")\n        await self.emit(\n            \"tool_menu\",\n            menu.model_dump(),\n            namespace=\"/dashboard\",\n        )\n\n    def on_disconnect(self, sid):\n        logger.info(\"Dashboard disconnected.\")\n\n    async def on_tool_cmd(self, sid, cmd: str):\n        match cmd:\n            case \"choose_camp\":\n                await self.cogip_server.choose_camp()\n            case \"choose_table\":\n                await self.cogip_server.choose_table()\n            case \"reset\":\n                await self.cogip_server.reset_robots()\n            case \"start\":\n                for _, robot in self.cogip_server.robots.items():\n                    if robot.sio.connected:\n                        await robot.sio.emit(\"command\", \"play\", namespace=\"/beacon\")\n            case _:\n                logger.warning(f\"Unknown command: {cmd}\")\n\n    async def on_wizard(self, sid, data: dict[str, Any]):\n        \"\"\"\n        Callback on wizard message.\n        \"\"\"\n        for _, robot in self.cogip_server.robots.items():\n            if robot.sio.connected:\n                await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n        await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n        match data.get(\"name\"):\n            case \"Choose Camp\":\n                self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n            case \"Choose Table\":\n                self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/tools/server_beacon/namespaces/dashboard/#cogip.tools.server_beacon.namespaces.dashboard.DashboardNamespace.on_wizard","title":"<code>on_wizard(sid, data)</code>  <code>async</code>","text":"<p>Callback on wizard message.</p> Source code in <code>cogip/tools/server_beacon/namespaces/dashboard.py</code> <pre><code>async def on_wizard(self, sid, data: dict[str, Any]):\n    \"\"\"\n    Callback on wizard message.\n    \"\"\"\n    for _, robot in self.cogip_server.robots.items():\n        if robot.sio.connected:\n            await robot.sio.emit(\"wizard\", data, namespace=\"/beacon\")\n    await self.cogip_server.sio.emit(\"close_wizard\", namespace=\"/dashboard\")\n\n    match data.get(\"name\"):\n        case \"Choose Camp\":\n            self.cogip_server.camp = Camp.Colors[data[\"value\"]]\n        case \"Choose Table\":\n            self.cogip_server.table = TableEnum[data[\"value\"]]\n</code></pre>"},{"location":"reference/cogip/utils/argenum/","title":"argenum","text":""},{"location":"reference/cogip/utils/argenum/#cogip.utils.argenum.ArgEnum","title":"<code>ArgEnum</code>","text":"<p>               Bases: <code>Enum</code></p> <p>This base class can be used to define Enum argument for Typer. It allows to use the Enum name of the enum in the command line arguments instead the Enum value. To get the Enum name, use <code>ArgEnum.val</code> property instead of <code>ArgEnum.value</code>.</p> <p>This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085. There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.</p> Source code in <code>cogip/utils/argenum.py</code> <pre><code>class ArgEnum(Enum):\n    \"\"\"\n    This base class can be used to define Enum argument for Typer.\n    It allows to use the Enum name of the enum in the command line arguments instead the Enum value.\n    To get the Enum name, use `ArgEnum.val` property instead of `ArgEnum.value`.\n\n    This workaround is explained here: https://github.com/tiangolo/typer/issues/151#issuecomment-1755370085.\n    There is a pending merge request here: https://github.com/tiangolo/typer/pull/224.\n    \"\"\"\n\n    def __init__(self, val):\n        self.val = val\n\n    @property\n    def value(self):\n        return self.name\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/","title":"asyncloop","text":""},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop","title":"<code>AsyncLoop</code>","text":"<p>This class creates a async task to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>class AsyncLoop:\n    \"\"\"\n    This class creates a async task to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self.interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n        self._task: asyncio.Task | None = None\n        self.exit: bool = False\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.DEBUG)\n                else:\n                    self._logger.setLevel(logging.INFO)\n\n    async def task(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the task.\n        \"\"\"\n        self._logger.info(\"Task started\")\n\n        try:\n            while not self.exit:\n                start = time.time()\n                await self._func(*self._args, **self._kwargs)\n                now = time.time()\n                duration = now - start\n                if duration &gt; self.interval:\n                    self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n                else:\n                    wait = self.interval - duration\n                    await asyncio.sleep(wait)\n        except asyncio.CancelledError:\n            self._logger.info(\"Task cancelled\")\n            raise\n\n    def start(self):\n        if self._task:\n            self._logger.warning(\"Already started\")\n            return\n\n        self.exit = False\n        self._task = asyncio.create_task(self.task(), name=self._name)\n\n    async def stop(self):\n        if not self._task:\n            self._logger.warning(\"Not running\")\n            return\n\n        self._task.cancel()\n        try:\n            await self._task\n        except asyncio.CancelledError:\n            self._logger.info(\"Task cancelled\")\n\n        self._task = None\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self.interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._logger = logging.getLogger(f\"AsyncLoop: {name}\")\n    self._task: asyncio.Task | None = None\n    self.exit: bool = False\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.DEBUG)\n            else:\n                self._logger.setLevel(logging.INFO)\n</code></pre>"},{"location":"reference/cogip/utils/asyncloop/#cogip.utils.asyncloop.AsyncLoop.task","title":"<code>task()</code>  <code>async</code>","text":"<p>Loop function executed in the task.</p> Source code in <code>cogip/utils/asyncloop.py</code> <pre><code>async def task(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the task.\n    \"\"\"\n    self._logger.info(\"Task started\")\n\n    try:\n        while not self.exit:\n            start = time.time()\n            await self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if duration &gt; self.interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self.interval}\")\n            else:\n                wait = self.interval - duration\n                await asyncio.sleep(wait)\n    except asyncio.CancelledError:\n        self._logger.info(\"Task cancelled\")\n        raise\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/","title":"lidartablemodel","text":""},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel","title":"<code>LidarTableModel</code>","text":"<p>               Bases: <code>QAbstractTableModel</code></p> <p>Model class providing access to data to update the table view.</p> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>class LidarTableModel(QtCore.QAbstractTableModel):\n    \"\"\"\n    Model class providing access to data to update the table view.\n    \"\"\"\n\n    headers = [\"Angle\", \"Distance\", \"Intensity\"]\n\n    def __init__(\n        self,\n        angle_values: list[float],\n        distance_values: list[int],\n        intensity_values: list[int],\n        distance_color: QtGui.QColor,\n        intensity_color: QtGui.QColor,\n        nb_angles: int = 360,\n    ):\n        \"\"\"Class constructor\n\n        Arguments:\n            angle_values: angle values list\n            distance_values: distance values list\n            intensity_values: intensity values list\n            distance_color: distance color\n            intensity_color: intensity color\n            nb_angles: number of angles\n        \"\"\"\n        super().__init__()\n        self.angle_values = angle_values\n        self.distance_values = distance_values\n        self.intensity_values = intensity_values\n        self.distance_color = distance_color\n        self.intensity_color = intensity_color\n        self.nb_angles = nb_angles\n\n    def rowCount(self, parent):\n        return self.nb_angles\n\n    def columnCount(self, parent):\n        return 3\n\n    def data(self, index, role):\n        row, column = index.row(), index.column()\n\n        if role == QtCore.Qt.BackgroundRole:\n            if column == 0:\n                return QtGui.QColor(\"lightgray\")\n            if column == 1:\n                return self.distance_color\n            if column == 2:\n                return self.intensity_color\n            return None\n\n        if role == QtCore.Qt.TextAlignmentRole:\n            return QtCore.Qt.AlignRight\n\n        if role == QtCore.Qt.DisplayRole:\n            if column == 0:\n                return self.angle_values[row]\n            if column == 1:\n                return self.distance_values[row]\n            if column == 2:\n                return self.intensity_values[row]\n            return None\n\n        return None\n\n    def headerData(self, section, orientation, role):\n        if role == QtCore.Qt.BackgroundRole:\n            return QtGui.QColor(\"lightgray\")\n\n        if role == QtCore.Qt.FontRole:\n            font = QtWidgets.QApplication.font()\n            font.setPointSize(font.pointSize() - 2)\n            return font\n\n        if role != QtCore.Qt.DisplayRole or orientation != QtCore.Qt.Horizontal:\n            return None\n        return self.headers[section]\n</code></pre>"},{"location":"reference/cogip/utils/lidartablemodel/#cogip.utils.lidartablemodel.LidarTableModel.__init__","title":"<code>__init__(angle_values, distance_values, intensity_values, distance_color, intensity_color, nb_angles=360)</code>","text":"<p>Class constructor</p> <p>Parameters:</p> Name Type Description Default <code>angle_values</code> <code>list[float]</code> <p>angle values list</p> required <code>distance_values</code> <code>list[int]</code> <p>distance values list</p> required <code>intensity_values</code> <code>list[int]</code> <p>intensity values list</p> required <code>distance_color</code> <code>QColor</code> <p>distance color</p> required <code>intensity_color</code> <code>QColor</code> <p>intensity color</p> required <code>nb_angles</code> <code>int</code> <p>number of angles</p> <code>360</code> Source code in <code>cogip/utils/lidartablemodel.py</code> <pre><code>def __init__(\n    self,\n    angle_values: list[float],\n    distance_values: list[int],\n    intensity_values: list[int],\n    distance_color: QtGui.QColor,\n    intensity_color: QtGui.QColor,\n    nb_angles: int = 360,\n):\n    \"\"\"Class constructor\n\n    Arguments:\n        angle_values: angle values list\n        distance_values: distance values list\n        intensity_values: intensity values list\n        distance_color: distance color\n        intensity_color: intensity color\n        nb_angles: number of angles\n    \"\"\"\n    super().__init__()\n    self.angle_values = angle_values\n    self.distance_values = distance_values\n    self.intensity_values = intensity_values\n    self.distance_color = distance_color\n    self.intensity_color = intensity_color\n    self.nb_angles = nb_angles\n</code></pre>"},{"location":"reference/cogip/utils/singleton/","title":"singleton","text":""},{"location":"reference/cogip/utils/singleton/#cogip.utils.singleton.Singleton","title":"<code>Singleton</code>","text":"<p>               Bases: <code>type</code></p> <p>Meta class used to declare singleton</p> <p>Example:</p> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Data(metaclass=Singleton):\n    name: str = \"\"\n\n\ndata = Data()\nprint(data)            # output: Data(name='')\ndata.name = \"foo\"\nprint(data)            # output: Data(name='foo')\nprint(Data())          # output: Data(name='foo')\nprint(data is Data())  # output: True\n</code></pre> Source code in <code>cogip/utils/singleton.py</code> <pre><code>class Singleton(type):\n    \"\"\"\n    Meta class used to declare singleton\n\n    Example:\n\n        from dataclasses import dataclass\n\n\n        @dataclass\n        class Data(metaclass=Singleton):\n            name: str = \"\"\n\n\n        data = Data()\n        print(data)            # output: Data(name='')\n        data.name = \"foo\"\n        print(data)            # output: Data(name='foo')\n        print(Data())          # output: Data(name='foo')\n        print(data is Data())  # output: True\n    \"\"\"\n\n    _instance = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instance:\n            cls._instance[cls] = super().__call__(*args, **kwargs)\n        return cls._instance[cls]\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/","title":"threadloop","text":""},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop","title":"<code>ThreadLoop</code>","text":"<p>This class creates a thread to execute a function in loop and wait after the function until the defined loop interval is reached. A warning is emitted if the function duration is longer than the loop interval.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>class ThreadLoop:\n    \"\"\"\n    This class creates a thread to execute a function in loop and wait after\n    the function until the defined loop interval is reached.\n    A warning is emitted if the function duration is longer than the loop\n    interval.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        interval: float,\n        func: Callable,\n        logger: bool | logging.Logger = False,\n        args: list[Any] | None = None,\n        kwargs: dict[str, Any] | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: Name to identify the thread in the logs\n            interval: time between each iteration of the loop, in seconds\n            func: function to execute in the loop\n            logger: an optional custom logger\n            args: arguments of the function\n            kwargs: named arguments of the function\n        \"\"\"\n        self._name = name\n        self._interval = interval\n        self._func = func\n        self._args = args or []\n        self._kwargs = kwargs or {}\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n        self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n        if not isinstance(logger, bool):\n            self._logger = logger\n        else:\n            if self._logger.level == logging.NOTSET:\n                if logger:\n                    self._logger.setLevel(logging.INFO)\n                else:\n                    self._logger.setLevel(logging.ERROR)\n                self._logger.addHandler(logging.StreamHandler())\n\n    @property\n    def interval(self) -&gt; float:\n        return self._interval\n\n    @interval.setter\n    def interval(self, value: float) -&gt; None:\n        self._interval = value\n\n    def repeat(self) -&gt; None:\n        \"\"\"\n        Loop function executed in the thread.\n        \"\"\"\n        while not self._cancel:\n            start = time.time()\n            self._func(*self._args, **self._kwargs)\n            now = time.time()\n            duration = now - start\n            if duration &gt; self._interval:\n                self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n            else:\n                wait = self._interval - duration\n                time.sleep(wait)\n\n    def start(self) -&gt; None:\n        \"\"\"\n        Start the thread loop.\n        \"\"\"\n        if self._thread.is_alive():\n            self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n            return\n        if self._cancel:\n            self._thread = threading.Thread(target=self.repeat)\n            self._cancel = False\n        self._thread.start()\n\n    def stop(self) -&gt; None:\n        \"\"\"\n        Stop the thread loop.\n        \"\"\"\n        self._logger.debug(\"Stopping...\")\n        if self._thread.is_alive():\n            self._cancel = True\n            try:\n                self._thread.join()\n            except KeyboardInterrupt:\n                pass\n            self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.__init__","title":"<code>__init__(name, interval, func, logger=False, args=None, kwargs=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to identify the thread in the logs</p> required <code>interval</code> <code>float</code> <p>time between each iteration of the loop, in seconds</p> required <code>func</code> <code>Callable</code> <p>function to execute in the loop</p> required <code>logger</code> <code>bool | Logger</code> <p>an optional custom logger</p> <code>False</code> <code>args</code> <code>list[Any] | None</code> <p>arguments of the function</p> <code>None</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>named arguments of the function</p> <code>None</code> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    interval: float,\n    func: Callable,\n    logger: bool | logging.Logger = False,\n    args: list[Any] | None = None,\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: Name to identify the thread in the logs\n        interval: time between each iteration of the loop, in seconds\n        func: function to execute in the loop\n        logger: an optional custom logger\n        args: arguments of the function\n        kwargs: named arguments of the function\n    \"\"\"\n    self._name = name\n    self._interval = interval\n    self._func = func\n    self._args = args or []\n    self._kwargs = kwargs or {}\n    self._thread = threading.Thread(target=self.repeat)\n    self._cancel = False\n    self._logger = logging.getLogger(f\"ThreadLoop: {name}\")\n\n    if not isinstance(logger, bool):\n        self._logger = logger\n    else:\n        if self._logger.level == logging.NOTSET:\n            if logger:\n                self._logger.setLevel(logging.INFO)\n            else:\n                self._logger.setLevel(logging.ERROR)\n            self._logger.addHandler(logging.StreamHandler())\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.repeat","title":"<code>repeat()</code>","text":"<p>Loop function executed in the thread.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def repeat(self) -&gt; None:\n    \"\"\"\n    Loop function executed in the thread.\n    \"\"\"\n    while not self._cancel:\n        start = time.time()\n        self._func(*self._args, **self._kwargs)\n        now = time.time()\n        duration = now - start\n        if duration &gt; self._interval:\n            self._logger.warning(f\"Function too long: {duration} &gt; {self._interval}\")\n        else:\n            wait = self._interval - duration\n            time.sleep(wait)\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.start","title":"<code>start()</code>","text":"<p>Start the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"\n    Start the thread loop.\n    \"\"\"\n    if self._thread.is_alive():\n        self._logger.warning(f\"Already {'canceled' if self._cancel else 'running'}\")\n        return\n    if self._cancel:\n        self._thread = threading.Thread(target=self.repeat)\n        self._cancel = False\n    self._thread.start()\n</code></pre>"},{"location":"reference/cogip/utils/threadloop/#cogip.utils.threadloop.ThreadLoop.stop","title":"<code>stop()</code>","text":"<p>Stop the thread loop.</p> Source code in <code>cogip/utils/threadloop.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"\n    Stop the thread loop.\n    \"\"\"\n    self._logger.debug(\"Stopping...\")\n    if self._thread.is_alive():\n        self._cancel = True\n        try:\n            self._thread.join()\n        except KeyboardInterrupt:\n            pass\n        self._logger.debug(\"Stopped.\")\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/","title":"actuators","text":""},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ActuatorsDialog","title":"<code>ActuatorsDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>ActuatorsDialog class</p> <p>Build a modal for actuators remote control and monitoring.</p> <p>Attributes:</p> Name Type Description <code>new_actuator_command</code> <code>Signal</code> <p>Qt signal emitted when a actuator command is updated</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>class ActuatorsDialog(QtWidgets.QDialog):\n    \"\"\"\n    ActuatorsDialog class\n\n    Build a modal for actuators remote control and monitoring.\n\n    Attributes:\n        new_actuator_command: Qt signal emitted when a actuator command is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n    new_actuator_command: qtSignal = qtSignal(object)\n\n    def __init__(self, parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.servos: dict[ServoEnum, ServoControl] = {}\n        self.positional_actuators: dict[PositionalActuatorEnum, PositionalActuatorControl] = {}\n        self.bool_sensors: dict[BoolSensorEnum, BoolSensorControl] = {}\n        self.setWindowTitle(\"Actuators Control\")\n        self.setModal(False)\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        for id in ServoEnum:\n            self.servos[id] = ServoControl(id, layout)\n            self.servos[id].command_updated.connect(self.command_updated)\n\n        for id in PositionalActuatorEnum:\n            self.positional_actuators[id] = PositionalActuatorControl(id, layout)\n            self.positional_actuators[id].command_updated.connect(self.command_updated)\n\n        for id in BoolSensorEnum:\n            self.bool_sensors[id] = BoolSensorControl(id, layout)\n\n        self.readSettings()\n\n    def update_actuator(self, actuator_state: ActuatorState):\n        \"\"\"\n        Update an actuator with new values.\n\n        Arguments:\n            actuator_state: current state of an actuator\n        \"\"\"\n\n        match actuator_state.kind:\n            case ActuatorsKindEnum.servo:\n                actuator = self.servos.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown servo ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n            case ActuatorsKindEnum.positional_actuator:\n                actuator = self.positional_actuators.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown positional actuator ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n            case ActuatorsKindEnum.bool_sensor:\n                actuator = self.bool_sensors.get(actuator_state.id)\n                if actuator is None:\n                    logger.warning(f\"Unknown bool sensor ID: {actuator_state.id}\")\n                    return\n                actuator.update_value(actuator_state)\n\n    def command_updated(self, command: ActuatorCommand):\n        \"\"\"\n        Emit updated values with namespace, name and value.\n        \"\"\"\n        self.new_actuator_command.emit(command)\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"properties/actuators\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"properties/actuators\"))\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ActuatorsDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.servos: dict[ServoEnum, ServoControl] = {}\n    self.positional_actuators: dict[PositionalActuatorEnum, PositionalActuatorControl] = {}\n    self.bool_sensors: dict[BoolSensorEnum, BoolSensorControl] = {}\n    self.setWindowTitle(\"Actuators Control\")\n    self.setModal(False)\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    for id in ServoEnum:\n        self.servos[id] = ServoControl(id, layout)\n        self.servos[id].command_updated.connect(self.command_updated)\n\n    for id in PositionalActuatorEnum:\n        self.positional_actuators[id] = PositionalActuatorControl(id, layout)\n        self.positional_actuators[id].command_updated.connect(self.command_updated)\n\n    for id in BoolSensorEnum:\n        self.bool_sensors[id] = BoolSensorControl(id, layout)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ActuatorsDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"properties/actuators\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ActuatorsDialog.command_updated","title":"<code>command_updated(command)</code>","text":"<p>Emit updated values with namespace, name and value.</p> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def command_updated(self, command: ActuatorCommand):\n    \"\"\"\n    Emit updated values with namespace, name and value.\n    \"\"\"\n    self.new_actuator_command.emit(command)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ActuatorsDialog.update_actuator","title":"<code>update_actuator(actuator_state)</code>","text":"<p>Update an actuator with new values.</p> <p>Parameters:</p> Name Type Description Default <code>actuator_state</code> <code>ActuatorState</code> <p>current state of an actuator</p> required Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def update_actuator(self, actuator_state: ActuatorState):\n    \"\"\"\n    Update an actuator with new values.\n\n    Arguments:\n        actuator_state: current state of an actuator\n    \"\"\"\n\n    match actuator_state.kind:\n        case ActuatorsKindEnum.servo:\n            actuator = self.servos.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown servo ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n        case ActuatorsKindEnum.positional_actuator:\n            actuator = self.positional_actuators.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown positional actuator ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n        case ActuatorsKindEnum.bool_sensor:\n            actuator = self.bool_sensors.get(actuator_state.id)\n            if actuator is None:\n                logger.warning(f\"Unknown bool sensor ID: {actuator_state.id}\")\n                return\n            actuator.update_value(actuator_state)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.BoolSensorControl","title":"<code>BoolSensorControl</code>","text":"<p>               Bases: <code>QObject</code></p> <p>BoolSensorControl class.</p> <p>Build a widget to show the state of a bool  sensor.</p> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>class BoolSensorControl(QtCore.QObject):\n    \"\"\"\n    BoolSensorControl class.\n\n    Build a widget to show the state of a bool  sensor.\n    \"\"\"\n\n    def __init__(self, id: BoolSensorEnum, layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            id: ID of bool sensor to display\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self.enabled = False\n        self.id = id\n\n        row = layout.rowCount()\n\n        self.label = QtWidgets.QLabel(self.id.name)\n        layout.addWidget(self.label, row, 0)\n\n        self.kind = QtWidgets.QLabel(\"Bool Sensor\")\n        layout.addWidget(self.kind, row, 1)\n\n        self.state = QtWidgets.QCheckBox()\n        self.state.setToolTip(\"State\")\n        self.state.setAttribute(QtCore.Qt.WidgetAttribute.WA_TransparentForMouseEvents)\n        self.state.setFocusPolicy(QtCore.Qt.NoFocus)\n        self.state.setChecked(False)\n        layout.addWidget(self.state, row, 2)\n\n        self.label.setEnabled(False)\n        self.kind.setEnabled(False)\n        self.state.setEnabled(False)\n\n    def update_value(self, actuator: BoolSensor):\n        if not self.enabled:\n            self.enabled = True\n            self.label.setEnabled(True)\n            self.kind.setEnabled(True)\n            self.state.setEnabled(True)\n\n        self.state.setChecked(actuator.state)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.BoolSensorControl.__init__","title":"<code>__init__(id, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>BoolSensorEnum</code> <p>ID of bool sensor to display</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def __init__(self, id: BoolSensorEnum, layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        id: ID of bool sensor to display\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self.enabled = False\n    self.id = id\n\n    row = layout.rowCount()\n\n    self.label = QtWidgets.QLabel(self.id.name)\n    layout.addWidget(self.label, row, 0)\n\n    self.kind = QtWidgets.QLabel(\"Bool Sensor\")\n    layout.addWidget(self.kind, row, 1)\n\n    self.state = QtWidgets.QCheckBox()\n    self.state.setToolTip(\"State\")\n    self.state.setAttribute(QtCore.Qt.WidgetAttribute.WA_TransparentForMouseEvents)\n    self.state.setFocusPolicy(QtCore.Qt.NoFocus)\n    self.state.setChecked(False)\n    layout.addWidget(self.state, row, 2)\n\n    self.label.setEnabled(False)\n    self.kind.setEnabled(False)\n    self.state.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.PositionalActuatorControl","title":"<code>PositionalActuatorControl</code>","text":"<p>               Bases: <code>QObject</code></p> <p>PositionalControl class.</p> <p>Build a widget to control a positional actuator.</p> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>class PositionalActuatorControl(QtCore.QObject):\n    \"\"\"\n    PositionalControl class.\n\n    Build a widget to control a positional actuator.\n    \"\"\"\n\n    command_updated: qtSignal = qtSignal(object)\n\n    def __init__(self, id: PositionalActuatorEnum, layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            id: ID of positional actuator to control\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self.enabled = False\n        command_schema = Servo.model_json_schema()[\"properties\"][\"command\"]\n        self.id = id\n\n        row = layout.rowCount()\n        minimum, maximum = actuator_limits.get(id, (command_schema.get(\"minimum\"), command_schema.get(\"maximum\")))\n\n        self.label = QtWidgets.QLabel(self.id.name)\n        layout.addWidget(self.label, row, 0)\n\n        self.kind = QtWidgets.QLabel(\"Positional\")\n        layout.addWidget(self.kind, row, 1)\n\n        self.command = QtWidgets.QSpinBox()\n        self.command.setToolTip(\"Position command\")\n        self.command.setMinimum(minimum)\n        self.command.setMaximum(maximum)\n        self.command.setSingleStep(1)\n        self.command.valueChanged.connect(self.command_changed)\n        layout.addWidget(self.command, row, 2)\n\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.slider.setToolTip(\"Position command\")\n        self.slider.setMinimum(minimum)\n        self.slider.setMaximum(maximum)\n        self.slider.setSingleStep(1)\n        self.slider.valueChanged.connect(self.command.setValue)\n        layout.addWidget(self.slider, row, 3)\n\n        self.position = QtWidgets.QLabel()\n        self.position.setToolTip(\"Current command\")\n        layout.addWidget(self.position, row, 4)\n\n        self.label.setEnabled(False)\n        self.kind.setEnabled(False)\n        self.command.setEnabled(False)\n        self.slider.setEnabled(False)\n        self.position.setEnabled(False)\n\n    def command_changed(self, value):\n        self.slider.setValue(value)\n        command = PositionalActuatorCommand(id=self.id, command=value)\n        self.command_updated.emit(command)\n\n    def update_value(self, actuator: PositionalActuator):\n        if not self.enabled:\n            self.enabled = True\n            self.label.setEnabled(True)\n            self.kind.setEnabled(True)\n            self.command.setEnabled(True)\n            self.slider.setEnabled(True)\n            self.position.setEnabled(True)\n\n        self.command.blockSignals(True)\n        self.command.setValue(actuator.command)\n        self.command.blockSignals(False)\n        self.slider.blockSignals(True)\n        self.slider.setValue(actuator.command)\n        self.slider.blockSignals(False)\n        self.position.setText(str(actuator.command))\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.PositionalActuatorControl.__init__","title":"<code>__init__(id, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>PositionalActuatorEnum</code> <p>ID of positional actuator to control</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def __init__(self, id: PositionalActuatorEnum, layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        id: ID of positional actuator to control\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self.enabled = False\n    command_schema = Servo.model_json_schema()[\"properties\"][\"command\"]\n    self.id = id\n\n    row = layout.rowCount()\n    minimum, maximum = actuator_limits.get(id, (command_schema.get(\"minimum\"), command_schema.get(\"maximum\")))\n\n    self.label = QtWidgets.QLabel(self.id.name)\n    layout.addWidget(self.label, row, 0)\n\n    self.kind = QtWidgets.QLabel(\"Positional\")\n    layout.addWidget(self.kind, row, 1)\n\n    self.command = QtWidgets.QSpinBox()\n    self.command.setToolTip(\"Position command\")\n    self.command.setMinimum(minimum)\n    self.command.setMaximum(maximum)\n    self.command.setSingleStep(1)\n    self.command.valueChanged.connect(self.command_changed)\n    layout.addWidget(self.command, row, 2)\n\n    self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n    self.slider.setToolTip(\"Position command\")\n    self.slider.setMinimum(minimum)\n    self.slider.setMaximum(maximum)\n    self.slider.setSingleStep(1)\n    self.slider.valueChanged.connect(self.command.setValue)\n    layout.addWidget(self.slider, row, 3)\n\n    self.position = QtWidgets.QLabel()\n    self.position.setToolTip(\"Current command\")\n    layout.addWidget(self.position, row, 4)\n\n    self.label.setEnabled(False)\n    self.kind.setEnabled(False)\n    self.command.setEnabled(False)\n    self.slider.setEnabled(False)\n    self.position.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ServoControl","title":"<code>ServoControl</code>","text":"<p>               Bases: <code>QObject</code></p> <p>ServoControl class.</p> <p>Build a widget to control a servo.</p> Source code in <code>cogip/widgets/actuators.py</code> <pre><code>class ServoControl(QtCore.QObject):\n    \"\"\"\n    ServoControl class.\n\n    Build a widget to control a servo.\n    \"\"\"\n\n    command_updated: qtSignal = qtSignal(object)\n\n    def __init__(self, id: ServoEnum, layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            id: ID of servo to control\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self.enabled = False\n        position_schema = Servo.model_json_schema()[\"properties\"][\"position\"]\n        self.id = id\n\n        row = layout.rowCount()\n        minimum, maximum = actuator_limits.get(id, (position_schema.get(\"minimum\"), position_schema.get(\"maximum\")))\n\n        self.label = QtWidgets.QLabel(self.id.name)\n        layout.addWidget(self.label, row, 0)\n\n        self.kind = QtWidgets.QLabel(\"Servo\")\n        layout.addWidget(self.kind, row, 1)\n\n        self.command = QtWidgets.QSpinBox()\n        self.command.setToolTip(\"Position command\")\n        self.command.setMinimum(minimum)\n        self.command.setMaximum(maximum)\n        self.command.setSingleStep(1)\n        self.command.valueChanged.connect(self.command_changed)\n        layout.addWidget(self.command, row, 2)\n\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self.slider.setToolTip(\"Position command\")\n        self.slider.setMinimum(minimum)\n        self.slider.setMaximum(maximum)\n        self.slider.setSingleStep(1)\n        self.slider.valueChanged.connect(self.command.setValue)\n        layout.addWidget(self.slider, row, 3)\n\n        self.position = QtWidgets.QLabel()\n        self.position.setToolTip(\"Current position\")\n        layout.addWidget(self.position, row, 4)\n\n        self.label.setEnabled(False)\n        self.kind.setEnabled(False)\n        self.command.setEnabled(False)\n        self.slider.setEnabled(False)\n        self.position.setEnabled(False)\n\n    def command_changed(self, value):\n        self.slider.setValue(value)\n        command = ServoCommand(id=self.id, command=value)\n        self.command_updated.emit(command)\n\n    def update_value(self, actuator: Servo):\n        if not self.enabled:\n            self.enabled = True\n            self.label.setEnabled(True)\n            self.kind.setEnabled(True)\n            self.command.setEnabled(True)\n            self.slider.setEnabled(True)\n            self.position.setEnabled(True)\n\n        self.command.blockSignals(True)\n        self.command.setValue(actuator.position)\n        self.command.blockSignals(True)\n        self.slider.blockSignals(False)\n        self.slider.setValue(actuator.command)\n        self.slider.blockSignals(False)\n        self.position.setText(str(actuator.position))\n</code></pre>"},{"location":"reference/cogip/widgets/actuators/#cogip.widgets.actuators.ServoControl.__init__","title":"<code>__init__(id, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>ServoEnum</code> <p>ID of servo to control</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/widgets/actuators.py</code> <pre><code>def __init__(self, id: ServoEnum, layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        id: ID of servo to control\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self.enabled = False\n    position_schema = Servo.model_json_schema()[\"properties\"][\"position\"]\n    self.id = id\n\n    row = layout.rowCount()\n    minimum, maximum = actuator_limits.get(id, (position_schema.get(\"minimum\"), position_schema.get(\"maximum\")))\n\n    self.label = QtWidgets.QLabel(self.id.name)\n    layout.addWidget(self.label, row, 0)\n\n    self.kind = QtWidgets.QLabel(\"Servo\")\n    layout.addWidget(self.kind, row, 1)\n\n    self.command = QtWidgets.QSpinBox()\n    self.command.setToolTip(\"Position command\")\n    self.command.setMinimum(minimum)\n    self.command.setMaximum(maximum)\n    self.command.setSingleStep(1)\n    self.command.valueChanged.connect(self.command_changed)\n    layout.addWidget(self.command, row, 2)\n\n    self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n    self.slider.setToolTip(\"Position command\")\n    self.slider.setMinimum(minimum)\n    self.slider.setMaximum(maximum)\n    self.slider.setSingleStep(1)\n    self.slider.valueChanged.connect(self.command.setValue)\n    layout.addWidget(self.slider, row, 3)\n\n    self.position = QtWidgets.QLabel()\n    self.position.setToolTip(\"Current position\")\n    layout.addWidget(self.position, row, 4)\n\n    self.label.setEnabled(False)\n    self.kind.setEnabled(False)\n    self.command.setEnabled(False)\n    self.slider.setEnabled(False)\n    self.position.setEnabled(False)\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/","title":"chartsview","text":""},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView","title":"<code>ChartView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>ChartsView class</p> <p>Chart widget displaying a graph with a 'current' and an 'order' curve.</p> <p>It features a scrollbar, a zoom slider and a button to save the data in CVS format.</p> <p>The chart is reset after the robot mode has changed from RUNNING to an other value.</p> <p>Attributes:</p> Name Type Description <code>need_reset</code> <code>bool</code> <p>True if the data must be reset on next state</p> <code>slider_events_disabled</code> <code>bool</code> <p>Do not recalculate range if False</p> <code>default_range_max_x</code> <code>float</code> <p>Default max X range value</p> <code>default_range_max_y</code> <code>float</code> <p>Default max Y range value</p> <code>range_max_x</code> <code>float</code> <p>Current max X range value</p> <code>range_max_y</code> <code>float</code> <p>Current max Y range value</p> <code>zoom_max</code> <code>int</code> <p>max zoom value</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>class ChartView(QtWidgets.QWidget):\n    \"\"\"ChartsView class\n\n    Chart widget displaying a graph with a 'current' and an 'order' curve.\n\n    It features a scrollbar, a zoom slider and a button to save the data in CVS format.\n\n    The chart is reset after the robot mode has changed from RUNNING to an other value.\n\n    Attributes:\n        need_reset: True if the data must be reset on next state\n        slider_events_disabled: Do not recalculate range if False\n        default_range_max_x: Default max X range value\n        default_range_max_y: Default max Y range value\n        range_max_x: Current max X range value\n        range_max_y: Current max Y range value\n        zoom_max: max zoom value\n    \"\"\"\n\n    need_reset: bool = False\n    slider_events_disabled: bool = False\n    default_range_max_x: float = 100\n    default_range_max_y: float = 0.5\n    range_max_x: float = default_range_max_x\n    range_max_y: float = default_range_max_y\n    zoom_max: int = 10\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None, name: str | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n            name: Name of the current chart\n        \"\"\"\n        super().__init__(parent)\n        self.name = name\n\n        layout = QtWidgets.QVBoxLayout(self)\n\n        self.chart_view = QtCharts.QChartView()\n        self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n        layout.addWidget(self.chart_view)\n\n        sliders_widget = QtWidgets.QWidget()\n        sliders_layout = QtWidgets.QGridLayout(sliders_widget)\n        sliders_widget.setLayout(sliders_layout)\n        layout.addWidget(sliders_widget)\n\n        self.scrollbar = QtWidgets.QScrollBar(QtCore.Qt.Horizontal)\n        self.scrollbar.setMinimum(1)\n        self.scrollbar.setMaximum(self.default_range_max_x)\n        self.scrollbar.setSliderPosition(25)\n        self.scrollbar.valueChanged.connect(self.slider_changed)\n        sliders_layout.addWidget(self.scrollbar, 0, 0)\n\n        self.zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=60)\n        self.zoom.setMinimum(1)\n        self.zoom.setMaximum(self.zoom_max)\n        self.zoom.setValue(1)\n        self.zoom.valueChanged.connect(self.slider_changed)\n        sliders_layout.addWidget(self.zoom, 1, 0)\n\n        self.save_button = QtWidgets.QPushButton()\n        self.save_button.setIcon(QtGui.QIcon.fromTheme(\"document-save\"))\n        self.save_button.setStatusTip(\"Save values\")\n        self.save_button.clicked.connect(self.save_values)\n        sliders_layout.addWidget(self.save_button, 0, 1, 2, 1)\n\n        self.chart = QtCharts.QChart()\n        self.axis_x = QtCharts.QValueAxis(self)\n        self.axis_y = QtCharts.QValueAxis(self)\n        self.chart.addAxis(self.axis_x, QtCore.Qt.AlignBottom)\n        self.chart.addAxis(self.axis_y, QtCore.Qt.AlignLeft)\n\n        self.serie_current = QtCharts.QLineSeries(name=f\"{self.name} Current\")\n        self.chart.addSeries(self.serie_current)\n        self.serie_current.attachAxis(self.axis_x)\n        self.serie_current.attachAxis(self.axis_y)\n        pen = self.serie_current.pen()\n        pen.setWidth(5)\n        self.serie_current.setPen(pen)\n\n        self.serie_order = QtCharts.QLineSeries(name=f\"{self.name} Order\")\n        self.chart.addSeries(self.serie_order)\n        self.serie_order.attachAxis(self.axis_x)\n        self.serie_order.attachAxis(self.axis_y)\n\n        pen = self.serie_order.pen()\n        pen.setWidth(5)\n        self.serie_order.setPen(pen)\n\n        # self.chart.createDefaultAxes()\n\n        self.axis_x.setMin(1)\n        self.axis_x.setTickInterval(1)\n\n        self.axis_y.setMin(1)\n        self.axis_y.setMax(self.default_range_max_y)\n\n        self.chart_view.setChart(self.chart)\n\n        self.recalculate_range_x()\n\n    @qtSlot(int)\n    def slider_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the scrollbar and zoom has changed.\n        \"\"\"\n        self.recalculate_range_x()\n\n    def recalculate_range_x(self):\n        \"\"\"\n        Given the current zoom and current position of the scrollbar,\n        compute the X min/max range and the slider position.\n        \"\"\"\n        if self.slider_events_disabled:\n            return\n        self.slider_events_disabled = True\n\n        span = int(self.range_max_x / self.zoom.value())\n        span = span + span % 2\n        scroll_min = span / 2\n        scroll_max = self.range_max_x - span / 2\n\n        scroll = self.scrollbar.value()\n        scroll = max(scroll_min, scroll)\n        scroll = min(scroll_max, scroll)\n\n        self.scrollbar.setMinimum(scroll_min)\n        self.scrollbar.setMaximum(scroll_max)\n        self.scrollbar.setValue(scroll)\n\n        self.axis_x.setMax(self.range_max_x)\n\n        span = int(self.range_max_x / self.zoom.sliderPosition())\n        span = span + span % 2\n\n        x_min = scroll - span / 2\n        x_max = scroll + span / 2\n        self.axis_x.setRange(x_min, x_max)\n\n        self.slider_events_disabled = False\n\n    def reset(self):\n        \"\"\"\n        Reset the chart\n        \"\"\"\n        self.serie_current.clear()\n        self.serie_order.clear()\n\n        self.range_max_x = self.default_range_max_x\n        self.range_max_y = self.default_range_max_y\n\n        self.recalculate_range_x()\n\n    def new_robot_state(self, cycle: int, current: float | None, order: float | None) -&gt; None:\n        \"\"\"\n        Add a new point on the chart view.\n\n        Arguments:\n            cycle: Current cycle\n            current: Current value\n            order: Order value\n        \"\"\"\n        if self.need_reset:\n            self.need_reset = False\n            self.reset()\n\n        self.range_max_x = max(self.range_max_x, cycle)\n\n        if current:\n            self.serie_current.append(cycle, current)\n            self.range_max_y = max(self.range_max_y, current)\n\n        if order:\n            self.serie_order.append(cycle, order)\n            self.range_max_y = max(self.range_max_y, order)\n\n        self.axis_y.setMax(self.range_max_y)\n\n        self.recalculate_range_x()\n\n    @qtSlot()\n    def save_values(self):\n        \"\"\"\n        Qt Slot\n\n        Open a file dialog to select a file and save chart values in it.\n        \"\"\"\n        filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n            parent=self,\n            caption=f\"Select file to save {self.name} values\",\n            dir=\"\",\n            filter=\"CSV Files (*.csv)\",\n            # Workaround a know Qt bug\n            options=QtWidgets.QFileDialog.DontUseNativeDialog,\n        )\n        if filename:\n            with Path(filename).open(\"w\", newline=\"\") as csv_file:\n                writer = csv.DictWriter(csv_file, fieldnames=[\"cycle\", \"order\", \"current\"])\n                writer.writeheader()\n\n                for order, current in zip(self.serie_order.points(), self.serie_current.points()):\n                    writer.writerow({\"cycle\": int(order.x()), \"order\": order.y(), \"current\": current.y()})\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.__init__","title":"<code>__init__(parent=None, name=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget | None</code> <p>The parent widget</p> <code>None</code> <code>name</code> <code>str | None</code> <p>Name of the current chart</p> <code>None</code> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget | None = None, name: str | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n        name: Name of the current chart\n    \"\"\"\n    super().__init__(parent)\n    self.name = name\n\n    layout = QtWidgets.QVBoxLayout(self)\n\n    self.chart_view = QtCharts.QChartView()\n    self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n    layout.addWidget(self.chart_view)\n\n    sliders_widget = QtWidgets.QWidget()\n    sliders_layout = QtWidgets.QGridLayout(sliders_widget)\n    sliders_widget.setLayout(sliders_layout)\n    layout.addWidget(sliders_widget)\n\n    self.scrollbar = QtWidgets.QScrollBar(QtCore.Qt.Horizontal)\n    self.scrollbar.setMinimum(1)\n    self.scrollbar.setMaximum(self.default_range_max_x)\n    self.scrollbar.setSliderPosition(25)\n    self.scrollbar.valueChanged.connect(self.slider_changed)\n    sliders_layout.addWidget(self.scrollbar, 0, 0)\n\n    self.zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=0, maximum=100, value=60)\n    self.zoom.setMinimum(1)\n    self.zoom.setMaximum(self.zoom_max)\n    self.zoom.setValue(1)\n    self.zoom.valueChanged.connect(self.slider_changed)\n    sliders_layout.addWidget(self.zoom, 1, 0)\n\n    self.save_button = QtWidgets.QPushButton()\n    self.save_button.setIcon(QtGui.QIcon.fromTheme(\"document-save\"))\n    self.save_button.setStatusTip(\"Save values\")\n    self.save_button.clicked.connect(self.save_values)\n    sliders_layout.addWidget(self.save_button, 0, 1, 2, 1)\n\n    self.chart = QtCharts.QChart()\n    self.axis_x = QtCharts.QValueAxis(self)\n    self.axis_y = QtCharts.QValueAxis(self)\n    self.chart.addAxis(self.axis_x, QtCore.Qt.AlignBottom)\n    self.chart.addAxis(self.axis_y, QtCore.Qt.AlignLeft)\n\n    self.serie_current = QtCharts.QLineSeries(name=f\"{self.name} Current\")\n    self.chart.addSeries(self.serie_current)\n    self.serie_current.attachAxis(self.axis_x)\n    self.serie_current.attachAxis(self.axis_y)\n    pen = self.serie_current.pen()\n    pen.setWidth(5)\n    self.serie_current.setPen(pen)\n\n    self.serie_order = QtCharts.QLineSeries(name=f\"{self.name} Order\")\n    self.chart.addSeries(self.serie_order)\n    self.serie_order.attachAxis(self.axis_x)\n    self.serie_order.attachAxis(self.axis_y)\n\n    pen = self.serie_order.pen()\n    pen.setWidth(5)\n    self.serie_order.setPen(pen)\n\n    # self.chart.createDefaultAxes()\n\n    self.axis_x.setMin(1)\n    self.axis_x.setTickInterval(1)\n\n    self.axis_y.setMin(1)\n    self.axis_y.setMax(self.default_range_max_y)\n\n    self.chart_view.setChart(self.chart)\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.new_robot_state","title":"<code>new_robot_state(cycle, current, order)</code>","text":"<p>Add a new point on the chart view.</p> <p>Parameters:</p> Name Type Description Default <code>cycle</code> <code>int</code> <p>Current cycle</p> required <code>current</code> <code>float | None</code> <p>Current value</p> required <code>order</code> <code>float | None</code> <p>Order value</p> required Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def new_robot_state(self, cycle: int, current: float | None, order: float | None) -&gt; None:\n    \"\"\"\n    Add a new point on the chart view.\n\n    Arguments:\n        cycle: Current cycle\n        current: Current value\n        order: Order value\n    \"\"\"\n    if self.need_reset:\n        self.need_reset = False\n        self.reset()\n\n    self.range_max_x = max(self.range_max_x, cycle)\n\n    if current:\n        self.serie_current.append(cycle, current)\n        self.range_max_y = max(self.range_max_y, current)\n\n    if order:\n        self.serie_order.append(cycle, order)\n        self.range_max_y = max(self.range_max_y, order)\n\n    self.axis_y.setMax(self.range_max_y)\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.recalculate_range_x","title":"<code>recalculate_range_x()</code>","text":"<p>Given the current zoom and current position of the scrollbar, compute the X min/max range and the slider position.</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def recalculate_range_x(self):\n    \"\"\"\n    Given the current zoom and current position of the scrollbar,\n    compute the X min/max range and the slider position.\n    \"\"\"\n    if self.slider_events_disabled:\n        return\n    self.slider_events_disabled = True\n\n    span = int(self.range_max_x / self.zoom.value())\n    span = span + span % 2\n    scroll_min = span / 2\n    scroll_max = self.range_max_x - span / 2\n\n    scroll = self.scrollbar.value()\n    scroll = max(scroll_min, scroll)\n    scroll = min(scroll_max, scroll)\n\n    self.scrollbar.setMinimum(scroll_min)\n    self.scrollbar.setMaximum(scroll_max)\n    self.scrollbar.setValue(scroll)\n\n    self.axis_x.setMax(self.range_max_x)\n\n    span = int(self.range_max_x / self.zoom.sliderPosition())\n    span = span + span % 2\n\n    x_min = scroll - span / 2\n    x_max = scroll + span / 2\n    self.axis_x.setRange(x_min, x_max)\n\n    self.slider_events_disabled = False\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.reset","title":"<code>reset()</code>","text":"<p>Reset the chart</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset the chart\n    \"\"\"\n    self.serie_current.clear()\n    self.serie_order.clear()\n\n    self.range_max_x = self.default_range_max_x\n    self.range_max_y = self.default_range_max_y\n\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.save_values","title":"<code>save_values()</code>","text":"<p>Qt Slot</p> <p>Open a file dialog to select a file and save chart values in it.</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>@qtSlot()\ndef save_values(self):\n    \"\"\"\n    Qt Slot\n\n    Open a file dialog to select a file and save chart values in it.\n    \"\"\"\n    filename, _ = QtWidgets.QFileDialog.getSaveFileName(\n        parent=self,\n        caption=f\"Select file to save {self.name} values\",\n        dir=\"\",\n        filter=\"CSV Files (*.csv)\",\n        # Workaround a know Qt bug\n        options=QtWidgets.QFileDialog.DontUseNativeDialog,\n    )\n    if filename:\n        with Path(filename).open(\"w\", newline=\"\") as csv_file:\n            writer = csv.DictWriter(csv_file, fieldnames=[\"cycle\", \"order\", \"current\"])\n            writer.writeheader()\n\n            for order, current in zip(self.serie_order.points(), self.serie_current.points()):\n                writer.writerow({\"cycle\": int(order.x()), \"order\": order.y(), \"current\": current.y()})\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartView.slider_changed","title":"<code>slider_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the scrollbar and zoom has changed.</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>@qtSlot(int)\ndef slider_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the scrollbar and zoom has changed.\n    \"\"\"\n    self.recalculate_range_x()\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartsView","title":"<code>ChartsView</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>ChartsView class</p> <p>Build the calibration charts window.</p> <p>Attributes:</p> Name Type Description <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>class ChartsView(QtWidgets.QDialog):\n    \"\"\"ChartsView class\n\n    Build the calibration charts window.\n\n    Attributes:\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, parent: QtWidgets.QWidget | None = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.robot_id = 0\n\n        self.setWindowTitle(\"Calibration Charts\")\n        self.setModal(False)\n        self.setMinimumSize(QtCore.QSize(400, 400))\n\n        self.layout = QtWidgets.QGridLayout()\n        self.setLayout(self.layout)\n\n        self.linear_speed_chart = ChartView(self, \"Linear Speed\")\n        self.angular_speed_chart = ChartView(self, \"Angular Speed\")\n        self.layout.addWidget(self.linear_speed_chart, 0, 0)\n        self.layout.addWidget(self.angular_speed_chart, 1, 0)\n\n        reset_button = QtWidgets.QPushButton(\"Reset\")\n        self.layout.addWidget(reset_button)\n        reset_button.clicked.connect(self.reset)\n\n        self.readSettings()\n\n    def reset(self):\n        \"\"\"\n        Reset charts.\n        \"\"\"\n        self.linear_speed_chart.reset()\n        self.angular_speed_chart.reset()\n\n    def set_robot_id(self, robot_id: int) -&gt; None:\n        self.robot_id = robot_id\n        self.setWindowTitle(f\"Calibration Charts for Robot {robot_id}\")\n        self.readSettings()\n\n    @qtSlot(RobotState)\n    def new_robot_state(self, state: RobotState) -&gt; None:\n        \"\"\"\n        Qt Slot\n\n        Send robot data to corresponding charts\n\n        Arguments:\n            state: New robot state\n        \"\"\"\n        self.linear_speed_chart.new_robot_state(\n            state.cycle,\n            state.speed_current.distance,\n            state.speed_order.distance,\n        )\n        self.angular_speed_chart.new_robot_state(\n            state.cycle,\n            state.speed_current.angle,\n            state.speed_order.angle,\n        )\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(f\"chartsview/geometry/{self.robot_id}\", self.saveGeometry())\n\n        self.closed.emit()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(f\"chartsview/geometry/{self.robot_id}\"))\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartsView.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget | None</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget | None = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.robot_id = 0\n\n    self.setWindowTitle(\"Calibration Charts\")\n    self.setModal(False)\n    self.setMinimumSize(QtCore.QSize(400, 400))\n\n    self.layout = QtWidgets.QGridLayout()\n    self.setLayout(self.layout)\n\n    self.linear_speed_chart = ChartView(self, \"Linear Speed\")\n    self.angular_speed_chart = ChartView(self, \"Angular Speed\")\n    self.layout.addWidget(self.linear_speed_chart, 0, 0)\n    self.layout.addWidget(self.angular_speed_chart, 1, 0)\n\n    reset_button = QtWidgets.QPushButton(\"Reset\")\n    self.layout.addWidget(reset_button)\n    reset_button.clicked.connect(self.reset)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartsView.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(f\"chartsview/geometry/{self.robot_id}\", self.saveGeometry())\n\n    self.closed.emit()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartsView.new_robot_state","title":"<code>new_robot_state(state)</code>","text":"<p>Qt Slot</p> <p>Send robot data to corresponding charts</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>RobotState</code> <p>New robot state</p> required Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>@qtSlot(RobotState)\ndef new_robot_state(self, state: RobotState) -&gt; None:\n    \"\"\"\n    Qt Slot\n\n    Send robot data to corresponding charts\n\n    Arguments:\n        state: New robot state\n    \"\"\"\n    self.linear_speed_chart.new_robot_state(\n        state.cycle,\n        state.speed_current.distance,\n        state.speed_order.distance,\n    )\n    self.angular_speed_chart.new_robot_state(\n        state.cycle,\n        state.speed_current.angle,\n        state.speed_order.angle,\n    )\n</code></pre>"},{"location":"reference/cogip/widgets/chartsview/#cogip.widgets.chartsview.ChartsView.reset","title":"<code>reset()</code>","text":"<p>Reset charts.</p> Source code in <code>cogip/widgets/chartsview.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Reset charts.\n    \"\"\"\n    self.linear_speed_chart.reset()\n    self.angular_speed_chart.reset()\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/","title":"gameview","text":""},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.EventFilter","title":"<code>EventFilter</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Event filter registered on the 3D Window.</p> <p>Filter all mouse and keyboard events related to moving the scene in front of the camera.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>class EventFilter(QtCore.QObject):\n    \"\"\"\n    Event filter registered on the 3D Window.\n\n    Filter all mouse and keyboard events related to moving the scene\n    in front of the camera.\n    \"\"\"\n\n    def __init__(self, parent: \"GameView\"):\n        \"\"\"\n        Class constructor\n        \"\"\"\n        super().__init__(parent)\n        self.game_view = parent\n        self._last_mouse_pos = None\n\n    def eventFilter(self, source, event) -&gt; bool:\n        \"\"\"\n        Required event filter function.\n        \"\"\"\n        if isinstance(event, QtGui.QKeyEvent):\n            key: QtCore.Qt.Key = event.key()\n            modifiers: QtCore.Qt.KeyboardModifiers = event.modifiers()\n\n            if modifiers == QtCore.Qt.NoModifier:\n                if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.translate(-10, 0, 0)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.translate(10, 0, 0)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.translate(0, -10, 0)\n                elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.translate(0, 10, 0)\n                elif key == QtCore.Qt.Key_Space:\n                    self.game_view.top_view()\n                elif key == QtCore.Qt.Key_Return:\n                    self.game_view.default_view()\n                else:\n                    return False\n                return True\n\n            elif modifiers == QtCore.Qt.ShiftModifier:\n                if key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.rotate(-1, 0, 0)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.rotate(1, 0, 0)\n                elif key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.rotate(0, -1, 0)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.rotate(0, 1, 0)\n                else:\n                    return False\n                return True\n\n            elif modifiers == QtCore.Qt.ControlModifier:\n                if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                    self.game_view.rotate(0, 0, -1)\n                elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                    self.game_view.rotate(0, 0, 1)\n                elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                    self.game_view.translate(0, 0, -20)\n                elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                    self.game_view.translate(0, 0, 20)\n                else:\n                    return False\n\n            else:\n                return False\n\n        elif isinstance(event, QtGui.QWheelEvent):\n            self.game_view.translate(0, 0, event.angleDelta().y() / 5)\n\n        elif isinstance(event, QtGui.QMouseEvent):\n            new_pos = event.globalPosition().toPoint()\n            if not self._last_mouse_pos:\n                self._last_mouse_pos = new_pos\n            new_pos = event.globalPosition().toPoint()\n            delta = new_pos - self._last_mouse_pos\n            self._last_mouse_pos = new_pos\n\n            if event.type() == QtCore.QEvent.MouseMove:\n                if event.buttons() == QtCore.Qt.MouseButton.MiddleButton:\n                    self.game_view.rotate(0, 0, (delta.x() + delta.y()) / 2)\n                elif event.buttons() == QtCore.Qt.MouseButton.RightButton:\n                    self.game_view.rotate(delta.y(), delta.x(), 0)\n                else:\n                    return False\n            else:\n                return False\n        else:\n            return False\n\n        return True\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.EventFilter.__init__","title":"<code>__init__(parent)</code>","text":"<p>Class constructor</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def __init__(self, parent: \"GameView\"):\n    \"\"\"\n    Class constructor\n    \"\"\"\n    super().__init__(parent)\n    self.game_view = parent\n    self._last_mouse_pos = None\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.EventFilter.eventFilter","title":"<code>eventFilter(source, event)</code>","text":"<p>Required event filter function.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def eventFilter(self, source, event) -&gt; bool:\n    \"\"\"\n    Required event filter function.\n    \"\"\"\n    if isinstance(event, QtGui.QKeyEvent):\n        key: QtCore.Qt.Key = event.key()\n        modifiers: QtCore.Qt.KeyboardModifiers = event.modifiers()\n\n        if modifiers == QtCore.Qt.NoModifier:\n            if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.translate(-10, 0, 0)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.translate(10, 0, 0)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.translate(0, -10, 0)\n            elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.translate(0, 10, 0)\n            elif key == QtCore.Qt.Key_Space:\n                self.game_view.top_view()\n            elif key == QtCore.Qt.Key_Return:\n                self.game_view.default_view()\n            else:\n                return False\n            return True\n\n        elif modifiers == QtCore.Qt.ShiftModifier:\n            if key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.rotate(-1, 0, 0)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.rotate(1, 0, 0)\n            elif key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.rotate(0, -1, 0)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.rotate(0, 1, 0)\n            else:\n                return False\n            return True\n\n        elif modifiers == QtCore.Qt.ControlModifier:\n            if key in [QtCore.Qt.Key_Left, QtCore.Qt.Key_Q]:\n                self.game_view.rotate(0, 0, -1)\n            elif key in [QtCore.Qt.Key_Right, QtCore.Qt.Key_D]:\n                self.game_view.rotate(0, 0, 1)\n            elif key in [QtCore.Qt.Key_Down, QtCore.Qt.Key_S]:\n                self.game_view.translate(0, 0, -20)\n            elif key in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Z]:\n                self.game_view.translate(0, 0, 20)\n            else:\n                return False\n\n        else:\n            return False\n\n    elif isinstance(event, QtGui.QWheelEvent):\n        self.game_view.translate(0, 0, event.angleDelta().y() / 5)\n\n    elif isinstance(event, QtGui.QMouseEvent):\n        new_pos = event.globalPosition().toPoint()\n        if not self._last_mouse_pos:\n            self._last_mouse_pos = new_pos\n        new_pos = event.globalPosition().toPoint()\n        delta = new_pos - self._last_mouse_pos\n        self._last_mouse_pos = new_pos\n\n        if event.type() == QtCore.QEvent.MouseMove:\n            if event.buttons() == QtCore.Qt.MouseButton.MiddleButton:\n                self.game_view.rotate(0, 0, (delta.x() + delta.y()) / 2)\n            elif event.buttons() == QtCore.Qt.MouseButton.RightButton:\n                self.game_view.rotate(delta.y(), delta.x(), 0)\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView","title":"<code>GameView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>The <code>GameView</code> class is a <code>QWidget</code> containing a <code>Qt3DWindow</code> used to display all the game element, like table, robot and obstacles.</p> <p>It also contains an horizontal plane entity with a invisible <code>QPlaneMesh</code>. This plane is has a <code>QObjectPicker</code> to detect mouse clicks, to help grabbing and moving entities on the horizontal plane.</p> <p>Attributes:</p> Name Type Description <code>ground_image</code> <code>Path</code> <p>image to display on the table floor</p> <code>obstacle_entities</code> <code>list[ObstacleEntity]</code> <p>List of obstacles</p> <code>plane_intersection</code> <code>QVector3D</code> <p>last active intersection of plane picker in world coordinates</p> <code>mouse_enabled</code> <code>bool</code> <p>True to authorize translation and rotation of the scene using the mouse, False when an other object (obstacle, manual robot, ...) is picked.</p> <code>new_move_delta</code> <code>Signal</code> <p>signal emitted to movable entities when a mouse drag is detected</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>class GameView(QtWidgets.QWidget):\n    \"\"\"\n    The `GameView` class is a [`QWidget`](https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QWidget.html)\n    containing a [`Qt3DWindow`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/Qt3DWindow.html)\n    used to display all the game element, like table, robot and obstacles.\n\n    It also contains an horizontal plane entity with a invisible\n    [`QPlaneMesh`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DExtras/QPlaneMesh.html).\n    This plane is has a [`QObjectPicker`](https://doc.qt.io/qtforpython-6/PySide6/Qt3DRender/QObjectPicker.html)\n    to detect mouse clicks, to help grabbing and moving entities on the horizontal plane.\n\n    Attributes:\n        ground_image: image to display on the table floor\n        obstacle_entities: List of obstacles\n        plane_intersection: last active intersection of plane picker in world coordinates\n        mouse_enabled: True to authorize translation and rotation of the scene using the mouse,\n            False when an other object (obstacle, manual robot, ...) is picked.\n        new_move_delta: signal emitted to movable entities when a mouse drag is detected\n    \"\"\"\n\n    ground_image: Path = Path(\"assets/table2024.png\")\n    obstacle_entities: list[ObstacleEntity] = []\n    plane_intersection: QtGui.QVector3D = None\n    mouse_enabled: bool = True\n    new_move_delta: qtSignal = qtSignal(QtGui.QVector3D)\n\n    def __init__(self):\n        \"\"\"\n        Create all entities required in the view:\n\n          - the `Qt3DWindow` to display the scene\n          - the camera and all controls to move the scene in front of the camera\n          - the lights to have a good lightning of the scene\n          - the plane entity to help moving obstacles\n        \"\"\"\n        super().__init__()\n\n        # Create the 3D window and set it as the widget layout\n        self.view = Qt3DExtras.Qt3DWindow()\n        self.view.installEventFilter(EventFilter(self))\n        self.container = self.createWindowContainer(self.view)\n        self.container.setMinimumSize(QtCore.QSize(400, 400))\n        self.container.setFocusPolicy(QtCore.Qt.NoFocus)\n        layout = QtWidgets.QHBoxLayout()\n        layout.addWidget(self.container)\n        self.setLayout(layout)\n\n        picking_settings = self.view.renderSettings().pickingSettings()\n        picking_settings.setPickMethod(Qt3DRender.QPickingSettings.TrianglePicking)\n        picking_settings.setPickResultMode(Qt3DRender.QPickingSettings.AllPicks)\n\n        # Create root entity\n        self.root_entity = Qt3DCore.QEntity()\n        self.view.setRootEntity(self.root_entity)\n\n        self.root_transform = Qt3DCore.QTransform()\n        self.root_entity.addComponent(self.root_transform)\n        self.default_view()\n\n        # Create an object picker to catch mouse clicks on root entity\n        self.root_picker = Qt3DRender.QObjectPicker()\n        self.root_picker.setDragEnabled(True)\n        self.root_picker.pressed.connect(self.pressed)\n        self.root_picker.moved.connect(self.moved)\n        self.root_entity.addComponent(self.root_picker)\n\n        # Create scene entity\n        self.scene_entity = Qt3DCore.QEntity(self.root_entity)\n\n        self.scene_transform = Qt3DCore.QTransform()\n        self.scene_entity.addComponent(self.scene_transform)\n        self.scene_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n        self.scene_transform.setRotationZ(180)\n\n        # Draw axis\n        self.x_axis = LineEntity(QtCore.Qt.red, self.scene_entity)\n        self.x_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=5000, y=0, z=0),\n        )\n\n        self.y_axis = LineEntity(QtCore.Qt.green, self.scene_entity)\n        self.y_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=0, y=5000, z=0),\n        )\n\n        self.z_axis = LineEntity(QtCore.Qt.blue, self.scene_entity)\n        self.z_axis.set_points(\n            models.Vertex(x=0, y=0, z=0),\n            models.Vertex(x=0, y=0, z=5000),\n        )\n\n        self.path: dict[int, PathEntity] = {}\n\n        # Init Camera\n        self.camera_entity: Qt3DRender.QCamera = self.view.camera()\n        self.camera_entity.lens().setPerspectiveProjection(45.0, 16.0 / 9.0, 0.1, 10000.0)\n        self.camera_entity.setUpVector(QtGui.QVector3D(0, 0, 1))\n        self.camera_entity.setPosition(QtGui.QVector3D(0, 0, 10))\n        self.camera_entity.setViewCenter(QtGui.QVector3D(0, 0, 0))\n\n        # Create lights\n        self.light_entity = create_light_entity(self.root_entity, 5000, 5000, 5000)\n        self.light_entity2 = create_light_entity(self.root_entity, 5000, -5000, 5000)\n\n        # Create object picker\n        self.create_object_picker()\n\n        # Add image on table floor\n        self.add_ground_image()\n\n        self.start_time = timeit.default_timer()\n\n    def enable_mouse(self, enable: bool) -&gt; None:\n        self.mouse_enabled = enable\n\n    def translate(self, x: int, y: int, z: int) -&gt; None:\n        self.root_transform.setTranslation(\n            QtGui.QVector3D(\n                max(-1500, min(1500, self.root_transform.translation().x() + x)),\n                max(-1000, min(1000, self.root_transform.translation().y() + y)),\n                max(-5000, min(-10, self.root_transform.translation().z() + z)),\n            )\n        )\n\n    def rotate(self, x: int, y: int, z: int) -&gt; None:\n        (self.root_transform.setRotationX((self.root_transform.rotationX() + x) % 360),)\n        (self.root_transform.setRotationY((self.root_transform.rotationY() + y) % 360),)\n        self.root_transform.setRotationZ((self.root_transform.rotationZ() - z) % 360)\n\n    def top_view(self) -&gt; None:\n        (self.root_transform.setRotationX(0),)\n        (self.root_transform.setRotationY(0),)\n        self.root_transform.setRotationZ(-90)\n        self.root_transform.setTranslation(QtGui.QVector3D(0, 0, -3500))\n\n    def default_view(self) -&gt; None:\n        self.root_transform.setRotationX(-45)\n        self.root_transform.setRotationY(0)\n        self.root_transform.setRotationZ(-45)\n        self.root_transform.setTranslation(QtGui.QVector3D(100, 400, -3500))\n\n    def add_asset(self, asset: AssetEntity) -&gt; None:\n        \"\"\"\n        Add an asset (like [TableEntity][cogip.entities.asset.AssetEntity]\n        or [RobotEntity][cogip.entities.robot.RobotEntity]) in the 3D view.\n\n        Argument:\n            asset: The asset entity to add to the vew\n        \"\"\"\n        asset.setParent(self.scene_entity)\n        asset.ready.connect(self.asset_ready)\n\n    def add_obstacle(self, x: int = 0, y: int = 0, rotation: int = 0, **kwargs) -&gt; ObstacleEntity:\n        \"\"\"\n        Create a new obstacle in the 3D view.\n\n        Arguments:\n            x: X position\n            y: Y position\n            rotation: Rotation\n\n        Return:\n            The obstacle entity\n        \"\"\"\n        obstacle_entity = ObstacleEntity(self.container, x, y, rotation, **kwargs)\n        obstacle_entity.setParent(self.scene_entity)\n        self.obstacle_entities.append(obstacle_entity)\n        obstacle_entity.enable_controller.connect(self.enable_mouse)\n        self.new_move_delta.connect(obstacle_entity.new_move_delta)\n        return obstacle_entity\n\n    def load_obstacles(self, filename: Path):\n        \"\"\"\n        Load obstacles from a JSON file.\n\n        Arguments:\n            filename: path of the JSON file\n        \"\"\"\n        try:\n            obstacle_models = TypeAdapter(models.ObstacleList).validate_json(filename.read_text())\n            for obstacle_model in obstacle_models:\n                self.add_obstacle(**obstacle_model.model_dump())\n        except ValidationError as exc:\n            print(exc)\n\n    def save_obstacles(self, filename: Path):\n        \"\"\"\n        Save obstacles to a JSON file.\n\n        Arguments:\n            filename: path of the JSON file\n        \"\"\"\n        obstacle_models = []\n        for obstacle_entity in self.obstacle_entities:\n            obstacle_models.append(obstacle_entity.get_model())\n        with filename.open(\"w\") as fd:\n            fd.write(json.dumps(obstacle_models, default=pydantic_encoder, indent=2))\n\n    def asset_ready(self):\n        \"\"\"\n        Create artifacts when all assets are ready (loading assets is done in background).\n        \"\"\"\n        child_assets_not_ready = [\n            child for child in self.scene_entity.findChildren(AssetEntity) if not child.asset_ready\n        ]\n        if len(child_assets_not_ready) == 0:\n            self.robot_manual = RobotManualEntity(self.scene_entity, self.container)\n            self.robot_manual.enable_controller.connect(self.enable_mouse)\n            self.new_move_delta.connect(self.robot_manual.new_move_delta)\n            self.pami_manual = RobotManualEntity(self.scene_entity, self.container, robot_id=2, y=-1200)\n            self.pami_manual.enable_controller.connect(self.enable_mouse)\n            self.new_move_delta.connect(self.pami_manual.new_move_delta)\n\n            print(f\"Load time of assets: {timeit.default_timer() - self.start_time:0.3f}s\")\n\n    def plane_pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Record the intersection between the mouse pointer and the plane entity,\n        on the `pressed` mouse event, in world coordinate.\n        \"\"\"\n        if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n            return\n\n        self.plane_intersection = pick.worldIntersection()\n\n    def plane_moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Compute the translation on the plane entity between the\n        current `moved` mouse event and the previous one.\n\n        Emit the `new_move_delta` signal to update the corresponding asset's position.\n        \"\"\"\n        if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n            return\n\n        new_intersection = pick.worldIntersection()\n        delta: QtGui.QVector3D = new_intersection - self.plane_intersection\n        delta.setZ(0)\n        rot_z = self.root_transform.rotationZ()\n        delta = QtGui.QVector3D(\n            -delta.x() * math.cos(math.radians(rot_z)) - delta.y() * math.sin(math.radians(rot_z)),\n            -delta.y() * math.cos(math.radians(rot_z)) + delta.x() * math.sin(math.radians(rot_z)),\n            0,\n        )\n        self.new_move_delta.emit(delta)\n        self.plane_intersection = new_intersection\n\n    def plane_released(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Emit the `new_move_delta` signal with `None` argument,\n        on `released` mouse event, to notify that mouse button was released\n        and no further moves will happen until next `pressed` mouse event.\n        \"\"\"\n        self.plane_intersection = None\n        self.new_move_delta.emit(None)\n\n    def add_robot(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Add a new robot status bar.\n\n        Parameters:\n            robot_id: ID of the new robot\n        \"\"\"\n        if self.path.get(robot_id):\n            return\n        path = PathEntity(parent=self.scene_entity)\n        path.set_points([])\n        self.path[robot_id] = path\n\n    def del_robot(self, robot_id: int) -&gt; None:\n        \"\"\"\n        Remove a robot.\n\n        Parameters:\n            robot_id: ID of the robot to remove\n        \"\"\"\n        path = self.path.pop(robot_id, None)\n        if not path:\n            return\n        path.set_points([])\n\n    def new_robot_path(self, robot_id: int, new_path: list[models.Vertex]) -&gt; None:\n        \"\"\"\n        Function called when robot path is updated.\n\n        Arguments:\n            robot_id: ID of the robot\n            new_path: new robot path\n        \"\"\"\n        path = self.path.get(robot_id)\n        if not path:\n            return\n        for vertex in new_path:\n            vertex.z = 20\n        path.set_points(new_path)\n\n    def pressed(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Function called on a ```pressed``` mouse event on the artifact.\n\n        Emit a signal to disable the camera controller before moving the artifact.\n        \"\"\"\n        self.last_mouse_pos = pick.worldIntersection()\n\n    def moved(self, pick: Qt3DRender.QPickEvent):\n        \"\"\"\n        Function called on a ```moved``` mouse event on the artifact.\n\n        Just record that the artifact is moving, the translation is computed\n        in the [GameView][cogip.widgets.gameview.GameView] object.\n        \"\"\"\n\n        if not self.mouse_enabled:\n            return\n\n        new_pos = pick.worldIntersection()\n        delta = new_pos - self.last_mouse_pos\n        self.last_mouse_pos = new_pos\n\n        if pick.buttons() == QtCore.Qt.MouseButton.LeftButton.value:\n            self.translate(delta.x(), delta.y(), 0)\n\n    def create_object_picker(self):\n        \"\"\"\n        Add a plane mesh with object picker to help moving objects with mouse drag and drop.\n        \"\"\"\n        self.plane_entity = Qt3DCore.QEntity(self.scene_entity)\n\n        plane_mesh = Qt3DExtras.QPlaneMesh(self.plane_entity)\n        plane_mesh.setHeight(8000)\n        plane_mesh.setWidth(10000)\n        self.plane_entity.addComponent(plane_mesh)\n\n        plane_transform = Qt3DCore.QTransform(self.plane_entity)\n        plane_transform.setTranslation(QtGui.QVector3D(0, 1000, 0))\n        plane_transform.setRotationX(90)\n        self.plane_entity.addComponent(plane_transform)\n\n        plane_picker = Qt3DRender.QObjectPicker(self.plane_entity)\n        plane_picker.setDragEnabled(True)\n        plane_picker.pressed.connect(self.plane_pressed)\n        plane_picker.released.connect(self.plane_released)\n        plane_picker.moved.connect(self.plane_moved)\n        self.plane_entity.addComponent(plane_picker)\n\n    def add_ground_image(self) -&gt; None:\n        \"\"\"\n        Add a plane to display the ground image\n        \"\"\"\n        self.ground_entity = Qt3DCore.QEntity(self.scene_entity)\n\n        ground_mesh = Qt3DExtras.QPlaneMesh(self.ground_entity)\n        ground_mesh.setHeight(3000)\n        ground_mesh.setWidth(2000)\n        self.ground_entity.addComponent(ground_mesh)\n\n        ground_material = Qt3DExtras.QTextureMaterial(self.ground_entity)\n\n        ground_texture = Qt3DRender.QTexture2D(ground_material)\n        ground_texture_image = Qt3DRender.QTextureImage(ground_texture)\n        ground_texture_image.setSource(QtCore.QUrl(f\"file:{self.ground_image}\"))\n        ground_texture_image.setMirrored(False)\n        ground_texture.addTextureImage(ground_texture_image)\n        ground_material.setTexture(ground_texture)\n        self.ground_entity.addComponent(ground_material)\n\n        ground_transform = Qt3DCore.QTransform(self.ground_entity)\n        ground_transform.setRotationX(90)\n        ground_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n        self.ground_entity.addComponent(ground_transform)\n\n    def get_camera_params(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Return current camera parameters to save them for next session.\n        \"\"\"\n        return {\n            \"translation\": self.root_transform.translation().toTuple(),\n            \"rotation\": [\n                self.root_transform.rotationX(),\n                self.root_transform.rotationY(),\n                self.root_transform.rotationZ(),\n            ],\n        }\n\n    def set_camera_params(self, camera_params: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Set camera parameters to restore them from previous session.\n        \"\"\"\n        self.root_transform.setTranslation(QtGui.QVector3D(*camera_params[\"translation\"]))\n        self.root_transform.setRotationX(camera_params[\"rotation\"][0])\n        self.root_transform.setRotationY(camera_params[\"rotation\"][1])\n        self.root_transform.setRotationZ(camera_params[\"rotation\"][2])\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.__init__","title":"<code>__init__()</code>","text":"<p>Create all entities required in the view:</p> <ul> <li>the <code>Qt3DWindow</code> to display the scene</li> <li>the camera and all controls to move the scene in front of the camera</li> <li>the lights to have a good lightning of the scene</li> <li>the plane entity to help moving obstacles</li> </ul> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create all entities required in the view:\n\n      - the `Qt3DWindow` to display the scene\n      - the camera and all controls to move the scene in front of the camera\n      - the lights to have a good lightning of the scene\n      - the plane entity to help moving obstacles\n    \"\"\"\n    super().__init__()\n\n    # Create the 3D window and set it as the widget layout\n    self.view = Qt3DExtras.Qt3DWindow()\n    self.view.installEventFilter(EventFilter(self))\n    self.container = self.createWindowContainer(self.view)\n    self.container.setMinimumSize(QtCore.QSize(400, 400))\n    self.container.setFocusPolicy(QtCore.Qt.NoFocus)\n    layout = QtWidgets.QHBoxLayout()\n    layout.addWidget(self.container)\n    self.setLayout(layout)\n\n    picking_settings = self.view.renderSettings().pickingSettings()\n    picking_settings.setPickMethod(Qt3DRender.QPickingSettings.TrianglePicking)\n    picking_settings.setPickResultMode(Qt3DRender.QPickingSettings.AllPicks)\n\n    # Create root entity\n    self.root_entity = Qt3DCore.QEntity()\n    self.view.setRootEntity(self.root_entity)\n\n    self.root_transform = Qt3DCore.QTransform()\n    self.root_entity.addComponent(self.root_transform)\n    self.default_view()\n\n    # Create an object picker to catch mouse clicks on root entity\n    self.root_picker = Qt3DRender.QObjectPicker()\n    self.root_picker.setDragEnabled(True)\n    self.root_picker.pressed.connect(self.pressed)\n    self.root_picker.moved.connect(self.moved)\n    self.root_entity.addComponent(self.root_picker)\n\n    # Create scene entity\n    self.scene_entity = Qt3DCore.QEntity(self.root_entity)\n\n    self.scene_transform = Qt3DCore.QTransform()\n    self.scene_entity.addComponent(self.scene_transform)\n    self.scene_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n    self.scene_transform.setRotationZ(180)\n\n    # Draw axis\n    self.x_axis = LineEntity(QtCore.Qt.red, self.scene_entity)\n    self.x_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=5000, y=0, z=0),\n    )\n\n    self.y_axis = LineEntity(QtCore.Qt.green, self.scene_entity)\n    self.y_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=0, y=5000, z=0),\n    )\n\n    self.z_axis = LineEntity(QtCore.Qt.blue, self.scene_entity)\n    self.z_axis.set_points(\n        models.Vertex(x=0, y=0, z=0),\n        models.Vertex(x=0, y=0, z=5000),\n    )\n\n    self.path: dict[int, PathEntity] = {}\n\n    # Init Camera\n    self.camera_entity: Qt3DRender.QCamera = self.view.camera()\n    self.camera_entity.lens().setPerspectiveProjection(45.0, 16.0 / 9.0, 0.1, 10000.0)\n    self.camera_entity.setUpVector(QtGui.QVector3D(0, 0, 1))\n    self.camera_entity.setPosition(QtGui.QVector3D(0, 0, 10))\n    self.camera_entity.setViewCenter(QtGui.QVector3D(0, 0, 0))\n\n    # Create lights\n    self.light_entity = create_light_entity(self.root_entity, 5000, 5000, 5000)\n    self.light_entity2 = create_light_entity(self.root_entity, 5000, -5000, 5000)\n\n    # Create object picker\n    self.create_object_picker()\n\n    # Add image on table floor\n    self.add_ground_image()\n\n    self.start_time = timeit.default_timer()\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.add_asset","title":"<code>add_asset(asset)</code>","text":"<p>Add an asset (like TableEntity or RobotEntity) in the 3D view.</p> Argument <p>asset: The asset entity to add to the vew</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def add_asset(self, asset: AssetEntity) -&gt; None:\n    \"\"\"\n    Add an asset (like [TableEntity][cogip.entities.asset.AssetEntity]\n    or [RobotEntity][cogip.entities.robot.RobotEntity]) in the 3D view.\n\n    Argument:\n        asset: The asset entity to add to the vew\n    \"\"\"\n    asset.setParent(self.scene_entity)\n    asset.ready.connect(self.asset_ready)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.add_ground_image","title":"<code>add_ground_image()</code>","text":"<p>Add a plane to display the ground image</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def add_ground_image(self) -&gt; None:\n    \"\"\"\n    Add a plane to display the ground image\n    \"\"\"\n    self.ground_entity = Qt3DCore.QEntity(self.scene_entity)\n\n    ground_mesh = Qt3DExtras.QPlaneMesh(self.ground_entity)\n    ground_mesh.setHeight(3000)\n    ground_mesh.setWidth(2000)\n    self.ground_entity.addComponent(ground_mesh)\n\n    ground_material = Qt3DExtras.QTextureMaterial(self.ground_entity)\n\n    ground_texture = Qt3DRender.QTexture2D(ground_material)\n    ground_texture_image = Qt3DRender.QTextureImage(ground_texture)\n    ground_texture_image.setSource(QtCore.QUrl(f\"file:{self.ground_image}\"))\n    ground_texture_image.setMirrored(False)\n    ground_texture.addTextureImage(ground_texture_image)\n    ground_material.setTexture(ground_texture)\n    self.ground_entity.addComponent(ground_material)\n\n    ground_transform = Qt3DCore.QTransform(self.ground_entity)\n    ground_transform.setRotationX(90)\n    ground_transform.setTranslation(QtGui.QVector3D(0, 0, 0))\n    self.ground_entity.addComponent(ground_transform)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.add_obstacle","title":"<code>add_obstacle(x=0, y=0, rotation=0, **kwargs)</code>","text":"<p>Create a new obstacle in the 3D view.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>X position</p> <code>0</code> <code>y</code> <code>int</code> <p>Y position</p> <code>0</code> <code>rotation</code> <code>int</code> <p>Rotation</p> <code>0</code> Return <p>The obstacle entity</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def add_obstacle(self, x: int = 0, y: int = 0, rotation: int = 0, **kwargs) -&gt; ObstacleEntity:\n    \"\"\"\n    Create a new obstacle in the 3D view.\n\n    Arguments:\n        x: X position\n        y: Y position\n        rotation: Rotation\n\n    Return:\n        The obstacle entity\n    \"\"\"\n    obstacle_entity = ObstacleEntity(self.container, x, y, rotation, **kwargs)\n    obstacle_entity.setParent(self.scene_entity)\n    self.obstacle_entities.append(obstacle_entity)\n    obstacle_entity.enable_controller.connect(self.enable_mouse)\n    self.new_move_delta.connect(obstacle_entity.new_move_delta)\n    return obstacle_entity\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.add_robot","title":"<code>add_robot(robot_id)</code>","text":"<p>Add a new robot status bar.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the new robot</p> required Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def add_robot(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Add a new robot status bar.\n\n    Parameters:\n        robot_id: ID of the new robot\n    \"\"\"\n    if self.path.get(robot_id):\n        return\n    path = PathEntity(parent=self.scene_entity)\n    path.set_points([])\n    self.path[robot_id] = path\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.asset_ready","title":"<code>asset_ready()</code>","text":"<p>Create artifacts when all assets are ready (loading assets is done in background).</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def asset_ready(self):\n    \"\"\"\n    Create artifacts when all assets are ready (loading assets is done in background).\n    \"\"\"\n    child_assets_not_ready = [\n        child for child in self.scene_entity.findChildren(AssetEntity) if not child.asset_ready\n    ]\n    if len(child_assets_not_ready) == 0:\n        self.robot_manual = RobotManualEntity(self.scene_entity, self.container)\n        self.robot_manual.enable_controller.connect(self.enable_mouse)\n        self.new_move_delta.connect(self.robot_manual.new_move_delta)\n        self.pami_manual = RobotManualEntity(self.scene_entity, self.container, robot_id=2, y=-1200)\n        self.pami_manual.enable_controller.connect(self.enable_mouse)\n        self.new_move_delta.connect(self.pami_manual.new_move_delta)\n\n        print(f\"Load time of assets: {timeit.default_timer() - self.start_time:0.3f}s\")\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.create_object_picker","title":"<code>create_object_picker()</code>","text":"<p>Add a plane mesh with object picker to help moving objects with mouse drag and drop.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def create_object_picker(self):\n    \"\"\"\n    Add a plane mesh with object picker to help moving objects with mouse drag and drop.\n    \"\"\"\n    self.plane_entity = Qt3DCore.QEntity(self.scene_entity)\n\n    plane_mesh = Qt3DExtras.QPlaneMesh(self.plane_entity)\n    plane_mesh.setHeight(8000)\n    plane_mesh.setWidth(10000)\n    self.plane_entity.addComponent(plane_mesh)\n\n    plane_transform = Qt3DCore.QTransform(self.plane_entity)\n    plane_transform.setTranslation(QtGui.QVector3D(0, 1000, 0))\n    plane_transform.setRotationX(90)\n    self.plane_entity.addComponent(plane_transform)\n\n    plane_picker = Qt3DRender.QObjectPicker(self.plane_entity)\n    plane_picker.setDragEnabled(True)\n    plane_picker.pressed.connect(self.plane_pressed)\n    plane_picker.released.connect(self.plane_released)\n    plane_picker.moved.connect(self.plane_moved)\n    self.plane_entity.addComponent(plane_picker)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.del_robot","title":"<code>del_robot(robot_id)</code>","text":"<p>Remove a robot.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot to remove</p> required Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def del_robot(self, robot_id: int) -&gt; None:\n    \"\"\"\n    Remove a robot.\n\n    Parameters:\n        robot_id: ID of the robot to remove\n    \"\"\"\n    path = self.path.pop(robot_id, None)\n    if not path:\n        return\n    path.set_points([])\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.get_camera_params","title":"<code>get_camera_params()</code>","text":"<p>Return current camera parameters to save them for next session.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def get_camera_params(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Return current camera parameters to save them for next session.\n    \"\"\"\n    return {\n        \"translation\": self.root_transform.translation().toTuple(),\n        \"rotation\": [\n            self.root_transform.rotationX(),\n            self.root_transform.rotationY(),\n            self.root_transform.rotationZ(),\n        ],\n    }\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.load_obstacles","title":"<code>load_obstacles(filename)</code>","text":"<p>Load obstacles from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the JSON file</p> required Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def load_obstacles(self, filename: Path):\n    \"\"\"\n    Load obstacles from a JSON file.\n\n    Arguments:\n        filename: path of the JSON file\n    \"\"\"\n    try:\n        obstacle_models = TypeAdapter(models.ObstacleList).validate_json(filename.read_text())\n        for obstacle_model in obstacle_models:\n            self.add_obstacle(**obstacle_model.model_dump())\n    except ValidationError as exc:\n        print(exc)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.moved","title":"<code>moved(pick)</code>","text":"<p>Function called on a <code>moved</code> mouse event on the artifact.</p> <p>Just record that the artifact is moving, the translation is computed in the GameView object.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Function called on a ```moved``` mouse event on the artifact.\n\n    Just record that the artifact is moving, the translation is computed\n    in the [GameView][cogip.widgets.gameview.GameView] object.\n    \"\"\"\n\n    if not self.mouse_enabled:\n        return\n\n    new_pos = pick.worldIntersection()\n    delta = new_pos - self.last_mouse_pos\n    self.last_mouse_pos = new_pos\n\n    if pick.buttons() == QtCore.Qt.MouseButton.LeftButton.value:\n        self.translate(delta.x(), delta.y(), 0)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.new_robot_path","title":"<code>new_robot_path(robot_id, new_path)</code>","text":"<p>Function called when robot path is updated.</p> <p>Parameters:</p> Name Type Description Default <code>robot_id</code> <code>int</code> <p>ID of the robot</p> required <code>new_path</code> <code>list[Vertex]</code> <p>new robot path</p> required Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def new_robot_path(self, robot_id: int, new_path: list[models.Vertex]) -&gt; None:\n    \"\"\"\n    Function called when robot path is updated.\n\n    Arguments:\n        robot_id: ID of the robot\n        new_path: new robot path\n    \"\"\"\n    path = self.path.get(robot_id)\n    if not path:\n        return\n    for vertex in new_path:\n        vertex.z = 20\n    path.set_points(new_path)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.plane_moved","title":"<code>plane_moved(pick)</code>","text":"<p>Compute the translation on the plane entity between the current <code>moved</code> mouse event and the previous one.</p> <p>Emit the <code>new_move_delta</code> signal to update the corresponding asset's position.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def plane_moved(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Compute the translation on the plane entity between the\n    current `moved` mouse event and the previous one.\n\n    Emit the `new_move_delta` signal to update the corresponding asset's position.\n    \"\"\"\n    if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n        return\n\n    new_intersection = pick.worldIntersection()\n    delta: QtGui.QVector3D = new_intersection - self.plane_intersection\n    delta.setZ(0)\n    rot_z = self.root_transform.rotationZ()\n    delta = QtGui.QVector3D(\n        -delta.x() * math.cos(math.radians(rot_z)) - delta.y() * math.sin(math.radians(rot_z)),\n        -delta.y() * math.cos(math.radians(rot_z)) + delta.x() * math.sin(math.radians(rot_z)),\n        0,\n    )\n    self.new_move_delta.emit(delta)\n    self.plane_intersection = new_intersection\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.plane_pressed","title":"<code>plane_pressed(pick)</code>","text":"<p>Record the intersection between the mouse pointer and the plane entity, on the <code>pressed</code> mouse event, in world coordinate.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def plane_pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Record the intersection between the mouse pointer and the plane entity,\n    on the `pressed` mouse event, in world coordinate.\n    \"\"\"\n    if pick.buttons() != QtCore.Qt.MouseButton.LeftButton.value:\n        return\n\n    self.plane_intersection = pick.worldIntersection()\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.plane_released","title":"<code>plane_released(pick)</code>","text":"<p>Emit the <code>new_move_delta</code> signal with <code>None</code> argument, on <code>released</code> mouse event, to notify that mouse button was released and no further moves will happen until next <code>pressed</code> mouse event.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def plane_released(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Emit the `new_move_delta` signal with `None` argument,\n    on `released` mouse event, to notify that mouse button was released\n    and no further moves will happen until next `pressed` mouse event.\n    \"\"\"\n    self.plane_intersection = None\n    self.new_move_delta.emit(None)\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.pressed","title":"<code>pressed(pick)</code>","text":"<p>Function called on a <code>pressed</code> mouse event on the artifact.</p> <p>Emit a signal to disable the camera controller before moving the artifact.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def pressed(self, pick: Qt3DRender.QPickEvent):\n    \"\"\"\n    Function called on a ```pressed``` mouse event on the artifact.\n\n    Emit a signal to disable the camera controller before moving the artifact.\n    \"\"\"\n    self.last_mouse_pos = pick.worldIntersection()\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.save_obstacles","title":"<code>save_obstacles(filename)</code>","text":"<p>Save obstacles to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>path of the JSON file</p> required Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def save_obstacles(self, filename: Path):\n    \"\"\"\n    Save obstacles to a JSON file.\n\n    Arguments:\n        filename: path of the JSON file\n    \"\"\"\n    obstacle_models = []\n    for obstacle_entity in self.obstacle_entities:\n        obstacle_models.append(obstacle_entity.get_model())\n    with filename.open(\"w\") as fd:\n        fd.write(json.dumps(obstacle_models, default=pydantic_encoder, indent=2))\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.GameView.set_camera_params","title":"<code>set_camera_params(camera_params)</code>","text":"<p>Set camera parameters to restore them from previous session.</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def set_camera_params(self, camera_params: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Set camera parameters to restore them from previous session.\n    \"\"\"\n    self.root_transform.setTranslation(QtGui.QVector3D(*camera_params[\"translation\"]))\n    self.root_transform.setRotationX(camera_params[\"rotation\"][0])\n    self.root_transform.setRotationY(camera_params[\"rotation\"][1])\n    self.root_transform.setRotationZ(camera_params[\"rotation\"][2])\n</code></pre>"},{"location":"reference/cogip/widgets/gameview/#cogip.widgets.gameview.create_light_entity","title":"<code>create_light_entity(parent, x, y, z, intensity=1)</code>","text":"<p>Create a light entity at the position specified in arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QEntity</code> <p>parent entity</p> required <code>x</code> <code>float</code> <p>X position</p> required <code>y</code> <code>float</code> <p>Y position</p> required <code>z</code> <code>float</code> <p>Z position</p> required <code>intensity</code> <code>float</code> <p>light intensity</p> <code>1</code> Return <p>The light entity</p> Source code in <code>cogip/widgets/gameview.py</code> <pre><code>def create_light_entity(\n    parent: Qt3DCore.QEntity, x: float, y: float, z: float, intensity: float = 1\n) -&gt; Qt3DCore.QEntity:\n    \"\"\"\n    Create a light entity at the position specified in arguments.\n\n    Arguments:\n        parent: parent entity\n        x: X position\n        y: Y position\n        z: Z position\n        intensity: light intensity\n\n    Return:\n        The light entity\n    \"\"\"\n    light_entity = Qt3DCore.QEntity(parent)\n\n    light = Qt3DRender.QPointLight(light_entity)\n    light.setColor(QtGui.QColor(QtCore.Qt.white))\n    light.setIntensity(intensity)\n    light_entity.addComponent(light)\n\n    light_transform = Qt3DCore.QTransform(light_entity)\n    light_transform.setTranslation(QtGui.QVector3D(x, y, z))\n    light_entity.addComponent(light_transform)\n\n    return light_entity\n</code></pre>"},{"location":"reference/cogip/widgets/help/","title":"help","text":""},{"location":"reference/cogip/widgets/help/#cogip.widgets.help.HelpCameraControlDialog","title":"<code>HelpCameraControlDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>HelpCameraControlDialog class</p> <p>Build a help modal for camera control.</p> <p>Attributes:</p> Name Type Description <code>saved_geometry</code> <p>Saved window position</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/widgets/help.py</code> <pre><code>class HelpCameraControlDialog(QtWidgets.QDialog):\n    \"\"\"HelpCameraControlDialog class\n\n    Build a help modal for camera control.\n\n    Attributes:\n        saved_geometry: Saved window position\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n\n        self.setWindowTitle(\"Camera Control\")\n        self.setModal(False)\n\n        layout = QtWidgets.QVBoxLayout()\n        self.setLayout(layout)\n\n        browser = QtWidgets.QTextBrowser()\n        layout.addWidget(browser)\n\n        browser.document().setMarkdown(help_text)\n\n        self.resize(580, 395)\n\n        self.readSettings()\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(\"help/geometry\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(\"help/geometry\"))\n</code></pre>"},{"location":"reference/cogip/widgets/help/#cogip.widgets.help.HelpCameraControlDialog.__init__","title":"<code>__init__(parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/help.py</code> <pre><code>def __init__(self, parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.setWindowTitle(\"Camera Control\")\n    self.setModal(False)\n\n    layout = QtWidgets.QVBoxLayout()\n    self.setLayout(layout)\n\n    browser = QtWidgets.QTextBrowser()\n    layout.addWidget(browser)\n\n    browser.document().setMarkdown(help_text)\n\n    self.resize(580, 395)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/widgets/help/#cogip.widgets.help.HelpCameraControlDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/widgets/help.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(\"help/geometry\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/","title":"lidarview","text":""},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView","title":"<code>LidarView</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>This class is a widget that provides the graphic view and instantiates the polar chart, sliders and the table view.</p> <p>Attributes:</p> Name Type Description <code>min_distance</code> <code>int</code> <p>min value of the distance range (use on the chart)</p> <code>max_distance</code> <code>int</code> <p>max value of the distance range (use on the chart)</p> <code>max_intensity</code> <code>int</code> <p>max value of the intensity range (use on the chart)</p> <code>enable_plain_area</code> <code>bool</code> <p>whether to display a line or an plain area for distance values</p> <code>max_intensity_threshold</code> <code>int</code> <p>max value of the intensity threshold slider (max value for YGLidar G2)</p> <code>new_filer</code> <code>int</code> <p>Qt signal emitted when the filter value is modified</p> <code>new_intensity_threshold</code> <code>Signal(int)</code> <p>Qt signal emitted when the filter intensity threshold is modified</p> Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>class LidarView(QtWidgets.QWidget):\n    \"\"\"\n    This class is a widget that provides the graphic view and instantiates the polar chart,\n    sliders and the table view.\n\n    Attributes:\n        min_distance: min value of the distance range (use on the chart)\n        max_distance: max value of the distance range (use on the chart)\n        max_intensity: max value of the intensity range (use on the chart)\n        enable_plain_area: whether to display a line or an plain area for distance values\n        max_intensity_threshold: max value of the intensity threshold slider (max value for YGLidar G2)\n        new_filer: Qt signal emitted when the filter value is modified\n        new_intensity_threshold: Qt signal emitted when the filter intensity threshold is modified\n    \"\"\"\n\n    min_distance: int = 100\n    max_distance: int = 5000\n    max_intensity: int = 1024\n    enable_plain_area: bool = True\n    max_intensity_threshold: int = 1024\n    new_filter: qtSignal(int) = qtSignal(int)\n    new_intensity_threshold: qtSignal(int) = qtSignal(int)\n    nb_angles: int = 360\n\n    def __init__(\n        self,\n        table_model: LidarTableModel,\n        angle_values: list[int],\n        distance_values: list[int],\n        intensity_values: list[int],\n        distance_color: QtGui.QColor,\n        intensity_color: QtGui.QColor,\n        nb_angles: int,\n        parent: QtWidgets.QWidget | None = None,\n    ):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            table_model: table model object\n            angle_values: angle values list\n            distance_values: distance values list\n            intensity_values: intensity values list\n            distance_color: distance color\n            intensity_color: intensity color\n            nb_angles: number of angles\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n\n        self.table_model = table_model\n        self.angle_values = angle_values\n        self.distance_values = distance_values\n        self.intensity_values = intensity_values\n        self.distance_color = distance_color\n        self.intensity_color = intensity_color\n        self.nb_angles = nb_angles\n\n        self.first_index = self.table_model.createIndex(0, 1)\n        self.last_index = self.table_model.createIndex(self.nb_angles - 1, 2)\n\n        layout = QtWidgets.QHBoxLayout(self)\n\n        chart_layout = QtWidgets.QVBoxLayout()\n        layout.addLayout(chart_layout)\n\n        # Create polar chart and chart view\n        self.chart = QtCharts.QPolarChart()\n        self.chart.setTitle(\"Lidar Data\")\n        self.chart.setMinimumSize(QtCore.QSize(800, 800))\n        self.chart_view = QtCharts.QChartView(self.chart)\n        self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n        chart_layout.addWidget(self.chart_view)\n\n        # Add axis\n        self.degree_axis = QtCharts.QValueAxis(self.chart)\n        self.degree_axis.setRange(-180, 179)\n        self.degree_axis.setLabelFormat(\"%d\")\n        self.degree_axis.setTickCount(17)\n        self.degree_axis.setMinorTickCount(1)\n        self.chart.addAxis(self.degree_axis, QtCharts.QPolarChart.PolarOrientationAngular)\n\n        self.distance_axis = QtCharts.QValueAxis(self.chart)\n        self.distance_axis.setRange(0, self.max_distance)\n        self.distance_axis.setMinorTickCount(2)\n        self.distance_axis.setTickCount(26)\n        self.distance_axis.setTickAnchor(1)\n        self.distance_axis.setLabelFormat(\"%d\")\n        self.chart.addAxis(self.distance_axis, QtCharts.QPolarChart.PolarOrientationRadial)\n\n        self.intensity_axis = QtCharts.QValueAxis(self.chart)\n        self.intensity_axis.setRange(0, self.max_intensity)\n        self.intensity_axis.setLabelFormat(\"%d\")\n        self.intensity_axis.setLabelsVisible(False)\n        self.chart.addAxis(self.intensity_axis, QtCharts.QPolarChart.PolarOrientationRadial)\n\n        # Add series\n        self.distance_serie = QtCharts.QLineSeries(name=\"Distance\")\n        # self.distance_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n        if self.enable_plain_area:\n            self.center_serie = QtCharts.QLineSeries()\n            # self.center_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n            self.distance_area_serie = QtCharts.QAreaSeries(self.distance_serie, self.center_serie, name=\"Distance\")\n            self.chart.addSeries(self.distance_area_serie)\n            self.distance_area_serie.attachAxis(self.degree_axis)\n            self.distance_area_serie.attachAxis(self.distance_axis)\n        else:\n            self.chart.addSeries(self.distance_serie)\n            self.distance_serie.attachAxis(self.degree_axis)\n            self.distance_serie.attachAxis(self.distance_axis)\n\n        self.intensity_serie = QtCharts.QLineSeries(name=\"Intensity\")\n        # self.intensity_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n        self.chart.addSeries(self.intensity_serie)\n        self.intensity_serie.attachAxis(self.degree_axis)\n        self.intensity_serie.attachAxis(self.intensity_axis)\n\n        # Add a grid for sliders\n        sliders_layout = QtWidgets.QGridLayout()\n        sliders_layout.setColumnStretch(0, 1)\n        sliders_layout.setColumnStretch(1, 10)\n        sliders_layout.setColumnStretch(2, 10)\n        sliders_layout.setColumnStretch(3, 200)\n        chart_layout.addLayout(sliders_layout)\n\n        # Distance Zoom slider\n        distance_label = QtWidgets.QLabel(\"Max Distance:\")\n        sliders_layout.addWidget(distance_label, 0, 1)\n        self.distance_value = QtWidgets.QLabel()\n        sliders_layout.addWidget(self.distance_value, 0, 2)\n        distance_zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=-self.max_distance, maximum=-self.min_distance)\n        distance_zoom.valueChanged.connect(self.distance_zoom_changed)\n        distance_zoom.setValue(-self.max_distance)\n        distance_zoom.setStyleSheet(\n            \"QSlider::handle:horizontal {\"\n            \"    border-radius: 5px; border: 2px solid #FFFFFF; width: 20px; margin: -5px 0;\"\n            f\"   background: {hex(self.distance_color.rgb()).replace('0x', '#')}\"\n            \"}\"\n            \"QSlider::sub-page:horizontal {\"\n            f\"   background: {hex(self.distance_color.rgb()).replace('0x', '#')};\"\n            \"}\"\n        )\n        sliders_layout.addWidget(distance_zoom, 0, 3)\n\n        # Intensity Zoom slider\n        intensity_label = QtWidgets.QLabel(\"Max Intensity:\")\n        sliders_layout.addWidget(intensity_label, 1, 1)\n        self.intensity_value = QtWidgets.QLabel()\n        sliders_layout.addWidget(self.intensity_value, 1, 2)\n        intensity_zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=-self.max_intensity, maximum=0)\n        intensity_zoom.valueChanged.connect(self.intensity_zoom_changed)\n        intensity_zoom.setValue(-self.max_intensity)\n        intensity_zoom.setStyleSheet(\n            \"QSlider::handle:horizontal {\"\n            \"    border-radius: 5px; border: 2px solid #FFFFFF; width: 20px; margin: -5px 0;\"\n            f\"   background: {hex(self.intensity_color.rgb()).replace('0x', '#')};\"\n            \"}\"\n            \"QSlider::sub-page:horizontal {\"\n            f\"   background: {hex(self.intensity_color.rgb()).replace('0x', '#')};\"\n            \"}\"\n        )\n        sliders_layout.addWidget(intensity_zoom, 1, 3)\n\n        # Distance filter slider\n        filter_check = QtWidgets.QCheckBox()\n        filter_check.stateChanged.connect(self.filter_check_changed)\n        sliders_layout.addWidget(filter_check, 2, 0)\n        self.filter_label = QtWidgets.QLabel(\"Distance filter:\")\n        sliders_layout.addWidget(self.filter_label, 2, 1)\n        self.filter_value = QtWidgets.QLabel()\n        sliders_layout.addWidget(self.filter_value, 2, 2)\n        self.filter_slider = QtWidgets.QSlider(\n            QtCore.Qt.Horizontal, minimum=self.min_distance, maximum=self.max_distance\n        )\n        self.filter_slider.valueChanged.connect(self.filter_slider_changed)\n        self.filter_slider.setValue(500)\n        sliders_layout.addWidget(self.filter_slider, 2, 3)\n\n        filter_check.setChecked(False)\n        self.filter_value.setEnabled(False)\n        self.filter_slider.setEnabled(False)\n\n        # Intensity threshold slider\n        self.intensity_threshold_label = QtWidgets.QLabel(\"Intensity threshold:\")\n        sliders_layout.addWidget(self.intensity_threshold_label, 3, 1)\n        self.intensity_threshold_value = QtWidgets.QLabel()\n        sliders_layout.addWidget(self.intensity_threshold_value, 3, 2)\n        self.intensity_threshold_slider = QtWidgets.QSlider(\n            QtCore.Qt.Horizontal, minimum=0, maximum=self.max_intensity_threshold\n        )\n        self.intensity_threshold_slider.valueChanged.connect(self.intensity_threshold_slider_changed)\n        self.intensity_threshold_slider.setValue(0)\n        sliders_layout.addWidget(self.intensity_threshold_slider, 3, 3)\n\n        # Create the table view\n        table_view = QtWidgets.QTableView()\n        table_view.setModel(self.table_model)\n        table_view.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)\n        table_view.resizeColumnsToContents()\n        table_view.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)\n        layout.addWidget(table_view)\n\n    @qtSlot(int)\n    def distance_zoom_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the distance zoom slider has changed.\n\n        Arguments:\n            value: new value\n        \"\"\"\n        self.distance_axis.setMax(-value)\n        self.distance_value.setText(str(-value))\n\n    @qtSlot(int)\n    def intensity_zoom_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the intensity zoom slider has changed.\n\n        Arguments:\n            value: new value\n        \"\"\"\n        self.intensity_axis.setMax(-value)\n        self.intensity_value.setText(str(-value))\n\n    @qtSlot(int)\n    def filter_slider_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the filter value slider has changed.\n\n        Arguments:\n            value: new value\n        \"\"\"\n        self.filter_value.setText(str(value))\n        self.new_filter.emit(value)\n\n    @qtSlot(int)\n    def filter_check_changed(self, state: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the filter checkbox is checked/unchecked.\n\n        Arguments:\n            state: new state\n        \"\"\"\n        enabled = state != 0\n        self.filter_value.setEnabled(enabled)\n        self.filter_slider.setEnabled(enabled)\n\n        self.new_filter.emit(self.filter_slider.value() if enabled else 0)\n\n    @qtSlot(int)\n    def intensity_threshold_slider_changed(self, value: int):\n        \"\"\"\n        Qt Slot\n\n        Function called when the intensity threshold value slider has changed.\n\n        Arguments:\n            value: new value\n        \"\"\"\n        self.intensity_threshold_value.setText(str(value))\n        self.new_intensity_threshold.emit(value)\n\n    @qtSlot()\n    def update_data(self) -&gt; None:\n        \"\"\"\n        Qt Slot\n\n        Function called to update data on chart and table.\n        \"\"\"\n        self.table_model.dataChanged.emit(self.first_index, self.last_index, [QtCore.Qt.DisplayRole])\n\n        self.distance_serie.replace(\n            [QtCore.QPointF(angle, value) for angle, value in zip(self.angle_values, self.distance_values)]\n        )\n        self.intensity_serie.replace(\n            [QtCore.QPointF(angle, value) for angle, value in zip(self.angle_values, self.intensity_values)]\n        )\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.__init__","title":"<code>__init__(table_model, angle_values, distance_values, intensity_values, distance_color, intensity_color, nb_angles, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>table_model</code> <code>LidarTableModel</code> <p>table model object</p> required <code>angle_values</code> <code>list[int]</code> <p>angle values list</p> required <code>distance_values</code> <code>list[int]</code> <p>distance values list</p> required <code>intensity_values</code> <code>list[int]</code> <p>intensity values list</p> required <code>distance_color</code> <code>QColor</code> <p>distance color</p> required <code>intensity_color</code> <code>QColor</code> <p>intensity color</p> required <code>nb_angles</code> <code>int</code> <p>number of angles</p> required <code>parent</code> <code>QWidget | None</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>def __init__(\n    self,\n    table_model: LidarTableModel,\n    angle_values: list[int],\n    distance_values: list[int],\n    intensity_values: list[int],\n    distance_color: QtGui.QColor,\n    intensity_color: QtGui.QColor,\n    nb_angles: int,\n    parent: QtWidgets.QWidget | None = None,\n):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        table_model: table model object\n        angle_values: angle values list\n        distance_values: distance values list\n        intensity_values: intensity values list\n        distance_color: distance color\n        intensity_color: intensity color\n        nb_angles: number of angles\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n\n    self.table_model = table_model\n    self.angle_values = angle_values\n    self.distance_values = distance_values\n    self.intensity_values = intensity_values\n    self.distance_color = distance_color\n    self.intensity_color = intensity_color\n    self.nb_angles = nb_angles\n\n    self.first_index = self.table_model.createIndex(0, 1)\n    self.last_index = self.table_model.createIndex(self.nb_angles - 1, 2)\n\n    layout = QtWidgets.QHBoxLayout(self)\n\n    chart_layout = QtWidgets.QVBoxLayout()\n    layout.addLayout(chart_layout)\n\n    # Create polar chart and chart view\n    self.chart = QtCharts.QPolarChart()\n    self.chart.setTitle(\"Lidar Data\")\n    self.chart.setMinimumSize(QtCore.QSize(800, 800))\n    self.chart_view = QtCharts.QChartView(self.chart)\n    self.chart_view.setRenderHint(QtGui.QPainter.Antialiasing)\n    chart_layout.addWidget(self.chart_view)\n\n    # Add axis\n    self.degree_axis = QtCharts.QValueAxis(self.chart)\n    self.degree_axis.setRange(-180, 179)\n    self.degree_axis.setLabelFormat(\"%d\")\n    self.degree_axis.setTickCount(17)\n    self.degree_axis.setMinorTickCount(1)\n    self.chart.addAxis(self.degree_axis, QtCharts.QPolarChart.PolarOrientationAngular)\n\n    self.distance_axis = QtCharts.QValueAxis(self.chart)\n    self.distance_axis.setRange(0, self.max_distance)\n    self.distance_axis.setMinorTickCount(2)\n    self.distance_axis.setTickCount(26)\n    self.distance_axis.setTickAnchor(1)\n    self.distance_axis.setLabelFormat(\"%d\")\n    self.chart.addAxis(self.distance_axis, QtCharts.QPolarChart.PolarOrientationRadial)\n\n    self.intensity_axis = QtCharts.QValueAxis(self.chart)\n    self.intensity_axis.setRange(0, self.max_intensity)\n    self.intensity_axis.setLabelFormat(\"%d\")\n    self.intensity_axis.setLabelsVisible(False)\n    self.chart.addAxis(self.intensity_axis, QtCharts.QPolarChart.PolarOrientationRadial)\n\n    # Add series\n    self.distance_serie = QtCharts.QLineSeries(name=\"Distance\")\n    # self.distance_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n    if self.enable_plain_area:\n        self.center_serie = QtCharts.QLineSeries()\n        # self.center_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n        self.distance_area_serie = QtCharts.QAreaSeries(self.distance_serie, self.center_serie, name=\"Distance\")\n        self.chart.addSeries(self.distance_area_serie)\n        self.distance_area_serie.attachAxis(self.degree_axis)\n        self.distance_area_serie.attachAxis(self.distance_axis)\n    else:\n        self.chart.addSeries(self.distance_serie)\n        self.distance_serie.attachAxis(self.degree_axis)\n        self.distance_serie.attachAxis(self.distance_axis)\n\n    self.intensity_serie = QtCharts.QLineSeries(name=\"Intensity\")\n    # self.intensity_serie.replace([QtCore.QPointF(i, 0) for i in range(self.nb_angles)])\n    self.chart.addSeries(self.intensity_serie)\n    self.intensity_serie.attachAxis(self.degree_axis)\n    self.intensity_serie.attachAxis(self.intensity_axis)\n\n    # Add a grid for sliders\n    sliders_layout = QtWidgets.QGridLayout()\n    sliders_layout.setColumnStretch(0, 1)\n    sliders_layout.setColumnStretch(1, 10)\n    sliders_layout.setColumnStretch(2, 10)\n    sliders_layout.setColumnStretch(3, 200)\n    chart_layout.addLayout(sliders_layout)\n\n    # Distance Zoom slider\n    distance_label = QtWidgets.QLabel(\"Max Distance:\")\n    sliders_layout.addWidget(distance_label, 0, 1)\n    self.distance_value = QtWidgets.QLabel()\n    sliders_layout.addWidget(self.distance_value, 0, 2)\n    distance_zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=-self.max_distance, maximum=-self.min_distance)\n    distance_zoom.valueChanged.connect(self.distance_zoom_changed)\n    distance_zoom.setValue(-self.max_distance)\n    distance_zoom.setStyleSheet(\n        \"QSlider::handle:horizontal {\"\n        \"    border-radius: 5px; border: 2px solid #FFFFFF; width: 20px; margin: -5px 0;\"\n        f\"   background: {hex(self.distance_color.rgb()).replace('0x', '#')}\"\n        \"}\"\n        \"QSlider::sub-page:horizontal {\"\n        f\"   background: {hex(self.distance_color.rgb()).replace('0x', '#')};\"\n        \"}\"\n    )\n    sliders_layout.addWidget(distance_zoom, 0, 3)\n\n    # Intensity Zoom slider\n    intensity_label = QtWidgets.QLabel(\"Max Intensity:\")\n    sliders_layout.addWidget(intensity_label, 1, 1)\n    self.intensity_value = QtWidgets.QLabel()\n    sliders_layout.addWidget(self.intensity_value, 1, 2)\n    intensity_zoom = QtWidgets.QSlider(QtCore.Qt.Horizontal, minimum=-self.max_intensity, maximum=0)\n    intensity_zoom.valueChanged.connect(self.intensity_zoom_changed)\n    intensity_zoom.setValue(-self.max_intensity)\n    intensity_zoom.setStyleSheet(\n        \"QSlider::handle:horizontal {\"\n        \"    border-radius: 5px; border: 2px solid #FFFFFF; width: 20px; margin: -5px 0;\"\n        f\"   background: {hex(self.intensity_color.rgb()).replace('0x', '#')};\"\n        \"}\"\n        \"QSlider::sub-page:horizontal {\"\n        f\"   background: {hex(self.intensity_color.rgb()).replace('0x', '#')};\"\n        \"}\"\n    )\n    sliders_layout.addWidget(intensity_zoom, 1, 3)\n\n    # Distance filter slider\n    filter_check = QtWidgets.QCheckBox()\n    filter_check.stateChanged.connect(self.filter_check_changed)\n    sliders_layout.addWidget(filter_check, 2, 0)\n    self.filter_label = QtWidgets.QLabel(\"Distance filter:\")\n    sliders_layout.addWidget(self.filter_label, 2, 1)\n    self.filter_value = QtWidgets.QLabel()\n    sliders_layout.addWidget(self.filter_value, 2, 2)\n    self.filter_slider = QtWidgets.QSlider(\n        QtCore.Qt.Horizontal, minimum=self.min_distance, maximum=self.max_distance\n    )\n    self.filter_slider.valueChanged.connect(self.filter_slider_changed)\n    self.filter_slider.setValue(500)\n    sliders_layout.addWidget(self.filter_slider, 2, 3)\n\n    filter_check.setChecked(False)\n    self.filter_value.setEnabled(False)\n    self.filter_slider.setEnabled(False)\n\n    # Intensity threshold slider\n    self.intensity_threshold_label = QtWidgets.QLabel(\"Intensity threshold:\")\n    sliders_layout.addWidget(self.intensity_threshold_label, 3, 1)\n    self.intensity_threshold_value = QtWidgets.QLabel()\n    sliders_layout.addWidget(self.intensity_threshold_value, 3, 2)\n    self.intensity_threshold_slider = QtWidgets.QSlider(\n        QtCore.Qt.Horizontal, minimum=0, maximum=self.max_intensity_threshold\n    )\n    self.intensity_threshold_slider.valueChanged.connect(self.intensity_threshold_slider_changed)\n    self.intensity_threshold_slider.setValue(0)\n    sliders_layout.addWidget(self.intensity_threshold_slider, 3, 3)\n\n    # Create the table view\n    table_view = QtWidgets.QTableView()\n    table_view.setModel(self.table_model)\n    table_view.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)\n    table_view.resizeColumnsToContents()\n    table_view.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)\n    layout.addWidget(table_view)\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.distance_zoom_changed","title":"<code>distance_zoom_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the distance zoom slider has changed.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>new value</p> required Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot(int)\ndef distance_zoom_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the distance zoom slider has changed.\n\n    Arguments:\n        value: new value\n    \"\"\"\n    self.distance_axis.setMax(-value)\n    self.distance_value.setText(str(-value))\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.filter_check_changed","title":"<code>filter_check_changed(state)</code>","text":"<p>Qt Slot</p> <p>Function called when the filter checkbox is checked/unchecked.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>int</code> <p>new state</p> required Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot(int)\ndef filter_check_changed(self, state: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the filter checkbox is checked/unchecked.\n\n    Arguments:\n        state: new state\n    \"\"\"\n    enabled = state != 0\n    self.filter_value.setEnabled(enabled)\n    self.filter_slider.setEnabled(enabled)\n\n    self.new_filter.emit(self.filter_slider.value() if enabled else 0)\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.filter_slider_changed","title":"<code>filter_slider_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the filter value slider has changed.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>new value</p> required Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot(int)\ndef filter_slider_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the filter value slider has changed.\n\n    Arguments:\n        value: new value\n    \"\"\"\n    self.filter_value.setText(str(value))\n    self.new_filter.emit(value)\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.intensity_threshold_slider_changed","title":"<code>intensity_threshold_slider_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the intensity threshold value slider has changed.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>new value</p> required Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot(int)\ndef intensity_threshold_slider_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the intensity threshold value slider has changed.\n\n    Arguments:\n        value: new value\n    \"\"\"\n    self.intensity_threshold_value.setText(str(value))\n    self.new_intensity_threshold.emit(value)\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.intensity_zoom_changed","title":"<code>intensity_zoom_changed(value)</code>","text":"<p>Qt Slot</p> <p>Function called when the intensity zoom slider has changed.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>new value</p> required Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot(int)\ndef intensity_zoom_changed(self, value: int):\n    \"\"\"\n    Qt Slot\n\n    Function called when the intensity zoom slider has changed.\n\n    Arguments:\n        value: new value\n    \"\"\"\n    self.intensity_axis.setMax(-value)\n    self.intensity_value.setText(str(-value))\n</code></pre>"},{"location":"reference/cogip/widgets/lidarview/#cogip.widgets.lidarview.LidarView.update_data","title":"<code>update_data()</code>","text":"<p>Qt Slot</p> <p>Function called to update data on chart and table.</p> Source code in <code>cogip/widgets/lidarview.py</code> <pre><code>@qtSlot()\ndef update_data(self) -&gt; None:\n    \"\"\"\n    Qt Slot\n\n    Function called to update data on chart and table.\n    \"\"\"\n    self.table_model.dataChanged.emit(self.first_index, self.last_index, [QtCore.Qt.DisplayRole])\n\n    self.distance_serie.replace(\n        [QtCore.QPointF(angle, value) for angle, value in zip(self.angle_values, self.distance_values)]\n    )\n    self.intensity_serie.replace(\n        [QtCore.QPointF(angle, value) for angle, value in zip(self.angle_values, self.intensity_values)]\n    )\n</code></pre>"},{"location":"reference/cogip/widgets/properties/","title":"properties","text":""},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.IntegerProperty","title":"<code>IntegerProperty</code>","text":"<p>               Bases: <code>QObject</code></p> <p>IntegerProperty class.</p> <p>Build a widget to configure a integer property.</p> Source code in <code>cogip/widgets/properties.py</code> <pre><code>class IntegerProperty(QtCore.QObject):\n    \"\"\"\n    IntegerProperty class.\n\n    Build a widget to configure a integer property.\n    \"\"\"\n\n    value_updated: qtSignal = qtSignal(str, int)\n\n    def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: property name\n            props: properties of the integer property\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self._name = name\n\n        row = layout.rowCount()\n        minimum = props.get(\"minimum\")\n        maximum = props.get(\"maximum\")\n        step = props.get(\"multipleOf\", 1)\n        help = props.get(\"description\")\n        self._slider = None\n\n        label = QtWidgets.QLabel(props[\"title\"])\n        label.setToolTip(help)\n        layout.addWidget(label, row, 0)\n\n        self._value = QtWidgets.QSpinBox()\n        self._value.setToolTip(help)\n        self._value.valueChanged.connect(self.value_changed)\n        if minimum is not None:\n            self._value.setMinimum(minimum)\n        if maximum is not None:\n            self._value.setMaximum(maximum)\n        self._value.setSingleStep(step)\n        self._value.setValue(props[\"value\"])\n        layout.addWidget(self._value, row, 1)\n\n        if minimum is not None and maximum is not None:\n            self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n            self._slider.setToolTip(help)\n            self._slider.setMinimum(minimum)\n            self._slider.setMaximum(maximum)\n            self._slider.setSingleStep(step)\n            self._slider.setValue(props[\"value\"])\n            self._slider.valueChanged.connect(self._value.setValue)\n            layout.addWidget(self._slider, row, 2)\n\n    def value_changed(self, value):\n        if self._slider:\n            self._slider.setValue(value)\n        self.value_updated.emit(self._name, value)\n\n    def update_value(self, value):\n        self._value.blockSignals(True)\n        self._value.setValue(value)\n        self._value.blockSignals(False)\n        if self._slider:\n            self._slider.blockSignals(True)\n            self._slider.setValue(value)\n            self._slider.blockSignals(False)\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.IntegerProperty.__init__","title":"<code>__init__(name, props, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>property name</p> required <code>props</code> <code>dict[str, Any]</code> <p>properties of the integer property</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/widgets/properties.py</code> <pre><code>def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: property name\n        props: properties of the integer property\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self._name = name\n\n    row = layout.rowCount()\n    minimum = props.get(\"minimum\")\n    maximum = props.get(\"maximum\")\n    step = props.get(\"multipleOf\", 1)\n    help = props.get(\"description\")\n    self._slider = None\n\n    label = QtWidgets.QLabel(props[\"title\"])\n    label.setToolTip(help)\n    layout.addWidget(label, row, 0)\n\n    self._value = QtWidgets.QSpinBox()\n    self._value.setToolTip(help)\n    self._value.valueChanged.connect(self.value_changed)\n    if minimum is not None:\n        self._value.setMinimum(minimum)\n    if maximum is not None:\n        self._value.setMaximum(maximum)\n    self._value.setSingleStep(step)\n    self._value.setValue(props[\"value\"])\n    layout.addWidget(self._value, row, 1)\n\n    if minimum is not None and maximum is not None:\n        self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self._slider.setToolTip(help)\n        self._slider.setMinimum(minimum)\n        self._slider.setMaximum(maximum)\n        self._slider.setSingleStep(step)\n        self._slider.setValue(props[\"value\"])\n        self._slider.valueChanged.connect(self._value.setValue)\n        layout.addWidget(self._slider, row, 2)\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.NumberProperty","title":"<code>NumberProperty</code>","text":"<p>               Bases: <code>QObject</code></p> <p>NumberProperty class.</p> <p>Build a widget to configure a number property.</p> Source code in <code>cogip/widgets/properties.py</code> <pre><code>class NumberProperty(QtCore.QObject):\n    \"\"\"\n    NumberProperty class.\n\n    Build a widget to configure a number property.\n    \"\"\"\n\n    value_updated: qtSignal = qtSignal(str, float)\n\n    def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            name: property name\n            props: properties of the number property\n            layout: The parent layout\n        \"\"\"\n        super().__init__()\n        self._name = name\n\n        row = layout.rowCount()\n        minimum = props.get(\"minimum\")\n        maximum = props.get(\"maximum\")\n        step = props.get(\"multipleOf\", 0.1)\n        self._slider = None\n\n        label = QtWidgets.QLabel(props[\"title\"])\n        layout.addWidget(label, row, 0)\n\n        self._value = QtWidgets.QDoubleSpinBox()\n        self._value.setDecimals(4)\n        self._value.valueChanged.connect(self.value_changed)\n        if minimum is not None:\n            self._value.setMinimum(minimum)\n        if maximum is not None:\n            self._value.setMaximum(maximum)\n        self._value.setSingleStep(step)\n        self._value.setValue(props[\"value\"])\n        layout.addWidget(self._value, row, 1)\n\n        if minimum is not None and maximum is not None:\n            self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n            self._slider.setMinimum(minimum * 100)\n            self._slider.setMaximum(maximum * 100)\n            self._slider.setSingleStep(step * 100)\n            self._slider.setValue(props[\"value\"] * 100)\n            self._slider.valueChanged.connect(lambda v: self._value.setValue(v / 100))\n            layout.addWidget(self._slider, row, 2)\n\n    def value_changed(self, value):\n        if self._slider:\n            self._slider.setValue(value * 100)\n        self.value_updated.emit(self._name, value)\n\n    def update_value(self, value):\n        self._value.blockSignals(True)\n        self._value.setValue(value)\n        self._value.blockSignals(False)\n        if self._slider:\n            self._slider.blockSignals(True)\n            self._slider.setValue(value * 100)\n            self._slider.blockSignals(False)\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.NumberProperty.__init__","title":"<code>__init__(name, props, layout)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>property name</p> required <code>props</code> <code>dict[str, Any]</code> <p>properties of the number property</p> required <code>layout</code> <code>QGridLayout</code> <p>The parent layout</p> required Source code in <code>cogip/widgets/properties.py</code> <pre><code>def __init__(self, name: str, props: dict[str, Any], layout: QtWidgets.QGridLayout):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        name: property name\n        props: properties of the number property\n        layout: The parent layout\n    \"\"\"\n    super().__init__()\n    self._name = name\n\n    row = layout.rowCount()\n    minimum = props.get(\"minimum\")\n    maximum = props.get(\"maximum\")\n    step = props.get(\"multipleOf\", 0.1)\n    self._slider = None\n\n    label = QtWidgets.QLabel(props[\"title\"])\n    layout.addWidget(label, row, 0)\n\n    self._value = QtWidgets.QDoubleSpinBox()\n    self._value.setDecimals(4)\n    self._value.valueChanged.connect(self.value_changed)\n    if minimum is not None:\n        self._value.setMinimum(minimum)\n    if maximum is not None:\n        self._value.setMaximum(maximum)\n    self._value.setSingleStep(step)\n    self._value.setValue(props[\"value\"])\n    layout.addWidget(self._value, row, 1)\n\n    if minimum is not None and maximum is not None:\n        self._slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)\n        self._slider.setMinimum(minimum * 100)\n        self._slider.setMaximum(maximum * 100)\n        self._slider.setSingleStep(step * 100)\n        self._slider.setValue(props[\"value\"] * 100)\n        self._slider.valueChanged.connect(lambda v: self._value.setValue(v / 100))\n        layout.addWidget(self._slider, row, 2)\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog","title":"<code>PropertiesDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>PropertiesDialog class</p> <p>Build a modal for properties configuration.</p> <p>Attributes:</p> Name Type Description <code>property_updated</code> <code>Signal</code> <p>Qt signal emitted when a property is updated</p> <code>closed</code> <code>Signal</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/widgets/properties.py</code> <pre><code>class PropertiesDialog(QtWidgets.QDialog):\n    \"\"\"\n    PropertiesDialog class\n\n    Build a modal for properties configuration.\n\n    Attributes:\n        property_updated: Qt signal emitted when a property is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    property_updated: qtSignal = qtSignal(dict)\n    closed: qtSignal = qtSignal()\n\n    def __init__(self, config: dict[str, Any], parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            config: JSON Schema of properties with current values and namespace\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self._config = config\n        self._properties: OrderedDict[str, IntegerProperty | NumberProperty] = collections.OrderedDict()\n        self.setWindowTitle(config[\"title\"])\n        self.setModal(False)\n\n        layout = QtWidgets.QGridLayout()\n        self.setLayout(layout)\n\n        self.add_properties(config[\"properties\"], layout)\n\n        self.readSettings()\n\n    def add_properties(self, props: dict[str, Any], layout: QtWidgets.QGridLayout, parent: str = \"\"):\n        \"\"\"\n        Add properties.\n\n        Arguments:\n            props:  properties to add\n            layout: parent layout\n            parent: parent property name if any\n        \"\"\"\n        for name, props in props.items():\n            if parent:\n                name = f\"{parent}/{name}\"\n            match type := props[\"type\"]:\n                case \"integer\":\n                    self._properties[name] = IntegerProperty(name, props, layout)\n                    self._properties[name].value_updated.connect(self.value_updated)\n                case \"number\":\n                    self._properties[name] = NumberProperty(name, props, layout)\n                    self._properties[name].value_updated.connect(self.value_updated)\n                case \"array\":\n                    values = props[\"value\"]\n                    for value in values:\n                        box = QtWidgets.QGroupBox(value[\"title\"])\n                        layout.addWidget(box, layout.rowCount(), 0, 1, -1)\n                        box_layout = QtWidgets.QGridLayout()\n                        box.setLayout(box_layout)\n                        self.add_properties(value[\"properties\"], box_layout, parent=value[\"title\"])\n                case _:\n                    logger.error(f\"Unsupported property type: {type}\")\n\n    def update_values(self, config: dict[str, Any]):\n        \"\"\"\n        Update properties with new values.\n\n        Arguments:\n            config: JSON Schema of properties with current values and namespace\n        \"\"\"\n        for name, props in config[\"properties\"].items():\n            if property := self._properties.get(name):\n                property.update_value(props[\"value\"])\n\n    def value_updated(self, name: str, value: int | float):\n        \"\"\"\n        Emit updated values with namespace, name and value.\n        \"\"\"\n        self.property_updated.emit(\n            {\n                \"namespace\": self._config[\"namespace\"],\n                \"name\": name,\n                \"value\": value,\n            }\n        )\n\n    def closeEvent(self, event: QtGui.QCloseEvent):\n        \"\"\"\n        Hide the window.\n\n        Arguments:\n            event: The close event (unused)\n        \"\"\"\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        settings.setValue(f\"properties/{self._config['namespace']}/{self._config['title']}\", self.saveGeometry())\n\n        self.closed.emit()\n        event.accept()\n        super().closeEvent(event)\n\n    def readSettings(self):\n        settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n        self.restoreGeometry(settings.value(f\"properties/{self._config['namespace']}/{self._config['title']}\"))\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog.__init__","title":"<code>__init__(config, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/properties.py</code> <pre><code>def __init__(self, config: dict[str, Any], parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        config: JSON Schema of properties with current values and namespace\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self._config = config\n    self._properties: OrderedDict[str, IntegerProperty | NumberProperty] = collections.OrderedDict()\n    self.setWindowTitle(config[\"title\"])\n    self.setModal(False)\n\n    layout = QtWidgets.QGridLayout()\n    self.setLayout(layout)\n\n    self.add_properties(config[\"properties\"], layout)\n\n    self.readSettings()\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog.add_properties","title":"<code>add_properties(props, layout, parent='')</code>","text":"<p>Add properties.</p> <p>Parameters:</p> Name Type Description Default <code>props</code> <code>dict[str, Any]</code> <p>properties to add</p> required <code>layout</code> <code>QGridLayout</code> <p>parent layout</p> required <code>parent</code> <code>str</code> <p>parent property name if any</p> <code>''</code> Source code in <code>cogip/widgets/properties.py</code> <pre><code>def add_properties(self, props: dict[str, Any], layout: QtWidgets.QGridLayout, parent: str = \"\"):\n    \"\"\"\n    Add properties.\n\n    Arguments:\n        props:  properties to add\n        layout: parent layout\n        parent: parent property name if any\n    \"\"\"\n    for name, props in props.items():\n        if parent:\n            name = f\"{parent}/{name}\"\n        match type := props[\"type\"]:\n            case \"integer\":\n                self._properties[name] = IntegerProperty(name, props, layout)\n                self._properties[name].value_updated.connect(self.value_updated)\n            case \"number\":\n                self._properties[name] = NumberProperty(name, props, layout)\n                self._properties[name].value_updated.connect(self.value_updated)\n            case \"array\":\n                values = props[\"value\"]\n                for value in values:\n                    box = QtWidgets.QGroupBox(value[\"title\"])\n                    layout.addWidget(box, layout.rowCount(), 0, 1, -1)\n                    box_layout = QtWidgets.QGridLayout()\n                    box.setLayout(box_layout)\n                    self.add_properties(value[\"properties\"], box_layout, parent=value[\"title\"])\n            case _:\n                logger.error(f\"Unsupported property type: {type}\")\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog.closeEvent","title":"<code>closeEvent(event)</code>","text":"<p>Hide the window.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>QCloseEvent</code> <p>The close event (unused)</p> required Source code in <code>cogip/widgets/properties.py</code> <pre><code>def closeEvent(self, event: QtGui.QCloseEvent):\n    \"\"\"\n    Hide the window.\n\n    Arguments:\n        event: The close event (unused)\n    \"\"\"\n    settings = QtCore.QSettings(\"COGIP\", \"monitor\")\n    settings.setValue(f\"properties/{self._config['namespace']}/{self._config['title']}\", self.saveGeometry())\n\n    self.closed.emit()\n    event.accept()\n    super().closeEvent(event)\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog.update_values","title":"<code>update_values(config)</code>","text":"<p>Update properties with new values.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required Source code in <code>cogip/widgets/properties.py</code> <pre><code>def update_values(self, config: dict[str, Any]):\n    \"\"\"\n    Update properties with new values.\n\n    Arguments:\n        config: JSON Schema of properties with current values and namespace\n    \"\"\"\n    for name, props in config[\"properties\"].items():\n        if property := self._properties.get(name):\n            property.update_value(props[\"value\"])\n</code></pre>"},{"location":"reference/cogip/widgets/properties/#cogip.widgets.properties.PropertiesDialog.value_updated","title":"<code>value_updated(name, value)</code>","text":"<p>Emit updated values with namespace, name and value.</p> Source code in <code>cogip/widgets/properties.py</code> <pre><code>def value_updated(self, name: str, value: int | float):\n    \"\"\"\n    Emit updated values with namespace, name and value.\n    \"\"\"\n    self.property_updated.emit(\n        {\n            \"namespace\": self._config[\"namespace\"],\n            \"name\": name,\n            \"value\": value,\n        }\n    )\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/","title":"wizard","text":""},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.BooleanWizard","title":"<code>BooleanWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>BooleanWizard class.</p> <p>Build a widget to input a boolean.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class BooleanWizard(QtCore.QObject):\n    \"\"\"\n    BooleanWizard class.\n\n    Build a widget to input a boolean.\n    \"\"\"\n\n    response: qtSignal = qtSignal(bool)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignHCenter)\n        parent.setLayout(layout)\n\n        self.input = QtWidgets.QCheckBox()\n        self.input.setChecked(self.wizard.get(\"value\", False))\n        layout.addWidget(self.input)\n\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(self.input.isChecked())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.BooleanWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    layout.setAlignment(QtCore.Qt.AlignHCenter)\n    parent.setLayout(layout)\n\n    self.input = QtWidgets.QCheckBox()\n    self.input.setChecked(self.wizard.get(\"value\", False))\n    layout.addWidget(self.input)\n\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.BooleanWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(self.input.isChecked())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.CampWizard","title":"<code>CampWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>CampWizard class.</p> <p>Build a widget to select a string.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class CampWizard(QtCore.QObject):\n    \"\"\"\n    CampWizard class.\n\n    Build a widget to select a string.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        button_layout = QtWidgets.QHBoxLayout()\n        layout.addLayout(button_layout)\n\n        self.buttons = QtWidgets.QButtonGroup()\n\n        self.button_blue = QtWidgets.QRadioButton()\n        self.button_blue.setObjectName(\"blueCamp\")\n        self.button_blue.setCheckable(True)\n        self.button_blue.setStyleSheet(\n            \"\"\"\n            QRadioButton#blueCamp {\n                border-color: #005CE6;\n                background-color: #005CE6;\n                border-width: 2px;\n                border-radius: 10px;\n                border-style: inset;\n                min-width: 6em;\n                padding: 6px;\n            }\n            QRadioButton#blueCamp:checked {\n                border-color: beige;\n                border-style: outset;\n            }\n            QRadioButton#blueCamp::indicator {\n                border-width: 0;\n            }\n            \"\"\"\n        )\n        self.buttons.addButton(self.button_blue)\n        button_layout.addWidget(self.button_blue)\n\n        self.button_yellow = QtWidgets.QRadioButton()\n        self.button_yellow.setObjectName(\"yellowCamp\")\n        self.button_yellow.setCheckable(True)\n        self.button_yellow.setStyleSheet(\n            \"\"\"\n            QRadioButton#yellowCamp {\n                border-color: #FFBF00;\n                background-color: #FFBF00;\n                border-width: 2px;\n                border-radius: 10px;\n                border-style: inset;\n                min-width: 6em;\n                padding: 6px;\n            }\n            QRadioButton#yellowCamp:checked {\n                border-color: beige;\n                border-style: outset;\n            }\n            QRadioButton#yellowCamp::indicator {\n                border-width: 0;\n            }\n            \"\"\"\n        )\n        self.buttons.addButton(self.button_yellow)\n        button_layout.addWidget(self.button_yellow)\n\n        if wizard[\"value\"] == \"blue\":\n            self.button_blue.setChecked(True)\n        else:\n            self.button_yellow.setChecked(True)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        color = \"blue\" if self.button_blue.isChecked() else \"yellow\"\n        self.response.emit(color)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.CampWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    button_layout = QtWidgets.QHBoxLayout()\n    layout.addLayout(button_layout)\n\n    self.buttons = QtWidgets.QButtonGroup()\n\n    self.button_blue = QtWidgets.QRadioButton()\n    self.button_blue.setObjectName(\"blueCamp\")\n    self.button_blue.setCheckable(True)\n    self.button_blue.setStyleSheet(\n        \"\"\"\n        QRadioButton#blueCamp {\n            border-color: #005CE6;\n            background-color: #005CE6;\n            border-width: 2px;\n            border-radius: 10px;\n            border-style: inset;\n            min-width: 6em;\n            padding: 6px;\n        }\n        QRadioButton#blueCamp:checked {\n            border-color: beige;\n            border-style: outset;\n        }\n        QRadioButton#blueCamp::indicator {\n            border-width: 0;\n        }\n        \"\"\"\n    )\n    self.buttons.addButton(self.button_blue)\n    button_layout.addWidget(self.button_blue)\n\n    self.button_yellow = QtWidgets.QRadioButton()\n    self.button_yellow.setObjectName(\"yellowCamp\")\n    self.button_yellow.setCheckable(True)\n    self.button_yellow.setStyleSheet(\n        \"\"\"\n        QRadioButton#yellowCamp {\n            border-color: #FFBF00;\n            background-color: #FFBF00;\n            border-width: 2px;\n            border-radius: 10px;\n            border-style: inset;\n            min-width: 6em;\n            padding: 6px;\n        }\n        QRadioButton#yellowCamp:checked {\n            border-color: beige;\n            border-style: outset;\n        }\n        QRadioButton#yellowCamp::indicator {\n            border-width: 0;\n        }\n        \"\"\"\n    )\n    self.buttons.addButton(self.button_yellow)\n    button_layout.addWidget(self.button_yellow)\n\n    if wizard[\"value\"] == \"blue\":\n        self.button_blue.setChecked(True)\n    else:\n        self.button_yellow.setChecked(True)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.ChoiceWizard","title":"<code>ChoiceWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>ChoiceWizard class.</p> <p>Build a widget to choose a integer, float or string from a list.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class ChoiceWizard(QtCore.QObject):\n    \"\"\"\n    ChoiceWizard class.\n\n    Build a widget to choose a integer, float or string from a list.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        self.buttons = QtWidgets.QButtonGroup(layout)\n        for v in wizard[\"choices\"]:\n            button = QtWidgets.QRadioButton(str(v))\n            self.buttons.addButton(button)\n            button.setChecked(v == wizard[\"value\"])\n            layout.addWidget(button)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(self.buttons.checkedButton().text())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.ChoiceWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    self.buttons = QtWidgets.QButtonGroup(layout)\n    for v in wizard[\"choices\"]:\n        button = QtWidgets.QRadioButton(str(v))\n        self.buttons.addButton(button)\n        button.setChecked(v == wizard[\"value\"])\n        layout.addWidget(button)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.ChoiceWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(self.buttons.checkedButton().text())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.InputWizard","title":"<code>InputWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>InputWizard class.</p> <p>Build a widget to input an integer, float or string.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class InputWizard(QtCore.QObject):\n    \"\"\"\n    InputWizard class.\n\n    Build a widget to input an integer, float or string.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        match self.wizard[\"type\"]:\n            case \"integer\":\n                self.input = QtWidgets.QSpinBox()\n                self.input.setValue(int(self.wizard.get(\"value\", 0)))\n            case \"floating\":\n                self.input = QtWidgets.QDoubleSpinBox()\n                self.input.setValue(float(self.wizard.get(\"value\", 0.0)))\n            case \"str\":\n                self.input = QtWidgets.QLineEdit()\n                self.input.setText(self.wizard.get(\"value\", \"\"))\n        layout.addWidget(self.input)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(self.input.text())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.InputWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    match self.wizard[\"type\"]:\n        case \"integer\":\n            self.input = QtWidgets.QSpinBox()\n            self.input.setValue(int(self.wizard.get(\"value\", 0)))\n        case \"floating\":\n            self.input = QtWidgets.QDoubleSpinBox()\n            self.input.setValue(float(self.wizard.get(\"value\", 0.0)))\n        case \"str\":\n            self.input = QtWidgets.QLineEdit()\n            self.input.setText(self.wizard.get(\"value\", \"\"))\n    layout.addWidget(self.input)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.InputWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(self.input.text())\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.MessageWizard","title":"<code>MessageWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>MessageWizard class.</p> <p>Build a widget to display a message.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class MessageWizard(QtCore.QObject):\n    \"\"\"\n    MessageWizard class.\n\n    Build a widget to display a message.\n    \"\"\"\n\n    response: qtSignal = qtSignal(str)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        layout.setAlignment(QtCore.Qt.AlignHCenter)\n        parent.setLayout(layout)\n\n        self.input = QtWidgets.QLabel()\n        self.input.setText(self.wizard.get(\"value\", False))\n        layout.addWidget(self.input)\n\n        send_button = QtWidgets.QPushButton(\"Ok\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        self.response.emit(\"\")\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.MessageWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    layout.setAlignment(QtCore.Qt.AlignHCenter)\n    parent.setLayout(layout)\n\n    self.input = QtWidgets.QLabel()\n    self.input.setText(self.wizard.get(\"value\", False))\n    layout.addWidget(self.input)\n\n    send_button = QtWidgets.QPushButton(\"Ok\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.MessageWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    self.response.emit(\"\")\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.SelectWizard","title":"<code>SelectWizard</code>","text":"<p>               Bases: <code>QObject</code></p> <p>SelectWizard class.</p> <p>Build a widget to select one or more integer, float or string from a list.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class SelectWizard(QtCore.QObject):\n    \"\"\"\n    SelectWizard class.\n\n    Build a widget to select one or more integer, float or string from a list.\n    \"\"\"\n\n    response: qtSignal = qtSignal(list)\n\n    def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            wizard: wizard request\n            parent: the parent widget\n        \"\"\"\n        super().__init__()\n        self.wizard = wizard\n\n        layout = QtWidgets.QVBoxLayout()\n        parent.setLayout(layout)\n\n        self.buttons = []\n        for v in wizard[\"choices\"]:\n            button = QtWidgets.QCheckBox(str(v))\n            self.buttons.append(button)\n            button.setChecked(v in wizard[\"value\"])\n            layout.addWidget(button)\n        send_button = QtWidgets.QPushButton(\"Send\")\n        layout.addWidget(send_button)\n        send_button.clicked.connect(self.send)\n\n    @qtSlot()\n    def send(self, clicked: bool):\n        \"\"\"\n        Send chosen value to parent dialog on Send button click.\n        \"\"\"\n        print([button.text() for button in self.buttons if button.isChecked()])\n        self.response.emit([button.text() for button in self.buttons if button.isChecked()])\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.SelectWizard.__init__","title":"<code>__init__(wizard, parent)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>wizard</code> <code>dict[str, Any]</code> <p>wizard request</p> required <code>parent</code> <code>QWidget</code> <p>the parent widget</p> required Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, wizard: dict[str, Any], parent: QtWidgets.QWidget):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        wizard: wizard request\n        parent: the parent widget\n    \"\"\"\n    super().__init__()\n    self.wizard = wizard\n\n    layout = QtWidgets.QVBoxLayout()\n    parent.setLayout(layout)\n\n    self.buttons = []\n    for v in wizard[\"choices\"]:\n        button = QtWidgets.QCheckBox(str(v))\n        self.buttons.append(button)\n        button.setChecked(v in wizard[\"value\"])\n        layout.addWidget(button)\n    send_button = QtWidgets.QPushButton(\"Send\")\n    layout.addWidget(send_button)\n    send_button.clicked.connect(self.send)\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.SelectWizard.send","title":"<code>send(clicked)</code>","text":"<p>Send chosen value to parent dialog on Send button click.</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>@qtSlot()\ndef send(self, clicked: bool):\n    \"\"\"\n    Send chosen value to parent dialog on Send button click.\n    \"\"\"\n    print([button.text() for button in self.buttons if button.isChecked()])\n    self.response.emit([button.text() for button in self.buttons if button.isChecked()])\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.WizardDialog","title":"<code>WizardDialog</code>","text":"<p>               Bases: <code>QDialog</code></p> <p>WizardDialog class</p> <p>Build a modal for wizard request.</p> <p>Attributes:</p> Name Type Description <code>property_updated</code> <p>Qt signal emitted when a property is updated</p> <code>closed</code> <p>Qt signal emitted when the window is hidden</p> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>class WizardDialog(QtWidgets.QDialog):\n    \"\"\"\n    WizardDialog class\n\n    Build a modal for wizard request.\n\n    Attributes:\n        property_updated: Qt signal emitted when a property is updated\n        closed: Qt signal emitted when the window is hidden\n    \"\"\"\n\n    response: qtSignal = qtSignal(dict)\n\n    def __init__(self, message: dict[str, Any], parent: QtWidgets.QWidget = None):\n        \"\"\"\n        Class constructor.\n\n        Arguments:\n            message: JSON Schema of properties with current values and namespace\n            parent: The parent widget\n        \"\"\"\n        super().__init__(parent)\n        self.message = message\n        self.setWindowTitle(self.message[\"name\"])\n        self.setModal(False)\n        self.setMinimumWidth(300)\n\n        match wizard_type := self.message[\"type\"]:\n            case \"boolean\":\n                self.wizard = BooleanWizard(self.message, self)\n            case \"integer\" | \"floating\" | \"str\":\n                self.wizard = InputWizard(self.message, self)\n            case \"message\":\n                self.wizard = MessageWizard(self.message, self)\n            case \"choice_integer\" | \"choice_floating\" | \"choice_str\":\n                self.wizard = ChoiceWizard(self.message, self)\n            case \"select_integer\" | \"select_floating\" | \"select_str\":\n                self.wizard = SelectWizard(self.message, self)\n            case \"camp\":\n                self.wizard = CampWizard(self.message, self)\n            case _:\n                logger.warning(f\"Wizard message '{wizard_type} unsupported'\")\n                return\n\n        self.wizard.response.connect(self.respond)\n        self.rejected.connect(self.force_close)\n\n    def respond(self, response: str | list[str]):\n        self.message[\"value\"] = response\n        self.response.emit(self.message)\n        self.accept()\n\n    def force_close(self):\n        self.message[\"value\"] = None\n        self.response.emit(self.message)\n        self.accept()\n</code></pre>"},{"location":"reference/cogip/widgets/wizard/#cogip.widgets.wizard.WizardDialog.__init__","title":"<code>__init__(message, parent=None)</code>","text":"<p>Class constructor.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>dict[str, Any]</code> <p>JSON Schema of properties with current values and namespace</p> required <code>parent</code> <code>QWidget</code> <p>The parent widget</p> <code>None</code> Source code in <code>cogip/widgets/wizard.py</code> <pre><code>def __init__(self, message: dict[str, Any], parent: QtWidgets.QWidget = None):\n    \"\"\"\n    Class constructor.\n\n    Arguments:\n        message: JSON Schema of properties with current values and namespace\n        parent: The parent widget\n    \"\"\"\n    super().__init__(parent)\n    self.message = message\n    self.setWindowTitle(self.message[\"name\"])\n    self.setModal(False)\n    self.setMinimumWidth(300)\n\n    match wizard_type := self.message[\"type\"]:\n        case \"boolean\":\n            self.wizard = BooleanWizard(self.message, self)\n        case \"integer\" | \"floating\" | \"str\":\n            self.wizard = InputWizard(self.message, self)\n        case \"message\":\n            self.wizard = MessageWizard(self.message, self)\n        case \"choice_integer\" | \"choice_floating\" | \"choice_str\":\n            self.wizard = ChoiceWizard(self.message, self)\n        case \"select_integer\" | \"select_floating\" | \"select_str\":\n            self.wizard = SelectWizard(self.message, self)\n        case \"camp\":\n            self.wizard = CampWizard(self.message, self)\n        case _:\n            logger.warning(f\"Wizard message '{wizard_type} unsupported'\")\n            return\n\n    self.wizard.response.connect(self.respond)\n    self.rejected.connect(self.force_close)\n</code></pre>"},{"location":"usage/beaconcam/","title":"Beaconcam","text":"<p>Not yet available.</p>"},{"location":"usage/camera/","title":"Camera","text":"<p>The <code>Camera</code> tool provides different commands to get information about cameras, calibrate them and detect Aruco tags.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-camera --help\nUsage: cogip-camera [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -d, --debug           Turn on debug messages\n                        env var: COGIP_DEBUG, CAMERA_DEBUG\n\n  --help                Show this message and exit.\n\nCommands:\n  calibrate  Calibrate camera using images captured by the 'capture' command\n  capture    Capture images to be used by the 'calibrate' command\n  info       Get properties of connected cameras\n</code></pre>"},{"location":"usage/camera/#info-command","title":"Info Command","text":"<p>Display properties of connected cameras.</p> <p>If a camera name is provided, only display properties of this camera and preview its video stream. Codec, width and height arguments apply only in this context.</p> <pre><code>$ cogip-camera info --help\nUsage: cogip-camera info [OPTIONS]\n\n  Get properties of connected cameras\n\nOptions:\n  --camera-name [hbv|sonix]   Name of the camera (all if not specified)\n                              env var: CAMERA_NAME\n\n  --camera-codec [mjpg|yuyv]  Camera video codec\n                              env var: CAMERA_CODEC\n                              default: yuyv\n\n  --camera-width INTEGER      Camera frame width\n                              env var: CAMERA_WIDTH\n                              default: 640\n\n  --camera-height INTEGER     Camera frame height\n                              env var: CAMERA_HEIGHT\n                              default: 480\n\n  --help                      Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#capture-command","title":"Capture Command","text":"<p>Capture images to be used by the <code>calibrate</code> command.</p> <p>Use <code>--max-frames</code> and <code>--capture-interval</code> options to customize the number of images to capture and the frequency of capture.</p> <p>To be valid for calibration, the images must contained a charuco board with different orientations on each image. Use <code>--charuco-*</code> options to configure the Charuco board used for calibration.</p> <p>The captured images will be displayed after charuco board detection.</p> <p>The Charuco board generated for detection is also displayed for comparison with the board on images.</p> <p>Images are stored in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/images</code>.</p> <pre><code>$ cogip-camera capture --help\nUsage: cogip-camera capture [OPTIONS]\n\n  Capture images to be used by the 'calibrate' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 640\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 480\n\n  --max-frames INTEGER            Maximum number of frames to read before exiting\n                                  env var: CAMERA_MAX_FRAMES\n                                  default: 120\n\n  --capture-interval INTEGER      Capture an image every 'capture_interval' frames\n                                  env var: CAMERA_CAPTURE_INTERVAL\n                                  default: 10\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: no-charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/camera/#calibrate-command","title":"Calibrate Command","text":"<p>Generate intrinsic calibration parameters using images recorded by the <code>capture</code> command.</p> <p>The parameter file is written in <code>cameras/&lt;robot_id&gt;/&lt;camera_name&gt;_&lt;camera_codec&gt;_&lt;camera_width&gt;x&lt;camera_height&gt;/params.yaml</code>.</p> <pre><code>$ cogip-camera calibrate --help\nUsage: cogip-camera calibrate [OPTIONS]\n\n  Calibrate camera using images captured by the 'capture' command\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, CAMERA_ID\n                                  default: 1, x&gt;=0\n\n  --camera-name [hbv|sonix]       Name of the camera\n                                  env var: CAMERA_NAME\n                                  default: hbv\n\n  --camera-codec [mjpg|yuyv]      Camera video codec\n                                  env var: CAMERA_CODEC\n                                  default: yuyv\n\n  --camera-width INTEGER          Camera frame width\n                                  env var: CAMERA_WIDTH\n                                  default: 640\n\n  --camera-height INTEGER         Camera frame height\n                                  env var: CAMERA_HEIGHT\n                                  default: 480\n\n  --charuco-rows INTEGER          Number of rows on the Charuco board\n                                  env var: CAMERA_CHARUCO_ROWS\n                                  default: 8\n\n  --charuco-cols INTEGER          Number of columns on the Charuco board\n                                  env var: CAMERA_CHARUCO_COLS\n                                  default: 13\n\n  --charuco-marker-length INTEGER\n                                  Length of an Aruco marker on the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_MARKER_LENGTH\n                                  default: 23\n\n  --charuco-square-length INTEGER\n                                  Length of a square in the Charuco board (in mm)\n                                  env var: CAMERA_CHARUCO_SQUARE_LENGTH\n                                  default: 30\n\n  --charuco-legacy / --no-charuco-legacy\n                                  Use Charuco boards compatible with OpenCV &lt; 4.6\n                                  env var: CAMERA_CHARUCO_LEGACY\n                                  default: no-charuco-legacy\n\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"usage/cansend/","title":"cansend","text":"<p>Helper tool to send CAN command on a CAN bus using COGIP messages.</p> <p>Use <code>--help</code> argument to show available commands:</p> <pre><code>$ cogip-cansend --help\nUsage: cogip-cansend [OPTIONS]\n\nOptions:\n  -c, --can-channel TEXT      CAN channel connected to STM32 modules\n                              env var: CANSEND_CAN_CHANNEL\n                              default: vcan0\n\n  -b, --can-bitrate INTEGER   CAN bitrate\n                              env var: CANSEND_CAN_BITRATE\n                              default: 500000\n\n  -B, --data-bitrate INTEGER  CAN FD data bitrate\n                              env var: CANSEND_CANFD_DATA_BITRATE\n                              default: 1000000\n\n  -c, --commands FILENAME     YAML file containing\n                              env var: CANSEND_COMMANDS\n                              default: 1000000\n\n  --help                      Show this message and exit.\n</code></pre> <p>The list of commands to send is provided using a YAML file.</p> <p>The commands are defined in <code>cogip/models/actuators.py</code>, like ServoCommand and PositionalActuatorCommand.</p> <p>Enum attributes can be specified by their name or value.</p> <p>Example:</p> <pre><code>- kind: 0\n  id: LXSERVO_LEFT_CART\n  command: 100\n\n- kind: POSITIONAL\n  id: 2\n  command: 1\n</code></pre>"},{"location":"usage/copilot/","title":"Copilot","text":"<p>The <code>Copilot</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates with <code>mcu-firmware</code> on the robot's STM32 over a serial port using Protobuf messages.</p> <p>It communicates on the <code>/copilot</code> namespace of the SocketIO server running on the central beacon over Wifi.</p>"},{"location":"usage/copilot/#data-flow","title":"Data Flow","text":""},{"location":"usage/copilot/#run-copilot","title":"Run Copilot","text":"<pre><code>$ cogip-copilot\n</code></pre>"},{"location":"usage/copilot/#parameters","title":"Parameters","text":"<p><code>Copilot</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-copilot --help\nUsage: cogip-copilot [OPTIONS]\n\nOptions:\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, COPILOT_ID\n                                  default: 1; x&gt;=1\n\n  -p, --serial-port PATH          Serial port connected to STM32 device\n                                  env var: COPILOT_SERIAL_PORT\n                                  default: /dev/ttyUSB0\n\n  -b, --serial-baudrate INTEGER   Baud rate\n                                  env var: COPILOT_BAUD_RATE\n                                  default: 230400\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, COPILOT_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, COPILOT_DEBUG\n</code></pre>"},{"location":"usage/dashboard/","title":"Dashboard","text":"<p>The <code>Dashboard</code> is a web site displayed on the touchscreens embedded in the robots.</p> <p>The web server can also be accessed from any devices (PC, smartphones) connected to the same network.</p> <p>The web server listen on port <code>8080 + robot_id</code>, ie <code>8081</code> on robot 1.</p> <p></p>"},{"location":"usage/dashboard/#data-flow","title":"Data Flow","text":""},{"location":"usage/dashboard_beacon/","title":"Beacon Dashboard","text":"<p>The <code>Beacon Dashboard</code> is a web site displayed on the touchscreens embedded the central beacon. It provides a menu and a dashboard to monitor all robots, and give access to the dashboard of each robot.</p> <p>The web server can also be accessed from any devices (PC, smartphones) connected to the same network.</p> <p>The web server listen on port <code>8080</code>.</p> <p>To access to robot dashboards, the beacon dashboard considers that robot hostnames are <code>robot1</code> to <code>robotN</code>, resolved by the DNS server or defined in <code>/etc/hosts</code> and the dashboard ports are <code>8080 + robot_id</code>.</p>"},{"location":"usage/detector/","title":"Detector","text":"<p>The <code>Detector</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/detector</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It builds dynamic obstacles used by <code>Monitor</code>/<code>Dashboards</code> for display and by <code>mcu-firmware</code> to compute avoidance path.</p> <p><code>Detector</code> can operate in monitoring or emulation mode.</p>"},{"location":"usage/detector/#monitoring-mode","title":"Monitoring Mode","text":"<p>Read data from lidar connected on a serial port of the Raspberry Pi. This is the default mode when a Lidar is connected, since the YDLidar SDK automatically detects the serial port to use.</p>"},{"location":"usage/detector/#emulation-mode","title":"Emulation Mode","text":"<p>Ask the <code>Monitor</code> to emulate the Lidar which sends its data through the SocketIO server. The emulation mode is enabled if no Lidar is detected at startup. In case of a false detection, use the <code>--emulation</code> option.</p>"},{"location":"usage/detector/#data-flow","title":"Data Flow","text":""},{"location":"usage/detector/#run-detector","title":"Run Detector","text":"<pre><code>$ cogip-detector\n</code></pre>"},{"location":"usage/detector/#parameters","title":"Parameters","text":"<p><code>Detector</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-detector --help\nUsage: cogip-detector [OPTIONS]\n\nOptions:\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID, DETECTOR_ID\n                                  default: 1; x&gt;=1\n\n  -p, --lidar-port PATH           Serial port connected to the Lidar\n                                  env var: DETECTOR_LIDAR_PORT\n                                  default: None (autodetect)\n\n  --min-distance INTEGER          Minimum distance to detect an obstacle\n                                  env var: DETECTOR_MIN_DISTANCE\n                                  default: 150\n\n  --max-distance INTEGER          Maximum distance to detect an obstacle\n                                  env var: DETECTOR_MAX_DISTANCE\n                                  default: 2500\n\n  --beacon-radius INTEGER         Radius of the opponent beacon support\n                                  (a cylinder of 70mm diameter to a cube of 100mm width)\n                                  env var: DETECTOR_BEACON_RADIUS\n                                  default: 35\n\n  --refresh-interval FLOAT        Interval between each update of the obstacle list (in seconds)\n                                  env var: DETECTOR_REFRESH_INTERVAL\n                                  default: 0.2\n\n  -r, --reload                    Reload app on source file changes.\n                                  env var: COGIP_RELOAD, DETECTOR_RELOAD\n\n  -d, --debug                     Turn on debug messages.\n                                  env var: COGIP_DEBUG, DETECTOR_DEBUG\n</code></pre>"},{"location":"usage/lidarusb/","title":"Lidar USB Viewer","text":"<p>This tool displays a graphical view to render data provided by a YDLidar G2 connected to USB port.</p> <p>After installation (see Install), the <code>Lidar USB Viewer</code> is launched with:</p> <pre><code>$ cogip-lidarusb\n</code></pre> <p>The serial port is detected automatically by the YDLidar SDK, so this tool has no specific options.</p>"},{"location":"usage/lidarusb/#interface","title":"Interface","text":"<p>The graphical interface provides a polar chart and table view.</p> <p></p> <p></p>"},{"location":"usage/lidarusb/#polar-chart","title":"Polar Chart","text":"<p>Two kind of values are drawn on the chart:</p> <ul> <li> <p>distance values for each degree (in millimeters)</p> </li> <li> <p>intensity values for each degree</p> </li> </ul> <p>Below the chart, the <code>Max Distance</code> and <code>Max Intensity</code> sliders allow to zoom on the distance and intensity axes.</p> <p>The <code>Distance filter</code> slider can be enabled/disabled using the checkbox. If disabled, distance values displayed on the charts are raw data. If enables, a filter is applied to drop corrupted values and limit the detection to the maximum distance selected by the slider.</p>"},{"location":"usage/lidarusb/#table","title":"Table","text":"<p>The table on the right of the window presents the same data as the chart but in numeric format.</p>"},{"location":"usage/monitor/","title":"Monitor","text":"<p>The <code>Monitor</code> is used to monitor the robot behavior during the game.</p> <p>It communicates on the <code>/monitor</code> and <code>/dashboard</code> namespaces of the SocketIO server running on the central beacon over Wifi.</p> <p>Only one <code>Monitor</code> can be connected to the SocketIO server at the same time.</p> <p>It can also provide fake Lidar data to <code>Detector</code> in emulation mode.</p> <p>The monitor provides a graphical interface, featuring:</p> <ul> <li> <p>a 3D view of the table and the robot</p> </li> <li> <p>a menu giving access to the planner menu and firmware's shell menu</p> </li> <li> <p>a button to add obstacles (in grey), move and resize them</p> </li> <li> <p>save and load obstacles using JSON files</p> </li> <li> <p>visualization of ToF (red dots) and LIDAR (blue dots) sensors detections</p> </li> <li> <p>visualization of obstacles detected using the Lidar (in transparent red)</p> </li> <li> <p>charts window to visualize calibration data</p> </li> <li> <p>dashboard window to visualize the <code>Dashboard</code></p> </li> <li> <p>different artifacts depending of current game rules</p> </li> </ul> <p></p> <p></p>"},{"location":"usage/monitor/#data-flow","title":"Data Flow","text":""},{"location":"usage/monitor/#run-monitor","title":"Run Monitor","text":"<p>To connect the <code>Monitor</code> to the <code>Server</code> running on the same development PC, run:</p> <pre><code>cogip-monitor http://localhost:8091\n</code></pre> <p>To connect the <code>Monitor</code> to the <code>Server</code> running on the Raspberry Pi in the robot, run:</p> <pre><code>cogip-monitor http://robot1:8091\n</code></pre> <p>Adapt URL and port depending on <code>Server</code> configuration</p>"},{"location":"usage/monitor/#command-line-options","title":"Command line options","text":"<pre><code>$ cogip-monitor --help\nUsage: cogip-monitor [URL]\n\n  Launch COGIP Monitor.\n\nArguments:\n  [URL]        Socket.IO Server URL\n               env var: COGIP_SOCKETIO_SERVER_URL\n               default: http://localhost:8091\n</code></pre>"},{"location":"usage/planner/","title":"Planner","text":"<p>The <code>Planner</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It is in charge computing the strategy and giving orders to the robot during the game.</p> <p>It communicates on the <code>/planner</code> namespace of the SocketIO server.</p>"},{"location":"usage/planner/#data-flow","title":"Data Flow","text":""},{"location":"usage/planner/#run-planner","title":"Run Planner","text":"<pre><code>$ cogip-planner\n</code></pre>"},{"location":"usage/planner/#parameters","title":"Parameters","text":"<p><code>Planner</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-planner --help\nUsage: cogip-planner [OPTIONS]\n\nOptions:\n  -i, --id INTEGER RANGE          Robot ID.\n                                  env var: ROBOT_ID\n                                  default: 1; x&gt;=1\n\n  --server-url TEXT               Socket.IO Server URL\n                                  env var: COGIP_SOCKETIO_SERVER_URL\n                                  default: None\n\n  --obstacle-radius INTEGER       Radius of a dynamic obstacle\n                                  env var: PLANNER_OBSTACLE_RADIUS\n                                  default: 500\n\n  --obstacle-bb-margin FLOAT      Obstacle bounding box margin in percent of the radius\n                                  env var: PLANNER_OBSTACLE_BB_MARGIN\n                                  default: 0.2\n\n  --obstacle-bb-vertices INTEGER  Number of obstacle bounding box vertices\n                                  env var: PLANNER_OBSTACLE_BB_VERTICES\n                                  default: 6\n\n  --obstacle-sender-interval FLOAT\n                                  Interval between each send of obstacles to dashboards (in seconds)\n                                  env var: PLANNER_OBSTACLE_SENDER_INTERVAL\n                                  default: 0.2\n\n  --path-refresh-interval FLOAT   Interval between each update of robot paths (in seconds)\n                                  env var: PLANNER_PATH_REFRESH_INTERVAL\n                                  default: 0.2\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/replay/","title":"Replay","text":"<p>The replay tool is used to replay a game from a trace file.</p> <p></p> <p>After installation (see Install), the replay tool is launched with:</p> <pre><code>$ cogip-replay\n</code></pre> <p>The replay tool is used to replay a game from a trace file.</p>"},{"location":"usage/replay/#command-line-options","title":"Command line options","text":"<pre><code>$ $ cogip-replay --help\nUsage: cogip-replay [OPTIONS] [TRACE_FILE]\n\n  Starts replay.\n\nArguments:\n  [TRACE_FILE]\n\nOptions:\n  --help                          Show this message and exit.\n</code></pre> <p>The trace file can be given on the command line or loaded from the UI.</p>"},{"location":"usage/robotcam/","title":"RobotCam","text":"<p>The <code>RobotCam</code> tool is running on the Raspberry Pi embedded in the robot.</p> <p>It communicates on the <code>/robotcam</code> namespace of the SocketIO server running on the central beacon over Wifi.</p> <p>It handles the robot camera, detect game elements using Aruco markers and stream the video to a web server.</p> <p>The web server listen on port <code>8100 + robot_id</code>, ie <code>8100</code> on the beacon or <code>8101</code> on robot 1.</p>"},{"location":"usage/robotcam/#run-robotcam","title":"Run RobotCam","text":"<pre><code>$ cogip-robocam\n</code></pre>"},{"location":"usage/robotcam/#parameters","title":"Parameters","text":"<p>RobotCam default parameters can be modified using environment variables. All variables can be defined in the <code>.env</code> file.</p> <p>Example of <code>.env</code> file with all default values:</p> <pre><code># Socket.IO Server URL\nCOGIP_SOCKETIO_SERVER_URL=\"http://localhost:8091\"\n\n# Robot ID\nROBOTCAM_ID=1\n\n# Camera name\nROBOTCAM_CAMERA_NAME=\"hbv\"\n\n# Camera frame width\nROBOTCAM_CAMERA_WIDTH=640\n\n# Camera frame height\nROBOTCAM_CAMERA_HEIGHT=480\n\n# Camera video codec\nROBOTCAM_CAMERA_CODEC=\"yuyv\"\n\n# Number of uvicorn workers (ignored if launched by gunicorn)\nROBOTCAM_NB_WORKERS=1\n\n# Size of the shared memory storing the last frame to stream on server\n# (size for a frame in BMP format, black and white, 640x480 pixels)\nROBOTCAM_FRAME_SIZE=308316\n</code></pre>"},{"location":"usage/server/","title":"Server","text":"<p>The <code>Server</code> tool is running on the Raspberry Pi embedded in a robot.</p> <p>It implements a Socket.IO server on which all other tools from robot and central beacon are connected on their own namespace. This server is only used to redirect messages from a tool to another.</p> <p>The Socket.IO server listen on port <code>8090 + robot_id</code>, ie <code>8091</code> on robot 1.</p>"},{"location":"usage/server/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server\n</code></pre>"},{"location":"usage/server/#parameters","title":"Parameters","text":"<p><code>Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --id , -i INTEGER RANGE         Robot ID\n                                  env var: ROBOT_ID, SERVER_ID\n                                  default: 0; 0&lt;=x&lt;=9\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, PLANNER_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, PLANNER_DEBUG\n</code></pre>"},{"location":"usage/server_beacon/","title":"Beacon Server","text":"<p>The <code>Beacon Server</code> tool is running on the Raspberry Pi embedded in the central beacon.</p> <p>It implements a Socket.IO server connected to the <code>Beacon Dashboard</code>.</p> <p>The Socket.IO server listens on port <code>8090</code>.</p> <p>It also implements Socket.IO clients connected to the Socket.IO server of each robot.</p> <p>Socket.IO clients consider that robot hostnames are <code>robot1</code> to <code>robotN</code>, resolved by the DNS server or defined in <code>/etc/hosts</code> and their ports are <code>8090 + robot_id</code>.</p>"},{"location":"usage/server_beacon/#run-server","title":"Run Server","text":"<pre><code>$ cogip-server-beacon\n</code></pre>"},{"location":"usage/server_beacon/#parameters","title":"Parameters","text":"<p><code>Beacon Server</code> default parameters can be modified using command line options or environment variables:</p> <pre><code>$ cogip-server --help\nUsage: cogip-server [OPTIONS]\n\n  --max-robots                    Maximum number of robots to detect (from 1 to max)\n                                  env var: SERVER_BEACON_MAX_ROBOTS\n                                  default: 4; x&gt;=1\n\n  --record-dir PATH               Directory where games will be recorded\n                                  env var: SERVER_BEACON_RECORD_DIR\n                                  default: /var/tmp/cogip\n\n  -r, --reload                    Reload app on source file changes\n                                  env var: COGIP_RELOAD, SERVER_BEACON_RELOAD\n\n  -d, --debug                     Turn on debug messages\n                                  env var: COGIP_DEBUG, SERVER_BEACON_DEBUG\n</code></pre>"}]}